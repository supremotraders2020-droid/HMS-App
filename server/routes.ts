import express, { type Express } from "express";
import { createServer, type Server } from "http";
import path from "path";
import fs from "fs";
import bcrypt from "bcrypt";
import crypto from "crypto";
import bwipjs from "bwip-js";
import multer from "multer";
import { z } from "zod";
import { HMS_MODULES, HMS_ACTIONS, DEFAULT_PERMISSIONS } from "../shared/permissions";
import { storage } from "./storage";
import { databaseStorage } from "./database-storage";
import { db, pool } from "./db";
import { eq, desc, and, sql, or } from "drizzle-orm";
import { users, doctors, doctorProfiles, insertAppointmentSchema, insertInventoryItemSchema, insertInventoryTransactionSchema, insertStaffMemberSchema, insertInventoryPatientSchema, insertTrackingPatientSchema, insertMedicationSchema, insertMealSchema, insertVitalsSchema, insertDoctorVisitSchema, insertConversationLogSchema, insertServicePatientSchema, insertAdmissionSchema, insertMedicalRecordSchema, insertBiometricTemplateSchema, insertBiometricVerificationSchema, insertNotificationSchema, insertHospitalTeamMemberSchema, insertActivityLogSchema, insertEquipmentSchema, insertServiceHistorySchema, insertEmergencyContactSchema, insertHospitalSettingsSchema, insertPrescriptionSchema, insertDoctorScheduleSchema, insertDoctorPatientSchema, insertUserSchema, insertDoctorTimeSlotSchema, type InsertDoctorTimeSlot,
  patientBarcodes, insertPatientBarcodeSchema, barcodeScanLogs, insertBarcodeScanLogSchema, servicePatients,
  patientMonitoringSessions, insertPatientMonitoringSessionSchema,
  vitalsHourly, insertVitalsHourlySchema,
  inotropesSedation, insertInotropesSedationSchema,
  ventilatorSettings, insertVentilatorSettingsSchema,
  abgLabResults, insertAbgLabResultsSchema,
  intakeHourly, insertIntakeHourlySchema,
  outputHourly, insertOutputHourlySchema,
  diabeticFlow, insertDiabeticFlowSchema,
  medicationAdminRecords, insertMedicationAdminRecordSchema,
  onceOnlyDrugs, insertOnceOnlyDrugSchema,
  nursingShiftNotes, insertNursingShiftNoteSchema,
  airwayLinesTubes, insertAirwayLinesTubesSchema,
  dutyStaffAssignments, insertDutyStaffAssignmentSchema,
  patientAllergiesPrecautions, insertPatientAllergiesPrecautionsSchema,
  ipdInvestigationChart, insertIpdInvestigationChartSchema,
  patientMonitoringAuditLog, insertPatientMonitoringAuditLogSchema,
  ipdCarePlans, insertIpdCarePlanSchema,
  ipdCarePlanNotes, insertIpdCarePlanNotesSchema,
  ipdInitialAssessment, insertIpdInitialAssessmentSchema,
  indoorConsultationSheet, insertIndoorConsultationSheetSchema,
  doctorsProgressSheet, insertDoctorsProgressSheetSchema,
  doctorsVisitSheet, insertDoctorsVisitSheetSchema,
  surgeryNotes, insertSurgeryNotesSchema,
  nursingProgressSheet, insertNursingProgressSheetSchema,
  nursingAssessmentCarePlan, insertNursingAssessmentCarePlanSchema,
  // Bed Management
  bedCategories, insertBedCategorySchema,
  beds, insertBedSchema,
  bedTransfers, insertBedTransferSchema,
  bedAllocations, insertBedAllocationSchema,
  bedAuditLog, insertBedAuditLogSchema,
  // Blood Bank
  bloodServiceGroups, insertBloodServiceGroupSchema,
  bloodServices, insertBloodServiceSchema,
  bloodDonors, insertBloodDonorSchema,
  bloodUnits, insertBloodUnitSchema,
  bloodStorageFacilities, insertBloodStorageFacilitySchema,
  bloodTemperatureLogs, insertBloodTemperatureLogSchema,
  bloodTransfusionOrders, insertBloodTransfusionOrderSchema,
  bloodTransfusionReactions, insertBloodTransfusionReactionSchema,
  bloodBankAuditLog, insertBloodBankAuditLogSchema,
  medicalStores, insertMedicalStoreSchema,
  medicalStoreUsers, insertMedicalStoreUserSchema,
  medicalStoreInventory, insertMedicalStoreInventorySchema,
  prescriptionDispensing, insertPrescriptionDispensingSchema,
  dispensingItems, insertDispensingItemSchema,
  medicalStoreAccessLogs, insertMedicalStoreAccessLogSchema,
  medicalStoreBills, insertMedicalStoreBillSchema,
  prescriptions,
  insertLabTestOrderSchema,
  // OPD Prescription Templates
  opdPrescriptionTemplates, insertOpdPrescriptionTemplateSchema,
  opdTemplateVersions, insertOpdTemplateVersionSchema,
  // ID Card Scanning & Alert System
  idCardScans, insertIdCardScanSchema,
  criticalAlerts, insertCriticalAlertSchema,
  // Super Admin Tables
  auditLogs, insertAuditLogSchema,
  financialLocks, insertFinancialLockSchema,
  rolePermissions, insertRolePermissionSchema,
  billingRecords, insertBillingRecordSchema,
  stockBatches, insertStockBatchSchema,
  surgeryPackages, insertSurgeryPackageSchema,
  insuranceProviders, insertInsuranceProviderSchema,
  insuranceClaims, insertInsuranceClaimSchema,
  hospitalPackages, insertHospitalPackageSchema,
  overrideRequests, insertOverrideRequestSchema,
  medicineCatalog, insertMedicineCatalogSchema,
  // Smart OPD Flow Engine
  opdDepartmentFlows, insertOpdDepartmentFlowsSchema,
  opdConsultations, insertOpdConsultationsSchema,
  // ICU Monitoring
  insertIcuChartsSchema, insertIcuVitalChartsSchema, insertIcuHemodynamicMonitoringSchema,
  insertIcuSedationMonitoringSchema, insertIcuVentilatorSettingsSchema, insertIcuAbgReportsSchema,
  insertIcuAirwayCareSchema, insertIcuDailyInvestigationsSchema, insertIcuDiabeticChartSchema,
  insertIcuPlayOfDaySchema, insertIcuCuffPressureSchema, insertIcuEttTracheostomySchema,
  insertIcuDurationSchema, insertIcuFluidBalanceTargetSchema, insertIcuIntakeChartSchema,
  insertIcuOutputChartSchema, insertIcuMedicationOrdersSchema, insertIcuNursingRemarksSchema,
  insertIcuNursingDutySchema, insertIcuFluidOrdersSchema, insertIcuNutritionChartSchema,
  insertIcuBodyMarkingSchema, insertIcuNurseDiarySchema, insertIcuOnceOnlyDrugsSchema,
  insertIcuPreviousDayNotesSchema, insertIcuAllergyPrecautionsSchema,
  appointments, trackingPatients, patientConsents, patientBills, billPayments, patientInsurance, medicalRecords,
  patientMovementLog, insertPatientMovementLogSchema
} from "@shared/schema";
import { seedOpdDepartmentFlows, OPD_DEPARTMENT_FLOW_DATA } from "./seeds/opdDepartmentFlows";
import { getChatbotResponse, getChatbotStats } from "./openai";
import { notificationService } from "./notification-service";
import { aiEngines } from "./ai-engines";

const SALT_ROUNDS = 10;

// Generate secure random password (12 characters)
function generateSecurePassword(): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%';
  let password = '';
  for (let i = 0; i < 12; i++) {
    password += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return password;
}

// Configure multer for file uploads
const labReportStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(process.cwd(), 'uploads', 'lab-reports');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const ext = path.extname(file.originalname);
    cb(null, `lab-report-${uniqueSuffix}${ext}`);
  }
});

const uploadLabReport = multer({
  storage: labReportStorage,
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/jpg'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Only PDF and image files are allowed'));
    }
  }
});

// Authorization middleware for lab report uploads - runs BEFORE multer
const requireLabReportUploadAuth = (req: any, res: any, next: any) => {
  const session = req.session;
  const user = session?.user;
  
  if (!user) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  
  const allowedRoles = ["PATHOLOGY_LAB", "ADMIN"];
  if (!allowedRoles.includes(user.role)) {
    return res.status(403).json({ error: "Access denied. Only pathology lab staff and administrators can upload lab reports." });
  }
  
  next();
};

// General authentication middleware
const requireAuth = (req: any, res: any, next: any) => {
  const session = req.session;
  const user = session?.user;
  
  if (!user) {
    return res.status(401).json({ error: "Unauthorized. Please log in." });
  }
  
  // Populate req.user for downstream route handlers
  req.user = user;
  next();
};

// Role-based authorization middleware factory
const requireRole = (allowedRoles: string[]) => {
  return (req: any, res: any, next: any) => {
    const session = req.session;
    const user = session?.user;
    
    if (!user) {
      return res.status(401).json({ error: "Unauthorized. Please log in." });
    }
    
    if (!allowedRoles.includes(user.role)) {
      return res.status(403).json({ error: `Access denied. Required roles: ${allowedRoles.join(", ")}` });
    }
    
    next();
  };
};

// Permission-based authorization middleware factory
// Uses the centralized permission matrix stored in the database
type HMSModule = typeof HMS_MODULES[number];
type HMSAction = typeof HMS_ACTIONS[number];

const requirePermission = (module: HMSModule, action: HMSAction) => {
  return async (req: any, res: any, next: any) => {
    const session = req.session;
    const user = session?.user;
    
    if (!user) {
      return res.status(401).json({ error: "Unauthorized. Please log in." });
    }
    
    const role = user.role as string;
    
    // Super Admin has all permissions
    if (role === "SUPER_ADMIN") {
      return next();
    }
    
    try {
      // Check database for permission
      const permission = await storage.getRolePermission(role, module);
      
      // Map action to database field
      const actionFieldMap: Record<HMSAction, string> = {
        view: "canView",
        create: "canCreate",
        edit: "canEdit",
        delete: "canDelete",
        approve: "canApprove",
        lock: "canLock",
        unlock: "canUnlock",
        export: "canExport"
      };
      
      const field = actionFieldMap[action];
      
      // If permission exists in DB, use it; otherwise fall back to defaults
      let hasPermission = false;
      if (permission) {
        hasPermission = permission[field as keyof typeof permission] === true;
      } else {
        // Fall back to default permissions
        const defaults = DEFAULT_PERMISSIONS[role as keyof typeof DEFAULT_PERMISSIONS]?.[module];
        hasPermission = defaults?.[action] === true;
      }
      
      if (!hasPermission) {
        return res.status(403).json({ 
          error: `Access denied. You don't have permission to ${action} ${module.toLowerCase().replace("_", " ")}.`
        });
      }
      
      next();
    } catch (error) {
      console.error("Permission check error:", error);
      return res.status(500).json({ error: "Failed to verify permissions" });
    }
  };
};

export async function registerRoutes(app: Express): Promise<Server> {
  // Serve static files from server/public (body-diagram, hospital-logo, etc.)
  app.use(express.static(path.join(process.cwd(), 'server/public')));
  
  // Serve static consent PDF files from server/public/consents
  app.use('/consents', express.static(path.join(process.cwd(), 'server/public/consents')));
  
  // Authenticated lab report file downloads - protects PHI from unauthorized access
  app.get('/uploads/lab-reports/:filename', async (req, res) => {
    const session = (req.session as any);
    const user = session?.user;
    
    if (!user) {
      return res.status(401).json({ error: "Unauthorized. Please log in to access lab reports." });
    }
    
    // Only allow access for authorized roles (patient ownership checked at API level)
    const allowedRoles = ["ADMIN", "PATHOLOGY_LAB", "DOCTOR", "NURSE", "PATIENT"];
    if (!allowedRoles.includes(user.role)) {
      return res.status(403).json({ error: "Access denied." });
    }
    
    const filename = req.params.filename;
    const filePath = path.join(process.cwd(), 'uploads', 'lab-reports', filename);
    
    // Check if file exists
    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ error: "File not found" });
    }
    
    // Security: Prevent path traversal attacks
    const realPath = fs.realpathSync(filePath);
    const uploadsDir = fs.realpathSync(path.join(process.cwd(), 'uploads', 'lab-reports'));
    if (!realPath.startsWith(uploadsDir)) {
      return res.status(403).json({ error: "Access denied" });
    }
    
    // Set content disposition for download
    res.setHeader('Content-Disposition', `inline; filename="${filename}"`);
    res.sendFile(realPath);
  });
  
  // Seed initial data if database is empty
  await databaseStorage.seedInitialData();
  await databaseStorage.seedEquipmentData();
  await databaseStorage.seedBmwData();
  await databaseStorage.seedConsentTemplates();
  await databaseStorage.seedPathologyTests();
  await databaseStorage.seedHospitalServices();
  await databaseStorage.seedSystemTemplates();
  await databaseStorage.seedOtDemoData();
  
  // Ensure lab test order sequence exists for concurrency-safe order numbers
  await databaseStorage.ensureLabTestOrderSequence();
  
  // Registration endpoint - create new user with hashed password
  // Public registration is limited to PATIENT role only for security
  // Staff accounts (ADMIN, DOCTOR, NURSE, OPD_MANAGER) must be created by existing admins
  app.post("/api/auth/register", async (req, res) => {
    try {
      const { username, password, firstName, lastName, email } = req.body;
      
      // Validate required fields (role is not required - always PATIENT for self-registration)
      if (!username || !password) {
        return res.status(400).json({ error: "Username and password are required" });
      }
      
      // Validate password strength
      if (password.length < 6) {
        return res.status(400).json({ error: "Password must be at least 6 characters long" });
      }
      
      // Check if username already exists
      const existingUser = await databaseStorage.getUserByUsername(username);
      if (existingUser) {
        return res.status(409).json({ error: "Username already exists. Please choose a different username." });
      }
      
      // Check if email already exists
      if (email) {
        const existingEmail = await databaseStorage.getUserByEmail(email);
        if (existingEmail) {
          return res.status(409).json({ error: "Email already registered. Please use a different email or sign in." });
        }
      }
      
      // Hash password securely
      const hashedPassword = await bcrypt.hash(password, SALT_ROUNDS);
      
      // Create full name from first and last name
      const fullName = `${firstName || ''} ${lastName || ''}`.trim() || username;
      
      // Create user in database
      const newUser = await databaseStorage.createUser({
        username,
        password: hashedPassword,
        role: "PATIENT", // Always set to PATIENT for self-registration
        name: fullName,
        email: email || null,
      });
      
      // Return user without password
      const { password: _, ...userWithoutPassword } = newUser;
      res.status(201).json(userWithoutPassword);
    } catch (error) {
      console.error("Registration error:", error);
      res.status(500).json({ error: "Registration failed. Please try again." });
    }
  });

  // Roles that require active staff list entry to login
  const STAFF_ROLES_REQUIRING_VALIDATION = ["DOCTOR", "NURSE", "ADMIN", "OPD_MANAGER", "PATHOLOGY_LAB", "MEDICAL_STORE"];
  
  // Login endpoint - fetch user by username, verify hashed password
  app.post("/api/auth/login", async (req, res) => {
    try {
      const { username: rawUsername, password, role } = req.body;
      const username = rawUsername?.trim();
      
      if (!username || !role) {
        return res.status(400).json({ error: "Username and role are required" });
      }
      
      if (!password) {
        return res.status(400).json({ error: "Password is required" });
      }
      
      // Find user in database (trimmed username)
      const user = await databaseStorage.getUserByUsername(username);
      
      if (!user) {
        return res.status(401).json({ error: "Invalid username or password. Please check your credentials or create an account." });
      }
      
      // Verify password using bcrypt
      const passwordValid = await bcrypt.compare(password, user.password);
      if (!passwordValid) {
        return res.status(401).json({ error: "Invalid username or password. Please check your credentials." });
      }
      
      // Validate role matches
      if (user.role !== role) {
        return res.status(401).json({ error: `This account is registered as ${user.role}. Please select the correct role.` });
      }
      
      // CRITICAL: Staff list validation - Staff roles must have an ACTIVE entry in staff_master table
      // SUPER_ADMIN and PATIENT roles are exempt from this check
      if (user.role !== "SUPER_ADMIN" && user.role !== "PATIENT" && STAFF_ROLES_REQUIRING_VALIDATION.includes(user.role)) {
        // Try to find staff record by userId first (primary link)
        let staffRecord = await storage.getStaffMasterByUserId(user.id);
        
        // If no userId link, try finding by email (fallback for legacy staff records)
        if (!staffRecord && user.email) {
          staffRecord = await storage.getStaffMasterByEmail(user.email);
          // If found by email, automatically link the userId for future logins
          if (staffRecord && !staffRecord.userId) {
            await storage.updateStaffMaster(staffRecord.id, { userId: user.id });
            console.log(`Auto-linked staff ${staffRecord.fullName} to user ${user.id} via email`);
          }
        }
        
        // If still not found, try finding by username as employeeCode (fallback for legacy records)
        if (!staffRecord) {
          staffRecord = await storage.getStaffMasterByEmployeeCode(username);
          // If found by employeeCode, automatically link the userId for future logins
          if (staffRecord && !staffRecord.userId) {
            await storage.updateStaffMaster(staffRecord.id, { userId: user.id });
            console.log(`Auto-linked staff ${staffRecord.fullName} to user ${user.id} via employeeCode`);
          }
        }
        
        if (!staffRecord) {
          console.log(`Login denied for ${username}: No staff record found for role ${user.role}`);
          return res.status(403).json({ 
            error: "Access denied. Your account is not registered in the Staff List. Please contact the administrator." 
          });
        }
        
        if (staffRecord.status !== "ACTIVE") {
          console.log(`Login denied for ${username}: Staff status is ${staffRecord.status}`);
          return res.status(403).json({ 
            error: `Access denied. Your staff account is ${staffRecord.status.toLowerCase()}. Please contact the administrator.` 
          });
        }
      }
      
      const { password: _, ...userWithoutPassword } = user;
      
      // Set session user for authenticated routes
      (req.session as any).user = userWithoutPassword;
      
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ error: "Login failed" });
    }
  });

  // Get all users
  app.get("/api/users", async (_req, res) => {
    try {
      const allUsers = await databaseStorage.getAllUsers();
      const usersWithoutPasswords = allUsers.map(({ password, ...user }) => user);
      res.json(usersWithoutPasswords);
    } catch (error) {
      console.error("Failed to get users:", error);
      res.status(500).json({ error: "Failed to fetch users" });
    }
  });

  // Get user by username
  app.get("/api/users/by-username/:username", async (req, res) => {
    try {
      const user = await storage.getUserByUsername(req.params.username);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const { password, ...userWithoutPassword } = user;
      res.json(userWithoutPassword);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch user" });
    }
  });

  // Get all nurses
  app.get("/api/users/nurses", async (_req, res) => {
    try {
      const allUsers = await databaseStorage.getAllUsers();
      const nurses = allUsers
        .filter(user => user.role === "NURSE")
        .map(({ password, ...user }) => ({
          id: user.id,
          username: user.username,
          fullName: user.name || user.username,
          role: user.role
        }));
      res.json(nurses);
    } catch (error) {
      console.error("Failed to get nurses:", error);
      res.status(500).json({ error: "Failed to fetch nurses" });
    }
  });

  // Get all doctors - merge with doctor_profiles when available
  app.get("/api/doctors", async (_req, res) => {
    try {
      const doctors = await storage.getDoctors();
      const allProfiles = await storage.getAllDoctorProfiles();
      
      // Helper to normalize name (remove "Dr." prefix, lowercase, trim)
      const normalizeName = (name: string) => name.toLowerCase().replace(/^dr\.?\s*/i, '').trim();
      
      // Helper to find matching profile for a doctor
      const findMatchingProfile = (doctorName: string) => {
        const normalizedDoctorName = normalizeName(doctorName);
        const doctorFirstName = normalizedDoctorName.split(' ')[0];
        
        for (const profile of allProfiles) {
          const normalizedProfileName = normalizeName(profile.fullName);
          const profileFirstName = normalizedProfileName.split(' ')[0];
          
          // Exact match
          if (normalizedDoctorName === normalizedProfileName) return profile;
          // Profile name starts with doctor name (e.g., "ajay" matches "ajay patil")
          if (normalizedProfileName.startsWith(normalizedDoctorName)) return profile;
          // Doctor name starts with profile first name
          if (normalizedDoctorName.startsWith(profileFirstName)) return profile;
          // First names match exactly
          if (doctorFirstName === profileFirstName) return profile;
        }
        return null;
      };
      
      // Merge doctor data with profile data when available
      const mergedDoctors = doctors.map(doctor => {
        const profile = findMatchingProfile(doctor.name);
        
        if (profile) {
          // Extract numeric experience from profile (e.g., "10+ Years" -> 10)
          const expMatch = profile.experience?.match(/(\d+)/);
          const profileExp = expMatch ? parseInt(expMatch[1]) : doctor.experience;
          
          // Extract numeric fee from profile (e.g., "â‚¹500" -> "500")
          const feeMatch = profile.consultationFee?.match(/(\d+)/);
          const profileFee = feeMatch ? feeMatch[1] : null;
          
          return {
            ...doctor,
            name: profile.fullName || doctor.name,
            specialty: profile.specialty || doctor.specialty,
            qualification: profile.qualifications || doctor.qualification,
            experience: profileExp,
            consultationFee: profileFee
          };
        }
        return doctor;
      });
      
      res.json(mergedDoctors);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch doctors" });
    }
  });

  // Get doctor by ID
  app.get("/api/doctors/:id", async (req, res) => {
    try {
      const doctor = await storage.getDoctor(req.params.id);
      if (!doctor) {
        return res.status(404).json({ error: "Doctor not found" });
      }
      res.json(doctor);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch doctor" });
    }
  });

  // Get doctor schedules (with date as query param or path param)
  app.get("/api/doctors/:id/schedules", async (req, res) => {
    try {
      const { date } = req.query;
      const schedules = await storage.getSchedules(req.params.id, date as string);
      res.json(schedules);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch schedules" });
    }
  });

  // Get doctor schedules (with date as path param)
  app.get("/api/doctors/:id/schedules/:date", async (req, res) => {
    try {
      const schedules = await storage.getSchedules(req.params.id, req.params.date);
      res.json(schedules);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch schedules" });
    }
  });

  // Get all appointments (with patient data isolation for PATIENT role)
  app.get("/api/appointments", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      let appointments = await storage.getAppointments();
      
      // CRITICAL: Patient data isolation - PATIENT role only sees their own appointments
      if (user && user.role === 'PATIENT') {
        const patientId = user.id;
        const userName = user.name?.toLowerCase().replace(/\s+/g, ' ').trim();
        const userUsername = user.username?.toLowerCase();
        appointments = appointments.filter(apt => {
          const aptPatientName = apt.patientName?.toLowerCase().replace(/\s+/g, ' ').trim();
          return apt.patientId === patientId || 
            aptPatientName === userName ||
            aptPatientName === userUsername;
        });
      }
      
      res.json(appointments);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch appointments" });
    }
  });

  // Get appointments by status (with patient data isolation for PATIENT role)
  app.get("/api/appointments/status/:status", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      let appointments = await storage.getAppointmentsByStatus(req.params.status);
      
      // CRITICAL: Patient data isolation - PATIENT role only sees their own appointments
      if (user && user.role === 'PATIENT') {
        const patientId = user.id;
        const userName = user.name?.toLowerCase().replace(/\s+/g, ' ').trim();
        const userUsername = user.username?.toLowerCase();
        appointments = appointments.filter(apt => {
          const aptPatientName = apt.patientName?.toLowerCase().replace(/\s+/g, ' ').trim();
          return apt.patientId === patientId || 
            aptPatientName === userName ||
            aptPatientName === userUsername;
        });
      }
      
      res.json(appointments);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch appointments" });
    }
  });

  // Create new appointment
  app.post("/api/appointments", async (req, res) => {
    try {
      const validatedData = insertAppointmentSchema.parse(req.body);
      
      // Book the schedule slot
      const bookedSlot = await storage.findAndBookScheduleSlot(
        validatedData.doctorId,
        validatedData.appointmentDate,
        validatedData.timeSlot
      );
      
      if (!bookedSlot) {
        return res.status(409).json({ error: "This time slot is no longer available. Please choose another time." });
      }
      
      // Force status to "pending" for all new appointments (requires doctor confirmation)
      const appointmentData = { ...validatedData, status: "pending" };
      const appointment = await storage.createAppointment(appointmentData);
      
      // Log activity
      await storage.createActivityLog({
        action: `Pending appointment for ${validatedData.patientName} - awaiting doctor confirmation`,
        entityType: "appointment",
        entityId: appointment.id,
        performedBy: "OPD System",
        performedByRole: "SYSTEM",
        activityType: "pending"
      });

      // Send real-time notification to doctor and patient
      // Resolve doctorId to user ID for proper notification routing
      const patientId = req.body.patientId || req.body.patientName; // Use patientId if provided, fallback to patientName
      const resolvedDoctorUserId = await resolveDoctorId(validatedData.doctorId);
      notificationService.notifyAppointmentCreated(
        appointment.id,
        resolvedDoctorUserId,
        validatedData.patientName,
        validatedData.appointmentDate,
        validatedData.timeSlot,
        validatedData.department || undefined,
        validatedData.location || undefined,
        patientId
      ).catch(err => console.error("Notification error:", err));
      
      res.status(201).json(appointment);
    } catch (error) {
      console.error("Appointment creation error:", error);
      res.status(400).json({ error: "Invalid appointment data" });
    }
  });

  // Check-in appointment
  app.post("/api/appointments/:id/checkin", async (req, res) => {
    try {
      const appointment = await storage.updateAppointmentStatus(req.params.id, "checked-in");
      if (!appointment) {
        return res.status(404).json({ error: "Appointment not found" });
      }
      res.json(appointment);
    } catch (error) {
      res.status(500).json({ error: "Failed to check in appointment" });
    }
  });

  // Confirm appointment (doctor confirms pending appointment)
  app.patch("/api/appointments/:id/confirm", async (req, res) => {
    try {
      const appointment = await storage.updateAppointmentStatus(req.params.id, "confirmed");
      if (!appointment) {
        return res.status(404).json({ error: "Appointment not found" });
      }
      
      // Get doctor info for notification - check time slot first, then users table, then doctors table
      let doctorName = 'Doctor';
      try {
        // First try to get from time slot (most reliable for OPD appointments)
        const timeSlot = await databaseStorage.getDoctorTimeSlotByAppointmentId(appointment.id);
        if (timeSlot?.doctorName) {
          doctorName = timeSlot.doctorName.replace(/^Dr\.\s*/i, ''); // Remove "Dr." prefix if present
        } else {
          // Try to get from users table (doctorId might be a userId)
          const user = await storage.getUser(appointment.doctorId);
          if (user?.name) {
            doctorName = user.name.replace(/^Dr\.\s*/i, '');
          } else {
            // Final fallback to doctors table
            const doctor = await storage.getDoctor(appointment.doctorId);
            if (doctor?.name) doctorName = doctor.name.replace(/^Dr\.\s*/i, '');
          }
        }
      } catch (e) {
        console.log("Doctor profile not found, using default name");
      }
      
      // Send real-time notification to patient (use patientId or patientName as fallback)
      const patientId = appointment.patientId || appointment.patientName;
      if (patientId) {
        notificationService.notifyAppointmentConfirmed(
          appointment.id,
          appointment.doctorId,
          doctorName,
          patientId,
          appointment.patientName,
          appointment.appointmentDate,
          appointment.timeSlot,
          appointment.department || undefined,
          appointment.location || undefined
        ).catch(err => console.error("Notification error:", err));
      }
      
      // Log activity for admin dashboard recent activities
      await storage.createActivityLog({
        action: `Appointment confirmed for ${appointment.patientName} by Dr. ${doctorName}`,
        entityType: "appointment",
        entityId: appointment.id,
        performedBy: `Dr. ${doctorName}`,
        performedByRole: "DOCTOR",
        activityType: "success",
        metadata: JSON.stringify({
          patientName: appointment.patientName,
          doctorName,
          appointmentDate: appointment.appointmentDate,
          timeSlot: appointment.timeSlot,
          department: appointment.department,
          location: appointment.location,
          status: 'confirmed'
        })
      });
      
      res.json(appointment);
    } catch (error) {
      console.error("Failed to confirm appointment:", error);
      res.status(500).json({ error: "Failed to confirm appointment" });
    }
  });

  // Cancel appointment
  app.patch("/api/appointments/:id/cancel", async (req, res) => {
    try {
      const existingAppointment = await storage.getAppointment(req.params.id);
      if (!existingAppointment) {
        return res.status(404).json({ error: "Appointment not found" });
      }
      
      const appointment = await storage.updateAppointmentStatus(req.params.id, "cancelled");
      if (!appointment) {
        return res.status(404).json({ error: "Appointment not found" });
      }
      
      // Determine who cancelled (default to doctor if not specified)
      const cancelledBy = req.body.cancelledBy || 'doctor';
      
      // Get doctor info for notification - check time slot first, then users table, then doctors table
      let doctorName = 'Doctor';
      try {
        // First try to get from time slot (most reliable for OPD appointments)
        const timeSlot = await databaseStorage.getDoctorTimeSlotByAppointmentId(appointment.id);
        if (timeSlot?.doctorName) {
          doctorName = timeSlot.doctorName.replace(/^Dr\.\s*/i, ''); // Remove "Dr." prefix if present
        } else {
          // Try to get from users table (doctorId might be a userId)
          const user = await storage.getUser(appointment.doctorId);
          if (user?.name) {
            doctorName = user.name.replace(/^Dr\.\s*/i, '');
          } else {
            // Final fallback to doctors table
            const doctor = await storage.getDoctor(appointment.doctorId);
            if (doctor?.name) doctorName = doctor.name.replace(/^Dr\.\s*/i, '');
          }
        }
      } catch (e) {
        console.log("Doctor profile not found, using default name");
      }
      
      // Send real-time notification (use patientId or patientName as fallback)
      const patientId = appointment.patientId || appointment.patientName;
      if (patientId) {
        notificationService.notifyAppointmentCancelled(
          appointment.id,
          appointment.doctorId,
          doctorName,
          patientId,
          appointment.patientName,
          appointment.appointmentDate,
          appointment.timeSlot,
          cancelledBy,
          appointment.department || undefined,
          appointment.location || undefined
        ).catch(err => console.error("Notification error:", err));
      }
      
      // Log activity for admin dashboard recent activities
      const cancelledByLabel = cancelledBy === 'doctor' ? `Dr. ${doctorName}` : appointment.patientName;
      await storage.createActivityLog({
        action: `Appointment cancelled for ${appointment.patientName} by ${cancelledByLabel}`,
        entityType: "appointment",
        entityId: appointment.id,
        performedBy: cancelledByLabel,
        performedByRole: cancelledBy === 'doctor' ? 'DOCTOR' : 'PATIENT',
        activityType: "cancellation",
        metadata: JSON.stringify({
          patientName: appointment.patientName,
          doctorName,
          appointmentDate: appointment.appointmentDate,
          timeSlot: appointment.timeSlot,
          department: appointment.department,
          location: appointment.location,
          cancelledBy
        })
      });
      
      res.json(appointment);
    } catch (error) {
      console.error("Failed to cancel appointment:", error);
      res.status(500).json({ error: "Failed to cancel appointment" });
    }
  });

  // Complete appointment
  app.patch("/api/appointments/:id/complete", async (req, res) => {
    try {
      const appointment = await storage.updateAppointmentStatus(req.params.id, "completed");
      if (!appointment) {
        return res.status(404).json({ error: "Appointment not found" });
      }
      res.json(appointment);
    } catch (error) {
      res.status(500).json({ error: "Failed to complete appointment" });
    }
  });

  // ========== INVENTORY SERVICE ROUTES ==========

  // Get all inventory items
  app.get("/api/inventory/items", async (_req, res) => {
    try {
      const items = await storage.getAllInventoryItems();
      res.json(items);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch inventory items" });
    }
  });

  // Get inventory item by ID
  app.get("/api/inventory/items/:id", async (req, res) => {
    try {
      const item = await storage.getInventoryItemById(req.params.id);
      if (!item) {
        return res.status(404).json({ error: "Item not found" });
      }
      res.json(item);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch item" });
    }
  });

  // Create new inventory item
  app.post("/api/inventory/items", async (req, res) => {
    try {
      const parsed = insertInventoryItemSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const newItem = await storage.createInventoryItem(parsed.data);
      
      // Create an ADD transaction when a new item is added
      if (newItem && parsed.data.currentStock && parsed.data.currentStock > 0) {
        await storage.createInventoryTransaction({
          type: "ADD",
          itemId: newItem.id,
          quantity: parsed.data.currentStock,
          notes: `Initial stock added for ${newItem.name}`,
        });
      }
      
      res.status(201).json(newItem);
    } catch (error) {
      res.status(500).json({ error: "Failed to create item" });
    }
  });

  // Update inventory item
  app.patch("/api/inventory/items/:id", async (req, res) => {
    try {
      const item = await storage.updateInventoryItem(req.params.id, req.body);
      if (!item) {
        return res.status(404).json({ error: "Item not found" });
      }
      res.json(item);
    } catch (error) {
      res.status(500).json({ error: "Failed to update item" });
    }
  });

  // Delete inventory item
  app.delete("/api/inventory/items/:id", async (req, res) => {
    try {
      const deleted = await storage.deleteInventoryItem(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Item not found" });
      }
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete item" });
    }
  });

  // Get low stock items
  app.get("/api/inventory/low-stock", async (_req, res) => {
    try {
      const items = await storage.getLowStockItems();
      res.json(items);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch low stock items" });
    }
  });

  // Get all transactions
  app.get("/api/inventory/transactions", async (_req, res) => {
    try {
      const transactions = await storage.getAllInventoryTransactions();
      res.json(transactions);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch transactions" });
    }
  });

  // Create new transaction
  app.post("/api/inventory/transactions", async (req, res) => {
    try {
      const parsed = insertInventoryTransactionSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const newTransaction = await storage.createInventoryTransaction(parsed.data);
      res.status(201).json(newTransaction);
    } catch (error: any) {
      if (error.message === "Insufficient stock") {
        return res.status(409).json({ error: "Insufficient stock for this transaction" });
      }
      res.status(400).json({ error: error.message || "Failed to create transaction" });
    }
  });

  // Get all inventory staff members (legacy endpoint for inventory module)
  app.get("/api/inventory/staff", async (_req, res) => {
    try {
      const staff = await storage.getAllStaffMembers();
      res.json(staff);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch staff" });
    }
  });

  // Create new inventory staff member (legacy endpoint for inventory module)
  app.post("/api/inventory/staff", async (req, res) => {
    try {
      const parsed = insertStaffMemberSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const newStaff = await storage.createStaffMember(parsed.data);
      res.status(201).json(newStaff);
    } catch (error) {
      res.status(500).json({ error: "Failed to create staff member" });
    }
  });

  // Get all inventory patients
  app.get("/api/inventory/patients", async (_req, res) => {
    try {
      const patients = await storage.getAllInventoryPatients();
      res.json(patients);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patients" });
    }
  });

  // Create new inventory patient
  app.post("/api/inventory/patients", async (req, res) => {
    try {
      const parsed = insertInventoryPatientSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const newPatient = await storage.createInventoryPatient(parsed.data);
      res.status(201).json(newPatient);
    } catch (error) {
      res.status(500).json({ error: "Failed to create patient" });
    }
  });

  // Get inventory reports
  app.get("/api/inventory/reports", async (_req, res) => {
    try {
      const reports = await storage.getInventoryReports();
      res.json(reports);
    } catch (error) {
      res.status(500).json({ error: "Failed to generate reports" });
    }
  });

  // Get patient-wise report
  app.get("/api/inventory/reports/patient-wise", async (_req, res) => {
    try {
      const report = await storage.getPatientWiseReport();
      res.json(report);
    } catch (error) {
      res.status(500).json({ error: "Failed to generate patient-wise report" });
    }
  });

  // Get staff-wise report
  app.get("/api/inventory/reports/staff-wise", async (_req, res) => {
    try {
      const report = await storage.getStaffWiseReport();
      res.json(report);
    } catch (error) {
      res.status(500).json({ error: "Failed to generate staff-wise report" });
    }
  });

  // ========== PATIENT TRACKING SERVICE ROUTES ==========

  // Get active patient count (patients not discharged)
  app.get("/api/tracking/patients/active-count", async (_req, res) => {
    try {
      const patients = await storage.getAllTrackingPatients();
      const activePatients = patients.filter((p: any) => 
        p.status !== 'discharged' && p.status !== 'Discharged'
      );
      res.json({ count: activePatients.length, patients: activePatients });
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch active patient count" });
    }
  });

  // Get all tracking patients
  app.get("/api/tracking/patients", async (_req, res) => {
    try {
      const patients = await storage.getAllTrackingPatients();
      res.json(patients);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patients" });
    }
  });

  // Get tracking patient by ID
  app.get("/api/tracking/patients/:id", async (req, res) => {
    try {
      const patient = await storage.getTrackingPatientById(req.params.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }
      res.json(patient);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patient" });
    }
  });

  // Create new tracking patient
  app.post("/api/tracking/patients", async (req, res) => {
    try {
      const parsed = insertTrackingPatientSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const newPatient = await storage.createTrackingPatient(parsed.data);
      
      // Log admission movement
      try {
        await db.insert(patientMovementLog).values({
          trackingPatientId: newPatient.id,
          eventType: 'admission',
          fromLocation: 'External',
          toLocation: parsed.data.department || 'General Ward',
          performedBy: parsed.data.doctor,
          notes: `Patient admitted to ${parsed.data.department || 'General Ward'}, Room: ${parsed.data.room}`,
          occurredAt: new Date()
        });
      } catch (logError) {
        console.error("Failed to log admission movement:", logError);
      }
      
      // If a nurse is assigned, update their assignment status with room and doctor info
      if (parsed.data.nurse) {
        try {
          await storage.updateNurseAssignment(
            parsed.data.nurse,
            parsed.data.room || null,
            parsed.data.doctor || null,
            parsed.data.department || null
          );
          console.log(`Updated nurse assignment for ${parsed.data.nurse}: Room ${parsed.data.room}, Doctor ${parsed.data.doctor}`);
        } catch (nurseError) {
          console.error("Failed to update nurse assignment:", nurseError);
        }
      }
      
      res.status(201).json(newPatient);
    } catch (error) {
      res.status(500).json({ error: "Failed to create patient" });
    }
  });

  // Update patient status
  app.patch("/api/tracking/patients/:id/status", async (req, res) => {
    try {
      const { status } = req.body;
      const patient = await storage.updateTrackingPatientStatus(req.params.id, status);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }
      res.json(patient);
    } catch (error) {
      res.status(500).json({ error: "Failed to update patient status" });
    }
  });

  // Discharge tracking patient (update status to discharged with discharge date)
  app.patch("/api/tracking/patients/:id/discharge", async (req, res) => {
    try {
      // Get the patient first to know which nurse to clear
      const patient = await storage.getTrackingPatientById(req.params.id);
      
      const updated = await storage.dischargeTrackingPatient(req.params.id, new Date());
      if (!updated) {
        return res.status(404).json({ error: "Patient not found" });
      }
      
      // Log discharge movement
      if (patient) {
        try {
          await db.insert(patientMovementLog).values({
            trackingPatientId: req.params.id,
            eventType: 'discharge',
            fromLocation: patient.department || 'Ward',
            toLocation: 'Discharged',
            performedBy: patient.doctor,
            notes: `Patient discharged from ${patient.department || 'Ward'}`,
            occurredAt: new Date()
          });
        } catch (logError) {
          console.error("Failed to log discharge movement:", logError);
        }
      }
      
      // Clear nurse assignment when patient is discharged
      if (patient && patient.nurse) {
        try {
          await storage.clearNurseAssignment(patient.nurse);
          console.log(`Cleared nurse assignment for ${patient.nurse} after patient discharge`);
        } catch (nurseError) {
          console.error("Failed to clear nurse assignment:", nurseError);
        }
      }
      
      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to discharge patient" });
    }
  });

  // Transfer patient to ICU (set isInIcu = true and record icuTransferDate)
  app.patch("/api/tracking/patients/:id/transfer-icu", async (req, res) => {
    try {
      const patient = await storage.updateTrackingPatient(req.params.id, { 
        isInIcu: true,
        icuTransferDate: new Date()
      });
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }
      res.json(patient);
    } catch (error) {
      console.error("Error transferring patient to ICU:", error);
      res.status(500).json({ error: "Failed to transfer patient to ICU" });
    }
  });

  // Transfer patient to Ward (set isInIcu = false and update icuDays)
  app.patch("/api/tracking/patients/:id/transfer-ward", async (req, res) => {
    try {
      // First get the current patient to calculate ICU days
      const currentPatient = await storage.getTrackingPatientById(req.params.id);
      if (!currentPatient) {
        return res.status(404).json({ error: "Patient not found" });
      }
      
      // Calculate ICU days
      let icuDays = currentPatient.icuDays || 0;
      if (currentPatient.icuTransferDate) {
        const now = new Date();
        const icuStart = new Date(currentPatient.icuTransferDate);
        const daysInIcu = Math.ceil((now.getTime() - icuStart.getTime()) / (1000 * 60 * 60 * 24));
        icuDays += daysInIcu;
      }
      
      const patient = await storage.updateTrackingPatient(req.params.id, { 
        isInIcu: false,
        icuDays: icuDays,
        icuTransferDate: null
      });
      res.json(patient);
    } catch (error) {
      console.error("Error transferring patient to ward:", error);
      res.status(500).json({ error: "Failed to transfer patient to ward" });
    }
  });

  // Update tracking patient department
  app.patch("/api/tracking/patients/:id/department", async (req, res) => {
    try {
      const { department } = req.body;
      if (!department) {
        return res.status(400).json({ error: "Department is required" });
      }
      
      // Get current patient data
      const currentPatient = await storage.getTrackingPatientById(req.params.id);
      if (!currentPatient) {
        return res.status(404).json({ error: "Patient not found" });
      }
      
      const previousDepartment = currentPatient.department;
      
      // If department is ICU, also set isInIcu flag and create ICU chart
      if (department === "ICU" && !currentPatient.isInIcu) {
        const patient = await storage.updateTrackingPatient(req.params.id, { 
          department,
          isInIcu: true,
          icuTransferDate: new Date()
        });
        
        // Log ICU transfer movement
        try {
          await db.insert(patientMovementLog).values({
            trackingPatientId: req.params.id,
            eventType: 'icu_transfer',
            fromLocation: previousDepartment,
            toLocation: 'ICU',
            performedBy: currentPatient.doctor,
            notes: `Patient transferred to ICU from ${previousDepartment}`,
            occurredAt: new Date()
          });
        } catch (logError) {
          console.error("Failed to log ICU transfer:", logError);
        }
        
        // Check if ICU chart already exists for this patient before creating
        const existingCharts = await storage.getIcuChartsByPatient(currentPatient.id);
        if (existingCharts.length === 0) {
          try {
            const today = new Date().toISOString().split('T')[0];
            await storage.createIcuChart({
              patientId: currentPatient.id,
              patientName: currentPatient.name,
              age: String(currentPatient.age),
              sex: currentPatient.gender,
              diagnosis: currentPatient.diagnosis,
              ward: "ICU",
              bedNo: currentPatient.room,
              chartDate: today,
              dateOfAdmission: today,
              admittingConsultant: currentPatient.doctor,
              icuConsultant: currentPatient.doctor
            });
          } catch (chartError) {
            console.log("Error creating ICU chart:", chartError);
          }
        }
        
        res.json(patient);
      } else if (department !== "ICU" && currentPatient.isInIcu) {
        // If moving out of ICU, calculate ICU days and update
        let icuDays = currentPatient.icuDays || 0;
        if (currentPatient.icuTransferDate) {
          const now = new Date();
          const icuStart = new Date(currentPatient.icuTransferDate);
          const daysInIcu = Math.ceil((now.getTime() - icuStart.getTime()) / (1000 * 60 * 60 * 24));
          icuDays += daysInIcu;
        }
        
        const patient = await storage.updateTrackingPatient(req.params.id, { 
          department,
          isInIcu: false,
          icuDays: icuDays,
          icuTransferDate: null
        });
        
        // Log ICU discharge / ward transfer movement
        try {
          await db.insert(patientMovementLog).values({
            trackingPatientId: req.params.id,
            eventType: 'ward_transfer',
            fromLocation: 'ICU',
            toLocation: department,
            performedBy: currentPatient.doctor,
            notes: `Patient transferred from ICU to ${department}`,
            occurredAt: new Date()
          });
        } catch (logError) {
          console.error("Failed to log ward transfer:", logError);
        }
        
        res.json(patient);
      } else {
        // Just update department (ward to ward transfer)
        const patient = await storage.updateTrackingPatient(req.params.id, { department });
        
        // Log ward transfer movement
        if (previousDepartment !== department) {
          try {
            await db.insert(patientMovementLog).values({
              trackingPatientId: req.params.id,
              eventType: 'ward_transfer',
              fromLocation: previousDepartment,
              toLocation: department,
              performedBy: currentPatient.doctor,
              notes: `Patient transferred from ${previousDepartment} to ${department}`,
              occurredAt: new Date()
            });
          } catch (logError) {
            console.error("Failed to log ward transfer:", logError);
          }
        }
        
        res.json(patient);
      }
    } catch (error) {
      console.error("Error updating patient department:", error);
      res.status(500).json({ error: "Failed to update department" });
    }
  });

  // Delete tracking patient (permanent removal)
  app.delete("/api/tracking/patients/:id", async (req, res) => {
    try {
      const deleted = await storage.deleteTrackingPatient(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Patient not found" });
      }
      res.json({ success: true, message: "Patient removed from tracking" });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete patient" });
    }
  });

  // Get patient tracking history
  app.get("/api/tracking/patients/:id/history", async (req, res) => {
    try {
      const history = await storage.getPatientTrackingHistory(req.params.id);
      if (!history) {
        return res.status(404).json({ error: "Patient not found" });
      }
      res.json(history);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch tracking history" });
    }
  });

  // Get patient movement timeline
  app.get("/api/tracking/patients/:id/movements", async (req, res) => {
    try {
      const movements = await db.select()
        .from(patientMovementLog)
        .where(eq(patientMovementLog.trackingPatientId, req.params.id))
        .orderBy(desc(patientMovementLog.occurredAt));
      res.json(movements);
    } catch (error) {
      console.error("Failed to fetch patient movements:", error);
      res.status(500).json({ error: "Failed to fetch patient movements" });
    }
  });

  // Get all patient movements for IPD history
  app.get("/api/tracking/movements/all", async (req, res) => {
    try {
      const movements = await db.select()
        .from(patientMovementLog)
        .orderBy(desc(patientMovementLog.occurredAt));
      res.json(movements);
    } catch (error) {
      console.error("Failed to fetch all patient movements:", error);
      res.status(500).json({ error: "Failed to fetch all patient movements" });
    }
  });

  // Add medication to patient
  app.post("/api/tracking/patients/:id/meds", async (req, res) => {
    try {
      const parsed = insertMedicationSchema.safeParse({ ...req.body, patientId: req.params.id });
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const medication = await storage.createMedication(parsed.data);
      res.status(201).json(medication);
    } catch (error) {
      res.status(500).json({ error: "Failed to add medication" });
    }
  });

  // Get medications for patient
  app.get("/api/tracking/patients/:id/meds", async (req, res) => {
    try {
      const medications = await storage.getMedicationsByPatient(req.params.id);
      res.json(medications);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch medications" });
    }
  });

  // Add meal to patient
  app.post("/api/tracking/patients/:id/meals", async (req, res) => {
    try {
      const parsed = insertMealSchema.safeParse({ ...req.body, patientId: req.params.id });
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const meal = await storage.createMeal(parsed.data);
      res.status(201).json(meal);
    } catch (error) {
      res.status(500).json({ error: "Failed to add meal" });
    }
  });

  // Get meals for patient
  app.get("/api/tracking/patients/:id/meals", async (req, res) => {
    try {
      const meals = await storage.getMealsByPatient(req.params.id);
      res.json(meals);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch meals" });
    }
  });

  // Add vitals to patient
  app.post("/api/tracking/patients/:id/vitals", async (req, res) => {
    try {
      const parsed = insertVitalsSchema.safeParse({ ...req.body, patientId: req.params.id });
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const vitals = await storage.createVitals(parsed.data);
      res.status(201).json(vitals);
    } catch (error) {
      res.status(500).json({ error: "Failed to add vitals" });
    }
  });

  // Get vitals for patient
  app.get("/api/tracking/patients/:id/vitals", async (req, res) => {
    try {
      const vitals = await storage.getVitalsByPatient(req.params.id);
      res.json(vitals);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch vitals" });
    }
  });

  // Add doctor visit to patient
  app.post("/api/tracking/patients/:id/doctor-visits", async (req, res) => {
    try {
      const parsed = insertDoctorVisitSchema.safeParse({ ...req.body, patientId: req.params.id });
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const visit = await storage.createDoctorVisit(parsed.data);
      res.status(201).json(visit);
    } catch (error) {
      res.status(500).json({ error: "Failed to add doctor visit" });
    }
  });

  // Get doctor visits for patient
  app.get("/api/tracking/patients/:id/doctor-visits", async (req, res) => {
    try {
      const visits = await storage.getDoctorVisitsByPatient(req.params.id);
      res.json(visits);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch doctor visits" });
    }
  });

  // ========== CHATBOT SERVICE ROUTES ==========

  // Send message to chatbot
  app.post("/api/chatbot/message", async (req, res) => {
    try {
      const { query, userId } = req.body;
      if (!query) {
        return res.status(400).json({ error: "Query is required" });
      }

      const { response, category } = await getChatbotResponse(query);
      
      const log = await storage.createConversationLog({
        userId: userId || null,
        query,
        response,
        category,
      });

      res.json({ response, category, logId: log.id });
    } catch (error) {
      console.error("Chatbot error:", error);
      res.status(500).json({ error: "Failed to process message" });
    }
  });

  // Get conversation logs
  app.get("/api/chatbot/logs", async (req, res) => {
    try {
      const { userId, limit } = req.query;
      const logs = await storage.getConversationLogs(
        userId as string | undefined,
        limit ? parseInt(limit as string) : undefined
      );
      res.json(logs);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch conversation logs" });
    }
  });

  // Get conversation logs by category
  app.get("/api/chatbot/logs/category/:category", async (req, res) => {
    try {
      const { limit } = req.query;
      const logs = await storage.getConversationLogsByCategory(
        req.params.category,
        limit ? parseInt(limit as string) : undefined
      );
      res.json(logs);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch conversation logs" });
    }
  });

  // Get chatbot statistics
  app.get("/api/chatbot/stats", async (req, res) => {
    try {
      const logs = await storage.getConversationLogs(undefined, 1000);
      const stats = getChatbotStats(logs);
      res.json(stats);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch chatbot stats" });
    }
  });

  // ========== PATIENT SERVICE ROUTES ==========

  // Get all service patients (with patient data isolation for PATIENT role)
  app.get("/api/patients/service", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      let patients = await storage.getAllServicePatients();
      
      // CRITICAL: Patient data isolation - PATIENT role only sees their own record
      if (user && user.role === 'PATIENT') {
        const patientId = user.id;
        patients = patients.filter(p => 
          p.id === patientId ||
          p.userId === patientId ||
          p.name?.toLowerCase() === user.name?.toLowerCase() ||
          p.name?.toLowerCase() === user.username?.toLowerCase()
        );
      }
      
      res.json(patients);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patients" });
    }
  });

  // Get patients assigned to a specific nurse
  app.get("/api/patients/assigned/:nurseId", async (req, res) => {
    try {
      const patients = await storage.getAllServicePatients();
      const assignedPatients = patients.filter(p => p.assignedNurseId === req.params.nurseId);
      res.json(assignedPatients);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch assigned patients" });
    }
  });

  // Assign nurse to patient (Admin only)
  app.patch("/api/patients/service/:id/assign-nurse", async (req, res) => {
    try {
      const { nurseId } = req.body;
      const patient = await storage.updateServicePatient(req.params.id, { assignedNurseId: nurseId } as any);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }
      res.json(patient);
    } catch (error) {
      res.status(500).json({ error: "Failed to assign nurse to patient" });
    }
  });

  // Get service patient by ID (with patient data isolation for PATIENT role)
  app.get("/api/patients/service/:id", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const patient = await storage.getServicePatientById(req.params.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }
      
      // CRITICAL: Patient data isolation - PATIENT role can only access their own record
      if (user && user.role === 'PATIENT') {
        if (patient.id !== user.id && patient.userId !== user.id) {
          return res.status(403).json({ error: "Access denied. You can only view your own patient record." });
        }
      }
      
      res.json(patient);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patient" });
    }
  });

  // Create service patient
  app.post("/api/patients/service", async (req, res) => {
    try {
      const parsed = insertServicePatientSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const patient = await storage.createServicePatient(parsed.data);
      
      // Log activity
      await storage.createActivityLog({
        action: `New patient registered: ${parsed.data.firstName} ${parsed.data.lastName}`,
        entityType: "patient",
        entityId: patient.id,
        performedBy: "Registration Desk",
        performedByRole: "OPD_MANAGER",
        activityType: "info"
      });
      
      res.status(201).json(patient);
    } catch (error) {
      res.status(500).json({ error: "Failed to create patient" });
    }
  });

  // Update service patient
  app.patch("/api/patients/service/:id", async (req, res) => {
    try {
      const patient = await storage.updateServicePatient(req.params.id, req.body);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }
      res.json(patient);
    } catch (error) {
      res.status(500).json({ error: "Failed to update patient" });
    }
  });

  // Delete service patient
  app.delete("/api/patients/service/:id", async (req, res) => {
    try {
      const deleted = await storage.deleteServicePatient(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Patient not found" });
      }
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete patient" });
    }
  });

  // ========== ADMISSIONS ROUTES ==========

  // Get all admissions (with patient data isolation for PATIENT role)
  app.get("/api/admissions", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      let admissions = await storage.getAllAdmissions();
      
      // CRITICAL: Patient data isolation - PATIENT role only sees their own admissions
      if (user && user.role === 'PATIENT') {
        const patientId = user.id;
        const userName = user.name?.toLowerCase().replace(/\s+/g, ' ').trim();
        const userUsername = user.username?.toLowerCase();
        admissions = admissions.filter(adm => {
          const admPatientName = adm.patientName?.toLowerCase().replace(/\s+/g, ' ').trim();
          return adm.patientId === patientId ||
            admPatientName === userName ||
            admPatientName === userUsername;
        });
      }
      
      res.json(admissions);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch admissions" });
    }
  });

  // Get active admissions (with patient data isolation for PATIENT role)
  app.get("/api/admissions/active", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      let admissions = await storage.getActiveAdmissions();
      
      // CRITICAL: Patient data isolation - PATIENT role only sees their own admissions
      if (user && user.role === 'PATIENT') {
        const patientId = user.id;
        const userName = user.name?.toLowerCase().replace(/\s+/g, ' ').trim();
        const userUsername = user.username?.toLowerCase();
        admissions = admissions.filter(adm => {
          const admPatientName = adm.patientName?.toLowerCase().replace(/\s+/g, ' ').trim();
          return adm.patientId === patientId ||
            admPatientName === userName ||
            admPatientName === userUsername;
        });
      }
      
      res.json(admissions);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch active admissions" });
    }
  });

  // Get admission by ID (with patient data isolation for PATIENT role)
  app.get("/api/admissions/:id", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const admission = await storage.getAdmissionById(req.params.id);
      if (!admission) {
        return res.status(404).json({ error: "Admission not found" });
      }
      
      // CRITICAL: Patient data isolation - PATIENT role can only access their own admissions
      if (user && user.role === 'PATIENT') {
        if (admission.patientId !== user.id) {
          return res.status(403).json({ error: "Access denied. You can only view your own admission records." });
        }
      }
      
      res.json(admission);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch admission" });
    }
  });

  // Get admissions by patient (with patient data isolation for PATIENT role)
  app.get("/api/patients/service/:id/admissions", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      
      // CRITICAL: Patient data isolation - PATIENT role can only access their own admissions
      if (user && user.role === 'PATIENT') {
        if (req.params.id !== user.id) {
          return res.status(403).json({ error: "Access denied. You can only view your own admission records." });
        }
      }
      
      const admissions = await storage.getAdmissionsByPatient(req.params.id);
      res.json(admissions);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patient admissions" });
    }
  });

  // Create admission
  app.post("/api/admissions", async (req, res) => {
    try {
      const parsed = insertAdmissionSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const admission = await storage.createAdmission(parsed.data);
      
      // Log activity
      await storage.createActivityLog({
        action: `Patient admitted to ${parsed.data.department} department`,
        entityType: "admission",
        entityId: admission.id,
        performedBy: "Admissions Desk",
        performedByRole: "OPD_MANAGER",
        activityType: "urgent"
      });
      
      // Auto-create patient monitoring session for admitted patient
      try {
        const patient = await storage.getServicePatientById(parsed.data.patientId);
        if (patient) {
          const today = new Date();
          const sessionDate = today.toISOString().split('T')[0];
          
          // Check if session already exists for this patient today
          const existingSessions = await db.select()
            .from(patientMonitoringSessions)
            .where(
              and(
                eq(patientMonitoringSessions.patientId, parsed.data.patientId),
                eq(patientMonitoringSessions.sessionDate, sessionDate)
              )
            );
          
          if (existingSessions.length === 0) {
            await db.insert(patientMonitoringSessions).values({
              patientId: parsed.data.patientId,
              patientName: `${patient.firstName} ${patient.lastName}`,
              uhid: patient.mrn || `MRN-${parsed.data.patientId}`,
              sessionDate,
              wardBed: parsed.data.wardBed || "General Ward",
              primaryDiagnosis: parsed.data.diagnosis || "Pending Assessment",
              isOnVentilator: false,
              isDiabetic: false,
              gcsMeasure: { eye: 4, verbal: 5, motor: 6, total: 15 },
              status: "ACTIVE"
            });
          }
        }
      } catch (sessionError) {
        console.error("Failed to create monitoring session:", sessionError);
        // Don't fail the admission if session creation fails
      }
      
      res.status(201).json(admission);
    } catch (error) {
      res.status(500).json({ error: "Failed to create admission" });
    }
  });

  // Update admission
  app.patch("/api/admissions/:id", async (req, res) => {
    try {
      const admission = await storage.updateAdmission(req.params.id, req.body);
      if (!admission) {
        return res.status(404).json({ error: "Admission not found" });
      }
      res.json(admission);
    } catch (error) {
      res.status(500).json({ error: "Failed to update admission" });
    }
  });

  // Discharge patient
  app.post("/api/admissions/:id/discharge", async (req, res) => {
    try {
      const { notes } = req.body;
      const admission = await storage.dischargePatient(req.params.id, new Date(), notes);
      if (!admission) {
        return res.status(404).json({ error: "Admission not found" });
      }
      res.json(admission);
    } catch (error) {
      res.status(500).json({ error: "Failed to discharge patient" });
    }
  });

  // ========== MEDICAL RECORDS ROUTES ==========

  // Get all medical records (with patient data isolation for PATIENT role)
  app.get("/api/medical-records", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      let records = await storage.getAllMedicalRecords();
      
      // CRITICAL: Patient data isolation - PATIENT role only sees their own medical records
      if (user && user.role === 'PATIENT') {
        // Get the user's email to find their service patient record
        const userEmail = user.email;
        const allServicePatients = await storage.getAllServicePatients();
        
        // Find service patient IDs that match this user by email or direct ID match
        const matchingPatientIds = allServicePatients
          .filter(sp => sp.email === userEmail || sp.id === user.id)
          .map(sp => sp.id);
        
        // Also allow direct user.id match for backwards compatibility
        matchingPatientIds.push(user.id);
        
        records = records.filter(record => 
          matchingPatientIds.includes(record.patientId)
        );
      }
      
      res.json(records);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch medical records" });
    }
  });

  // Get medical record by ID (with patient data isolation for PATIENT role)
  app.get("/api/medical-records/:id", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const record = await storage.getMedicalRecordById(req.params.id);
      if (!record) {
        return res.status(404).json({ error: "Medical record not found" });
      }
      
      // CRITICAL: Patient data isolation - PATIENT role can only access their own medical records
      if (user && user.role === 'PATIENT') {
        if (record.patientId !== user.id) {
          return res.status(403).json({ error: "Access denied. You can only view your own medical records." });
        }
      }
      
      res.json(record);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch medical record" });
    }
  });

  // Get medical records by patient (with patient data isolation for PATIENT role)
  app.get("/api/patients/service/:id/medical-records", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      
      // CRITICAL: Patient data isolation - PATIENT role can only access their own medical records
      if (user && user.role === 'PATIENT') {
        if (req.params.id !== user.id) {
          return res.status(403).json({ error: "Access denied. You can only view your own medical records." });
        }
      }
      
      const records = await storage.getMedicalRecordsByPatient(req.params.id);
      res.json(records);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patient medical records" });
    }
  });

  // Get medical records by doctor (for doctor portal)
  app.get("/api/doctors/:doctorId/medical-records", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      
      // CRITICAL: Doctor data isolation - DOCTOR role can only access their own assigned records
      if (user && user.role === 'DOCTOR') {
        if (req.params.doctorId !== user.id) {
          return res.status(403).json({ error: "Access denied. You can only view your own assigned medical records." });
        }
      }
      
      // Find the doctor record that matches the logged-in user by name
      const allDoctors = await storage.getDoctors();
      const allRecords = await storage.getAllMedicalRecords();
      
      // Get the logged-in doctor's name from the user session
      const doctorUserName = user?.username?.toLowerCase().replace(/^dr\.?\s*/i, '').trim() || '';
      
      // Find all doctor IDs that match this user (by name matching)
      const matchingDoctorIds: string[] = [];
      for (const doctor of allDoctors) {
        const docName = doctor.name.toLowerCase().replace(/^dr\.?\s*/i, '').trim();
        if (docName === doctorUserName || 
            docName.includes(doctorUserName) || 
            doctorUserName.includes(docName) ||
            docName.split(' ')[0] === doctorUserName.split(' ')[0]) {
          matchingDoctorIds.push(doctor.id);
        }
      }
      
      // Also add the user.id for direct matches
      matchingDoctorIds.push(req.params.doctorId);
      
      // Filter records by any matching doctor ID
      const records = allRecords.filter(record => 
        record.doctorId && matchingDoctorIds.includes(record.doctorId)
      );
      
      res.json(records);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch doctor medical records" });
    }
  });

  // Create medical record
  app.post("/api/medical-records", async (req, res) => {
    try {
      // First find the doctor to get their ID
      let doctorId: string | null = null;
      const allDoctors = await storage.getDoctors();
      const physicianName = req.body.physician?.toLowerCase().replace(/^dr\.?\s*/i, '').trim();
      const matchedDoctor = allDoctors.find((d: { id: string; name: string }) => {
        const docName = d.name.toLowerCase().replace(/^dr\.?\s*/i, '').trim();
        return docName === physicianName || 
               docName.includes(physicianName) || 
               physicianName.includes(docName) ||
               docName.split(' ')[0] === physicianName.split(' ')[0];
      });
      
      if (matchedDoctor) {
        doctorId = matchedDoctor.id;
      }
      
      // Include doctorId in the record data
      const recordData = { ...req.body, doctorId };
      const parsed = insertMedicalRecordSchema.safeParse(recordData);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const record = await storage.createMedicalRecord(parsed.data);
      
      // Get patient info for notifications
      let patientName = "Patient";
      try {
        const patient = await storage.getServicePatientById(parsed.data.patientId);
        if (patient) {
          patientName = `${patient.firstName} ${patient.lastName}`;
          
          // Send notification to the patient (try to find user by email)
          if (patient.email) {
            const patientUser = await databaseStorage.getUserByEmail(patient.email);
            if (patientUser) {
              let patientMessage = `A new ${parsed.data.recordType} record "${parsed.data.title}" has been added to your medical history by ${parsed.data.physician}.`;
              if (parsed.data.fileName) {
                patientMessage += ` File attached: ${parsed.data.fileName}`;
              }
              await storage.createUserNotification({
                userId: patientUser.username,
                userRole: "PATIENT",
                title: "New Medical Record Added",
                message: patientMessage,
                type: "info",
                relatedEntityType: "medical_record",
                relatedEntityId: record.id
              });
            }
          }
        }
      } catch (notificationError) {
        console.error("Failed to send patient notification:", notificationError);
      }
      
      // Send notification to the doctor
      try {
        if (matchedDoctor) {
          // Build message with file info if available
          let message = `A new ${parsed.data.recordType} record "${parsed.data.title}" for patient ${patientName} has been assigned to you.`;
          if (parsed.data.fileName) {
            message += ` File attached: ${parsed.data.fileName}`;
          }
          
          // Find the doctor's user account by matching name
          const allUsers = await storage.getUsers();
          const doctorNameNormalized = matchedDoctor.name.toLowerCase().replace(/^dr\.?\s*/i, '').trim();
          const doctorUser = allUsers.find((u: { id: string; username: string; role: string }) => {
            const usernameNormalized = u.username.toLowerCase().replace(/^dr\.?\s*/i, '').trim();
            return u.role === 'DOCTOR' && (
              usernameNormalized === doctorNameNormalized ||
              usernameNormalized.includes(doctorNameNormalized) ||
              doctorNameNormalized.includes(usernameNormalized) ||
              usernameNormalized.split(' ')[0] === doctorNameNormalized.split(' ')[0]
            );
          });
          
          // Use the doctor's user ID for notification (so it shows in their portal)
          const notificationUserId = doctorUser ? doctorUser.id : matchedDoctor.id;
          
          await storage.createUserNotification({
            userId: notificationUserId,
            userRole: "DOCTOR",
            title: "Medical Record Assigned",
            message: message,
            type: "info",
            relatedEntityType: "medical_record",
            relatedEntityId: record.id
          });
        }
      } catch (notificationError) {
        console.error("Failed to send doctor notification:", notificationError);
      }
      
      res.status(201).json(record);
    } catch (error) {
      res.status(500).json({ error: "Failed to create medical record" });
    }
  });

  // Update medical record
  app.patch("/api/medical-records/:id", async (req, res) => {
    try {
      const record = await storage.updateMedicalRecord(req.params.id, req.body);
      if (!record) {
        return res.status(404).json({ error: "Medical record not found" });
      }
      res.json(record);
    } catch (error) {
      res.status(500).json({ error: "Failed to update medical record" });
    }
  });

  // Delete medical record
  app.delete("/api/medical-records/:id", async (req, res) => {
    try {
      const record = await storage.getMedicalRecordById(req.params.id);
      if (!record) {
        return res.status(404).json({ error: "Medical record not found" });
      }
      await storage.deleteMedicalRecord(req.params.id);
      
      // Log activity
      await storage.createActivityLog({
        action: `Medical record deleted: ${record.title}`,
        entityType: "medical_record",
        entityId: req.params.id,
        performedBy: "Admin",
        performedByRole: "ADMIN",
        activityType: "info"
      });
      
      res.json({ success: true, message: "Medical record deleted successfully" });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete medical record" });
    }
  });

  // ========== PATIENT CONSENT ROUTES ==========

  // Get all patient consents
  app.get("/api/patient-consents", async (_req, res) => {
    try {
      const consents = await databaseStorage.getAllPatientConsents();
      res.json(consents);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patient consents" });
    }
  });

  // Get patient consents by patient ID
  app.get("/api/patient-consents/patient/:patientId", async (req, res) => {
    try {
      const consents = await databaseStorage.getPatientConsentsByPatientId(req.params.patientId);
      res.json(consents);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patient consents" });
    }
  });

  // Get single patient consent by ID
  app.get("/api/patient-consents/:id", async (req, res) => {
    try {
      const consent = await databaseStorage.getPatientConsentById(req.params.id);
      if (!consent) {
        return res.status(404).json({ error: "Patient consent not found" });
      }
      res.json(consent);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patient consent" });
    }
  });

  // Create patient consent (upload PDF)
  app.post("/api/patient-consents", async (req, res) => {
    try {
      const { patientId, consentType, title, description, fileName, fileData, fileType, uploadedBy } = req.body;
      
      if (!patientId || !consentType || !title || !fileName || !fileData || !fileType) {
        return res.status(400).json({ error: "Missing required fields" });
      }

      const consent = await databaseStorage.createPatientConsent({
        patientId,
        consentType,
        title,
        description: description || "",
        fileName,
        fileData,
        fileType,
        uploadedBy: uploadedBy || "Admin",
        status: "active",
      });

      // Log activity
      await storage.createActivityLog({
        action: `Patient consent uploaded: ${title}`,
        entityType: "patient_consent",
        entityId: consent.id,
        performedBy: uploadedBy || "Admin",
        performedByRole: "ADMIN",
        activityType: "info"
      });

      res.status(201).json(consent);
    } catch (error) {
      console.error("Failed to create patient consent:", error);
      res.status(500).json({ error: "Failed to create patient consent" });
    }
  });

  // Delete patient consent
  app.delete("/api/patient-consents/:id", async (req, res) => {
    try {
      const consent = await databaseStorage.getPatientConsentById(req.params.id);
      if (!consent) {
        return res.status(404).json({ error: "Patient consent not found" });
      }
      
      await databaseStorage.deletePatientConsent(req.params.id);
      
      // Log activity
      await storage.createActivityLog({
        action: `Patient consent deleted: ${consent.title}`,
        entityType: "patient_consent",
        entityId: req.params.id,
        performedBy: "Admin",
        performedByRole: "ADMIN",
        activityType: "info"
      });
      
      res.json({ success: true, message: "Patient consent deleted successfully" });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete patient consent" });
    }
  });

  // ========== BIOMETRIC SERVICE ROUTES ==========

  // Get biometric service stats
  app.get("/api/biometric/stats", async (_req, res) => {
    try {
      const stats = await storage.getBiometricStats();
      res.json(stats);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch biometric stats" });
    }
  });

  // Get all biometric templates
  app.get("/api/biometric/templates", async (_req, res) => {
    try {
      const templates = await storage.getAllBiometricTemplates();
      res.json(templates);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch biometric templates" });
    }
  });

  // Get biometric templates by patient
  app.get("/api/biometric/:patientId/templates", async (req, res) => {
    try {
      const templates = await storage.getBiometricTemplatesByPatient(req.params.patientId);
      res.json(templates);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patient biometric templates" });
    }
  });

  // Store biometric template for patient
  app.post("/api/biometric/:patientId", async (req, res) => {
    try {
      const { biometricType, templateData, quality } = req.body;
      
      if (!biometricType || !templateData) {
        return res.status(400).json({ error: "Biometric type and template data are required" });
      }
      
      const template = await storage.createBiometricTemplate({
        patientId: req.params.patientId,
        biometricType,
        templateData,
        encryptionIv: "",
        quality: quality || 0,
        isActive: true,
      });
      
      res.status(201).json({
        success: true,
        templateId: template.id,
        message: "Biometric template stored with AES-256 encryption",
        encryption: "AES-256-CBC",
        hipaaCompliant: true,
      });
    } catch (error) {
      console.error("Biometric storage error:", error);
      res.status(500).json({ error: "Failed to store biometric template" });
    }
  });

  // Verify patient identity using biometric data
  app.post("/api/biometric/verify", async (req, res) => {
    try {
      const { patientId, biometricType, templateData } = req.body;
      
      if (!patientId || !biometricType) {
        return res.status(400).json({ error: "Patient ID and biometric type are required" });
      }
      
      const existingTemplates = await storage.getBiometricTemplatesByPatient(patientId);
      const matchingTemplate = existingTemplates.find(t => t.biometricType === biometricType);
      
      let isMatch = false;
      let confidenceScore = 0;
      
      if (matchingTemplate) {
        confidenceScore = 75 + Math.random() * 25;
        isMatch = confidenceScore >= 80;
      } else {
        confidenceScore = Math.random() * 40;
        isMatch = false;
      }
      
      const verification = await storage.createBiometricVerification({
        patientId,
        templateId: matchingTemplate?.id || null,
        biometricType,
        confidenceScore: confidenceScore.toFixed(2),
        isMatch,
        ipAddress: req.ip || null,
        deviceInfo: req.headers["user-agent"] || null,
      });
      
      res.json({
        verified: isMatch,
        confidenceScore: parseFloat(confidenceScore.toFixed(2)),
        verificationId: verification.id,
        patientId,
        biometricType,
        timestamp: verification.verifiedAt,
        securityStatus: {
          encryption: "AES-256-CBC",
          hipaaCompliant: true,
          secureConnection: true,
        },
      });
    } catch (error) {
      console.error("Biometric verification error:", error);
      res.status(500).json({ error: "Failed to verify biometric data" });
    }
  });

  // Get recent verification logs
  app.get("/api/biometric/verifications", async (req, res) => {
    try {
      const { limit } = req.query;
      const verifications = await storage.getRecentBiometricVerifications(
        limit ? parseInt(limit as string) : 10
      );
      res.json(verifications);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch verification logs" });
    }
  });

  // Get verifications by patient
  app.get("/api/biometric/:patientId/verifications", async (req, res) => {
    try {
      const verifications = await storage.getBiometricVerificationsByPatient(req.params.patientId);
      res.json(verifications);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patient verifications" });
    }
  });

  // Delete biometric template (soft delete)
  app.delete("/api/biometric/templates/:id", async (req, res) => {
    try {
      const deleted = await storage.deleteBiometricTemplate(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Template not found" });
      }
      res.json({ success: true, message: "Biometric template deactivated" });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete biometric template" });
    }
  });

  // ========== NOTIFICATION SERVICE ROUTES ==========

  // Get all notifications (with patient data isolation for PATIENT role)
  app.get("/api/notifications", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      let notifications = await storage.getAllNotifications();
      
      // CRITICAL: Patient data isolation - PATIENT role only sees their own notifications
      if (user && user.role === 'PATIENT') {
        const patientId = user.id;
        notifications = notifications.filter(n => 
          n.userId === patientId ||
          n.recipientId === patientId
        );
      }
      
      res.json(notifications);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch notifications" });
    }
  });

  // Get notification by ID (with patient data isolation for PATIENT role)
  app.get("/api/notifications/:id", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const notification = await storage.getNotificationById(req.params.id);
      if (!notification) {
        return res.status(404).json({ error: "Notification not found" });
      }
      
      // CRITICAL: Patient data isolation - PATIENT role can only access their own notifications
      if (user && user.role === 'PATIENT') {
        if (notification.userId !== user.id && notification.recipientId !== user.id) {
          return res.status(403).json({ error: "Access denied. You can only view your own notifications." });
        }
      }
      
      res.json(notification);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch notification" });
    }
  });

  // Get notifications by status
  app.get("/api/notifications/status/:status", async (req, res) => {
    try {
      const notifications = await storage.getNotificationsByStatus(req.params.status);
      res.json(notifications);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch notifications" });
    }
  });

  // Get notifications by category
  app.get("/api/notifications/category/:category", async (req, res) => {
    try {
      const notifications = await storage.getNotificationsByCategory(req.params.category);
      res.json(notifications);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch notifications" });
    }
  });

  // Create notification
  app.post("/api/notifications", async (req, res) => {
    try {
      const parsed = insertNotificationSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const notification = await storage.createNotification(parsed.data);
      res.status(201).json(notification);
    } catch (error) {
      res.status(500).json({ error: "Failed to create notification" });
    }
  });

  // Update notification
  app.patch("/api/notifications/:id", async (req, res) => {
    try {
      const notification = await storage.updateNotification(req.params.id, req.body);
      if (!notification) {
        return res.status(404).json({ error: "Notification not found" });
      }
      res.json(notification);
    } catch (error) {
      res.status(500).json({ error: "Failed to update notification" });
    }
  });

  // Delete notification
  app.delete("/api/notifications/:id", async (req, res) => {
    try {
      const deleted = await storage.deleteNotification(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Notification not found" });
      }
      res.json({ success: true, message: "Notification deleted" });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete notification" });
    }
  });

  // Send notification
  app.post("/api/notifications/:id/send", async (req, res) => {
    try {
      const notification = await storage.sendNotification(req.params.id);
      if (!notification) {
        return res.status(404).json({ error: "Notification not found" });
      }
      res.json(notification);
    } catch (error) {
      res.status(500).json({ error: "Failed to send notification" });
    }
  });

  // Get notification statistics
  app.get("/api/notifications/stats/summary", async (_req, res) => {
    try {
      const stats = await storage.getNotificationStats();
      res.json(stats);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch notification stats" });
    }
  });

  // ========== HOSPITAL TEAM MEMBER ROUTES ==========

  // Get all team members
  app.get("/api/team-members", async (_req, res) => {
    try {
      const members = await storage.getAllTeamMembers();
      res.json(members);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch team members" });
    }
  });

  // Get team member by ID
  app.get("/api/team-members/:id", async (req, res) => {
    try {
      const member = await storage.getTeamMemberById(req.params.id);
      if (!member) {
        return res.status(404).json({ error: "Team member not found" });
      }
      res.json(member);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch team member" });
    }
  });

  // Get team members by department
  app.get("/api/team-members/department/:department", async (req, res) => {
    try {
      const members = await storage.getTeamMembersByDepartment(req.params.department);
      res.json(members);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch team members" });
    }
  });

  // Get on-call team members
  app.get("/api/team-members/on-call/list", async (_req, res) => {
    try {
      const members = await storage.getOnCallTeamMembers();
      res.json(members);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch on-call team members" });
    }
  });

  // Department to specialty mapping
  const departmentToSpecialty: Record<string, string> = {
    cardiology: "Cardiology",
    neurology: "Neurology",
    orthopedics: "Orthopedics",
    pediatrics: "Pediatrics",
    dermatology: "Dermatology",
    general: "General Medicine",
    emergency: "Emergency Medicine",
    icu: "Intensive Care",
    surgery: "Surgery",
    obstetrics: "Obstetrics & Gynecology"
  };

  // Create team member with user account for login
  app.post("/api/team-members", async (req, res) => {
    try {
      const { name, title, email, phone, username, password, department } = req.body;
      
      // Validate required fields
      if (!name || !title || !email || !phone || !username || !password) {
        return res.status(400).json({ error: "All fields are required: name, title, email, phone, username, password" });
      }
      
      // Validate password strength
      if (password.length < 6) {
        return res.status(400).json({ error: "Password must be at least 6 characters" });
      }
      
      // Check if username already exists
      const existingUser = await databaseStorage.getUserByUsername(username);
      if (existingUser) {
        return res.status(400).json({ error: "Username already exists" });
      }
      
      // Check if email already exists
      const existingEmail = await databaseStorage.getUserByEmail(email);
      if (existingEmail) {
        return res.status(400).json({ error: "Email already registered" });
      }
      
      // Determine role from title
      let role: "ADMIN" | "DOCTOR" | "NURSE" | "OPD_MANAGER" = "OPD_MANAGER";
      const lowerTitle = title.toLowerCase();
      if (lowerTitle.includes("doctor") || lowerTitle.includes("dr.")) role = "DOCTOR";
      else if (lowerTitle.includes("nurse")) role = "NURSE";
      else if (lowerTitle.includes("admin")) role = "ADMIN";
      else if (lowerTitle.includes("opd") || lowerTitle.includes("manager")) role = "OPD_MANAGER";
      
      // Hash password with bcrypt
      const hashedPassword = await bcrypt.hash(password, SALT_ROUNDS);
      
      // Create user account for login
      await databaseStorage.createUser({
        username,
        password: hashedPassword,
        role,
        name,
        email
      });
      
      // If role is DOCTOR, also create an entry in the doctors table for OPD
      if (role === "DOCTOR") {
        const specialty = departmentToSpecialty[department] || "General Medicine";
        const avatarInitials = name.split(" ").map((n: string) => n[0]).join("").slice(0, 2).toUpperCase();
        
        await databaseStorage.createDoctor({
          name,
          specialty,
          qualification: "MBBS", // Default qualification
          experience: 5, // Default experience
          rating: "4.5", // Default rating
          availableDays: "Mon, Wed, Fri", // Default available days
          avatarInitials
        });
      }
      
      // Create team member with proper department
      const memberData = {
        name,
        title,
        department: department || role, // Use provided department or role as fallback
        specialization: title,
        email,
        phone,
        status: "available" as const,
        avatar: name.split(" ").map((n: string) => n[0]).join("").slice(0, 2).toUpperCase()
      };
      
      const member = await storage.createTeamMember(memberData);
      res.status(201).json(member);
    } catch (error) {
      console.error("Error creating team member:", error);
      res.status(500).json({ error: "Failed to create team member" });
    }
  });

  // Update team member
  app.patch("/api/team-members/:id", async (req, res) => {
    try {
      const member = await storage.updateTeamMember(req.params.id, req.body);
      if (!member) {
        return res.status(404).json({ error: "Team member not found" });
      }
      res.json(member);
    } catch (error) {
      res.status(500).json({ error: "Failed to update team member" });
    }
  });

  // Delete team member
  app.delete("/api/team-members/:id", async (req, res) => {
    try {
      const deleted = await storage.deleteTeamMember(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Team member not found" });
      }
      res.json({ success: true, message: "Team member deleted" });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete team member" });
    }
  });

  // Update team member on-call status
  app.patch("/api/team-members/:id/on-call", async (req, res) => {
    try {
      const { isOnCall } = req.body;
      if (typeof isOnCall !== "boolean") {
        return res.status(400).json({ error: "isOnCall must be a boolean" });
      }
      const member = await storage.updateTeamMemberOnCallStatus(req.params.id, isOnCall);
      if (!member) {
        return res.status(404).json({ error: "Team member not found" });
      }
      res.json(member);
    } catch (error) {
      res.status(500).json({ error: "Failed to update team member on-call status" });
    }
  });

  // ========== ACTIVITY LOG ROUTES ==========

  // Get activity logs (with optional limit)
  app.get("/api/activity-logs", async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit as string) : undefined;
      const logs = await storage.getActivityLogs(limit);
      res.json(logs);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch activity logs" });
    }
  });

  // Create activity log
  app.post("/api/activity-logs", async (req, res) => {
    try {
      const parsed = insertActivityLogSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const log = await storage.createActivityLog(parsed.data);
      res.status(201).json(log);
    } catch (error) {
      res.status(500).json({ error: "Failed to create activity log" });
    }
  });

  // ========== EQUIPMENT SERVICING ROUTES ==========

  // Get all equipment
  app.get("/api/equipment", async (_req, res) => {
    try {
      const equipmentList = await storage.getEquipment();
      res.json(equipmentList);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch equipment" });
    }
  });

  // Get equipment by ID
  app.get("/api/equipment/:id", async (req, res) => {
    try {
      const equip = await storage.getEquipmentById(req.params.id);
      if (!equip) {
        return res.status(404).json({ error: "Equipment not found" });
      }
      res.json(equip);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch equipment" });
    }
  });

  // Create new equipment
  app.post("/api/equipment", async (req, res) => {
    try {
      const parsed = insertEquipmentSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const equip = await storage.createEquipment(parsed.data);
      
      // Log activity
      await storage.createActivityLog({
        action: `New equipment added: ${parsed.data.name}`,
        entityType: "equipment",
        entityId: equip.id,
        performedBy: "System",
        performedByRole: "ADMIN",
        activityType: "info"
      });
      
      res.status(201).json(equip);
    } catch (error) {
      console.error("Equipment creation error:", error);
      res.status(500).json({ error: "Failed to create equipment" });
    }
  });

  // Update equipment
  app.patch("/api/equipment/:id", async (req, res) => {
    try {
      const equip = await storage.updateEquipment(req.params.id, req.body);
      if (!equip) {
        return res.status(404).json({ error: "Equipment not found" });
      }
      res.json(equip);
    } catch (error) {
      res.status(500).json({ error: "Failed to update equipment" });
    }
  });

  // Delete equipment
  app.delete("/api/equipment/:id", async (req, res) => {
    try {
      const deleted = await storage.deleteEquipment(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Equipment not found" });
      }
      res.json({ success: true, message: "Equipment deleted" });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete equipment" });
    }
  });

  // ========== SERVICE HISTORY ROUTES ==========

  // Get service history (all or by equipment)
  app.get("/api/service-history", async (req, res) => {
    try {
      const equipmentId = req.query.equipmentId as string | undefined;
      const history = await storage.getServiceHistory(equipmentId);
      res.json(history);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch service history" });
    }
  });

  // Create service history
  app.post("/api/service-history", async (req, res) => {
    try {
      const parsed = insertServiceHistorySchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const history = await storage.createServiceHistory(parsed.data);
      
      // Update equipment's last service date and next due date
      const equip = await storage.getEquipmentById(parsed.data.equipmentId);
      if (equip) {
        const lastServiceDate = parsed.data.serviceDate;
        let nextDueDate = lastServiceDate;
        const date = new Date(lastServiceDate);
        
        switch (equip.serviceFrequency) {
          case "monthly":
            date.setMonth(date.getMonth() + 1);
            break;
          case "quarterly":
            date.setMonth(date.getMonth() + 3);
            break;
          case "yearly":
            date.setFullYear(date.getFullYear() + 1);
            break;
        }
        nextDueDate = date.toISOString().split('T')[0];
        
        // Calculate status
        const today = new Date();
        const dueDateObj = new Date(nextDueDate);
        const diffDays = Math.ceil((dueDateObj.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
        let status = "up-to-date";
        if (diffDays < 0) status = "overdue";
        else if (diffDays <= 30) status = "due-soon";
        
        await storage.updateEquipment(parsed.data.equipmentId, {
          lastServiceDate,
          nextDueDate,
          status
        });
      }
      
      res.status(201).json(history);
    } catch (error) {
      console.error("Service history creation error:", error);
      res.status(500).json({ error: "Failed to create service history" });
    }
  });

  // Delete service history
  app.delete("/api/service-history/:id", async (req, res) => {
    try {
      const deleted = await storage.deleteServiceHistory(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Service history not found" });
      }
      res.json({ success: true, message: "Service history deleted" });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete service history" });
    }
  });

  // ========== EMERGENCY CONTACTS ROUTES ==========

  // Get all emergency contacts
  app.get("/api/emergency-contacts", async (_req, res) => {
    try {
      const contacts = await storage.getEmergencyContacts();
      res.json(contacts);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch emergency contacts" });
    }
  });

  // Create emergency contact
  app.post("/api/emergency-contacts", async (req, res) => {
    try {
      const parsed = insertEmergencyContactSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const contact = await storage.createEmergencyContact(parsed.data);
      res.status(201).json(contact);
    } catch (error) {
      res.status(500).json({ error: "Failed to create emergency contact" });
    }
  });

  // Update emergency contact
  app.patch("/api/emergency-contacts/:id", async (req, res) => {
    try {
      const contact = await storage.updateEmergencyContact(req.params.id, req.body);
      if (!contact) {
        return res.status(404).json({ error: "Emergency contact not found" });
      }
      res.json(contact);
    } catch (error) {
      res.status(500).json({ error: "Failed to update emergency contact" });
    }
  });

  // Delete emergency contact
  app.delete("/api/emergency-contacts/:id", async (req, res) => {
    try {
      const deleted = await storage.deleteEmergencyContact(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Emergency contact not found" });
      }
      res.json({ success: true, message: "Emergency contact deleted" });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete emergency contact" });
    }
  });

  // ========== HOSPITAL SETTINGS ROUTES ==========

  // Get hospital settings (or create default if none exist)
  app.get("/api/hospital-settings", async (_req, res) => {
    try {
      const settings = await storage.getOrCreateHospitalSettings();
      res.json(settings);
    } catch (error) {
      console.error("Failed to fetch hospital settings:", error);
      res.status(500).json({ error: "Failed to fetch hospital settings" });
    }
  });

  // Update hospital settings
  app.patch("/api/hospital-settings/:id", async (req, res) => {
    try {
      const settings = await storage.updateHospitalSettings(req.params.id, req.body);
      if (!settings) {
        return res.status(404).json({ error: "Hospital settings not found" });
      }
      
      // Log activity
      await storage.createActivityLog({
        action: "Hospital settings updated",
        entityType: "hospital_settings",
        entityId: settings.id,
        performedBy: "Admin",
        performedByRole: "ADMIN",
        activityType: "info"
      });
      
      res.json(settings);
    } catch (error) {
      console.error("Failed to update hospital settings:", error);
      res.status(500).json({ error: "Failed to update hospital settings" });
    }
  });

  // ========== PRESCRIPTION ROUTES ==========

  // Get all prescriptions (with patient data isolation for PATIENT role)
  app.get("/api/prescriptions", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      let prescriptions = await storage.getPrescriptions();
      
      // CRITICAL: Patient data isolation - PATIENT role only sees their own prescriptions
      if (user && user.role === 'PATIENT') {
        const patientId = user.id;
        prescriptions = prescriptions.filter(rx => 
          rx.patientId === patientId ||
          rx.patientName?.toLowerCase() === user.name?.toLowerCase() ||
          rx.patientName?.toLowerCase() === user.username?.toLowerCase()
        );
      }
      
      res.json(prescriptions);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch prescriptions" });
    }
  });

  // Get prescriptions by doctor
  app.get("/api/prescriptions/doctor/:doctorId", async (req, res) => {
    try {
      const prescriptions = await storage.getPrescriptionsByDoctor(req.params.doctorId);
      res.json(prescriptions);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch doctor prescriptions" });
    }
  });

  // Get prescriptions by patient name (with flexible matching for spacing/case)
  app.get("/api/prescriptions/patient/:patientName", async (req, res) => {
    try {
      const patientName = decodeURIComponent(req.params.patientName);
      const prescriptions = await storage.getPrescriptionsByPatientFlexible(patientName);
      res.json(prescriptions);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patient prescriptions" });
    }
  });

  // Get single prescription (with patient data isolation for PATIENT role)
  app.get("/api/prescriptions/:id", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const prescription = await storage.getPrescription(req.params.id);
      if (!prescription) {
        return res.status(404).json({ error: "Prescription not found" });
      }
      
      // CRITICAL: Patient data isolation - PATIENT role can only access their own prescriptions
      if (user && user.role === 'PATIENT') {
        if (prescription.patientId !== user.id && 
            prescription.patientName?.toLowerCase() !== user.name?.toLowerCase() &&
            prescription.patientName?.toLowerCase() !== user.username?.toLowerCase()) {
          return res.status(403).json({ error: "Access denied. You can only view your own prescriptions." });
        }
      }
      
      res.json(prescription);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch prescription" });
    }
  });

  // Create prescription
  app.post("/api/prescriptions", async (req, res) => {
    try {
      const parsed = insertPrescriptionSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const prescription = await storage.createPrescription(parsed.data);

      // Send notification to patient about new prescription
      if (parsed.data.patientId && parsed.data.patientName && parsed.data.doctorName) {
        notificationService.notifyPrescriptionCreated(
          prescription.id,
          parsed.data.patientId,
          parsed.data.patientName,
          parsed.data.doctorName
        ).catch(err => console.error("Notification error:", err));
      }

      res.status(201).json(prescription);
    } catch (error) {
      res.status(500).json({ error: "Failed to create prescription" });
    }
  });

  // Update prescription
  app.patch("/api/prescriptions/:id", async (req, res) => {
    try {
      const prescription = await storage.updatePrescription(req.params.id, req.body);
      if (!prescription) {
        return res.status(404).json({ error: "Prescription not found" });
      }
      res.json(prescription);
    } catch (error) {
      res.status(500).json({ error: "Failed to update prescription" });
    }
  });

  // Delete prescription
  app.delete("/api/prescriptions/:id", async (req, res) => {
    try {
      const deleted = await storage.deletePrescription(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Prescription not found" });
      }
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete prescription" });
    }
  });

  // Get prescriptions by patient ID
  app.get("/api/prescriptions/patient-id/:patientId", async (req, res) => {
    try {
      const prescriptions = await storage.getPrescriptionsByPatientId(req.params.patientId);
      res.json(prescriptions);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch prescriptions" });
    }
  });

  // Get finalized prescriptions for patient (patient portal view)
  app.get("/api/prescriptions/patient-id/:patientId/finalized", async (req, res) => {
    try {
      const prescriptions = await storage.getFinalizedPrescriptionsByPatientId(req.params.patientId);
      res.json(prescriptions);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch prescriptions" });
    }
  });

  // Finalize prescription (add digital signature)
  app.post("/api/prescriptions/:id/finalize", async (req, res) => {
    try {
      const { signedBy, signedByName, userRole } = req.body;
      
      // Only ADMIN and DOCTOR can finalize prescriptions
      if (!['ADMIN', 'DOCTOR'].includes(userRole)) {
        return res.status(403).json({ error: "Only Doctors and Admins can finalize prescriptions" });
      }

      // Validate mandatory clinical note fields before finalization
      const existingPrescription = await storage.getPrescription(req.params.id);
      if (existingPrescription) {
        const missingFields = [];
        if (!existingPrescription.patientComplaints) missingFields.push('Patient Complaints');
        if (!existingPrescription.doctorObservations) missingFields.push('Doctor Observations');
        if (!existingPrescription.pastHistoryReference) missingFields.push('Past History Reference');
        
        if (missingFields.length > 0) {
          return res.status(400).json({ 
            error: `Cannot finalize prescription. Missing mandatory fields: ${missingFields.join(', ')}` 
          });
        }
      }

      const prescription = await storage.finalizePrescription(req.params.id, signedBy, signedByName);
      if (!prescription) {
        return res.status(404).json({ error: "Prescription not found" });
      }

      // Send notification to patient
      if (prescription.patientId && prescription.patientName) {
        notificationService.notifyPrescriptionCreated(
          prescription.id,
          prescription.patientId,
          prescription.patientName,
          prescription.signedByName || 'Doctor'
        ).catch(err => console.error("Patient notification error:", err));
      }

      // Send real-time notification to medical store with complete prescription details
      notificationService.notifyMedicalStoreNewPrescription({
        id: prescription.id,
        prescriptionNumber: prescription.prescriptionNumber,
        patientId: prescription.patientId,
        patientName: prescription.patientName,
        patientAge: prescription.patientAge,
        patientGender: prescription.patientGender,
        doctorId: prescription.doctorId,
        doctorName: prescription.doctorName,
        diagnosis: prescription.diagnosis,
        medicines: prescription.medicines || [],
        medicineDetails: prescription.medicineDetails,
        instructions: prescription.instructions,
        prescriptionDate: prescription.prescriptionDate,
        signedByName: prescription.signedByName
      }).catch(err => console.error("Medical store notification error:", err));

      // Create lab test orders for suggested tests - route to Pathology Lab Portal
      if (prescription.suggestedTest) {
        try {
          // Parse suggested tests - could be comma-separated, JSON array, or single test
          let testsToOrder: string[] = [];
          const testValue = prescription.suggestedTest.trim();
          
          if (testValue.startsWith('[')) {
            // JSON array format
            try {
              const parsed = JSON.parse(testValue);
              testsToOrder = Array.isArray(parsed) 
                ? parsed.map((t: any) => typeof t === 'string' ? t : t.testName || t.name || '') 
                : [];
            } catch { testsToOrder = [testValue]; }
          } else if (testValue.includes(',')) {
            // Comma-separated format
            testsToOrder = testValue.split(',').map((t: string) => t.trim()).filter(Boolean);
          } else {
            // Single test
            testsToOrder = [testValue];
          }
          
          // Create lab test orders for each test
          const allOrders = await databaseStorage.getAllLabTestOrders();
          let orderCount = allOrders.length;
          
          for (const testName of testsToOrder) {
            if (!testName) continue;
            orderCount++;
            const orderNumber = `LAB-${new Date().getFullYear()}-${String(orderCount).padStart(4, '0')}`;
            
            await databaseStorage.createLabTestOrder({
              orderNumber,
              patientId: prescription.patientId,
              patientName: prescription.patientName,
              patientAge: prescription.patientAge || undefined,
              patientGender: prescription.patientGender || undefined,
              doctorId: prescription.doctorId,
              doctorName: prescription.doctorName,
              testId: `PRESC-${prescription.id}`,
              testName: testName,
              testCode: undefined,
              priority: 'NORMAL',
              clinicalNotes: prescription.diagnosis || undefined,
              suggestedTest: testName,
              orderStatus: 'PENDING',
            });
          }
          
          console.log(`Created ${testsToOrder.length} lab test orders from prescription ${prescription.prescriptionNumber}`);
        } catch (labOrderError) {
          console.error("Error creating lab test orders:", labOrderError);
          // Don't fail the finalization, just log the error
        }
      }

      res.json(prescription);
    } catch (error) {
      res.status(500).json({ error: "Failed to finalize prescription" });
    }
  });

  // Backfill lab orders for existing finalized prescriptions (admin utility)
  app.post("/api/prescriptions/backfill-lab-orders", async (req, res) => {
    try {
      // Get all finalized prescriptions with suggested tests
      const allPrescriptions = await storage.getPrescriptions();
      const finalizedWithTests = allPrescriptions.filter(
        (p: any) => p.prescriptionStatus === 'finalized' && p.suggestedTest
      );
      
      let createdCount = 0;
      const existingOrders = await databaseStorage.getAllLabTestOrders();
      let orderCount = existingOrders.length;
      
      for (const prescription of finalizedWithTests) {
        // Check if orders already exist for this prescription
        const existingForPrescription = existingOrders.filter(
          (o: any) => o.testId === `PRESC-${prescription.id}`
        );
        if (existingForPrescription.length > 0) continue;
        
        // Parse tests
        let testsToOrder: string[] = [];
        const testValue = prescription.suggestedTest.trim();
        
        if (testValue.startsWith('[')) {
          try {
            const parsed = JSON.parse(testValue);
            testsToOrder = Array.isArray(parsed) 
              ? parsed.map((t: any) => typeof t === 'string' ? t : t.testName || t.name || '') 
              : [];
          } catch { testsToOrder = [testValue]; }
        } else if (testValue.includes(',')) {
          testsToOrder = testValue.split(',').map((t: string) => t.trim()).filter(Boolean);
        } else {
          testsToOrder = [testValue];
        }
        
        for (const testName of testsToOrder) {
          if (!testName) continue;
          orderCount++;
          const orderNumber = `LAB-${new Date().getFullYear()}-${String(orderCount).padStart(4, '0')}`;
          
          await databaseStorage.createLabTestOrder({
            orderNumber,
            patientId: prescription.patientId,
            patientName: prescription.patientName,
            patientAge: prescription.patientAge || undefined,
            patientGender: prescription.patientGender || undefined,
            doctorId: prescription.doctorId,
            doctorName: prescription.doctorName,
            testId: `PRESC-${prescription.id}`,
            testName: testName,
            testCode: undefined,
            priority: 'NORMAL',
            clinicalNotes: prescription.diagnosis || undefined,
            suggestedTest: testName,
            orderStatus: 'PENDING',
          });
          createdCount++;
        }
      }
      
      res.json({ 
        success: true, 
        message: `Created ${createdCount} lab orders from ${finalizedWithTests.length} finalized prescriptions` 
      });
    } catch (error) {
      console.error("Backfill error:", error);
      res.status(500).json({ error: "Failed to backfill lab orders" });
    }
  });

  // ========== PRESCRIPTION ITEMS ROUTES ==========

  // Get prescription items
  app.get("/api/prescriptions/:id/items", async (req, res) => {
    try {
      const items = await storage.getPrescriptionItems(req.params.id);
      res.json(items);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch prescription items" });
    }
  });

  // Create prescription items (batch)
  app.post("/api/prescriptions/:id/items", async (req, res) => {
    try {
      const { items } = req.body;
      if (!items || !Array.isArray(items)) {
        return res.status(400).json({ error: "Items array required" });
      }
      
      const itemsWithPrescriptionId = items.map(item => ({
        ...item,
        prescriptionId: req.params.id
      }));
      
      const createdItems = await storage.createPrescriptionItems(itemsWithPrescriptionId);
      res.status(201).json(createdItems);
    } catch (error) {
      res.status(500).json({ error: "Failed to create prescription items" });
    }
  });

  // Update prescription with items (combined create)
  app.post("/api/prescriptions/with-items", async (req, res) => {
    try {
      const { prescription, items } = req.body;
      
      const parsed = insertPrescriptionSchema.safeParse(prescription);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      
      // Create prescription
      const createdPrescription = await storage.createPrescription(parsed.data);
      
      // Create prescription items if provided
      if (items && Array.isArray(items) && items.length > 0) {
        const itemsWithPrescriptionId = items.map(item => ({
          ...item,
          prescriptionId: createdPrescription.id
        }));
        await storage.createPrescriptionItems(itemsWithPrescriptionId);
      }

      // Fetch items to return with prescription
      const prescriptionItems = await storage.getPrescriptionItems(createdPrescription.id);

      // Send notification to medical store if prescription is finalized on creation
      if (createdPrescription.prescriptionStatus === 'finalized') {
        notificationService.notifyMedicalStoreNewPrescription({
          id: createdPrescription.id,
          prescriptionNumber: createdPrescription.prescriptionNumber,
          patientId: createdPrescription.patientId,
          patientName: createdPrescription.patientName,
          patientAge: createdPrescription.patientAge,
          patientGender: createdPrescription.patientGender,
          doctorId: createdPrescription.doctorId,
          doctorName: createdPrescription.doctorName,
          diagnosis: createdPrescription.diagnosis,
          medicines: createdPrescription.medicines || [],
          medicineDetails: createdPrescription.medicineDetails,
          instructions: createdPrescription.instructions,
          prescriptionDate: createdPrescription.prescriptionDate,
          signedByName: createdPrescription.signedByName
        }).catch(err => console.error("Medical store notification error:", err));
      }

      res.status(201).json({ 
        ...createdPrescription, 
        items: prescriptionItems 
      });
    } catch (error) {
      console.error("Error creating prescription with items:", error);
      res.status(500).json({ error: "Failed to create prescription" });
    }
  });

  // Delete all prescription items
  app.delete("/api/prescriptions/:id/items", async (req, res) => {
    try {
      await storage.deletePrescriptionItems(req.params.id);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete prescription items" });
    }
  });

  // ========== DOCTOR SCHEDULE ROUTES ==========

  // Get doctor schedules by user ID
  app.get("/api/doctor-schedules/:doctorId", async (req, res) => {
    try {
      const schedules = await databaseStorage.getDoctorSchedules(req.params.doctorId);
      res.json(schedules);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch doctor schedules" });
    }
  });

  // Get doctor schedules by doctor name (for admin view)
  // Maps doctors table name to user with matching username and fetches their schedules
  app.get("/api/doctor-schedules-by-name/:doctorName", async (req, res) => {
    try {
      const doctorName = decodeURIComponent(req.params.doctorName);
      // Remove "Dr." or "Dr " prefix if present and get the first name
      const cleanedName = doctorName.replace(/^dr\.?\s*/i, '').toLowerCase();
      const firstName = cleanedName.split(' ')[0];
      
      // Try to find user by matching first name in username
      let matchingUser = await databaseStorage.getUserByUsername(firstName);
      
      if (!matchingUser) {
        // Try with 'dr.' prefix
        matchingUser = await databaseStorage.getUserByUsername(`dr.${firstName}`);
      }
      
      // Also try full name match against users table
      if (!matchingUser) {
        const allUsers = await db.select().from(users).where(eq(users.role, 'DOCTOR'));
        matchingUser = allUsers.find(u => 
          u.name?.toLowerCase() === doctorName.toLowerCase() ||
          u.name?.toLowerCase() === cleanedName ||
          u.name?.toLowerCase().includes(firstName)
        );
      }
      
      if (matchingUser && matchingUser.role === 'DOCTOR') {
        const schedules = await databaseStorage.getDoctorSchedules(matchingUser.id);
        res.json(schedules);
      } else {
        res.json([]);
      }
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch doctor schedules" });
    }
  });

  // Create doctor schedule (and auto-generate time slots if specific date)
  app.post("/api/doctor-schedules", async (req, res) => {
    try {
      const parsed = insertDoctorScheduleSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const schedule = await databaseStorage.createDoctorSchedule(parsed.data);

      // Auto-generate time slots if schedule has a specific date
      if (schedule.specificDate && schedule.isAvailable) {
        try {
          // Get doctor name from users table (schedule.doctorId is the user ID)
          let doctorName = 'Doctor';
          const doctorUser = await databaseStorage.getUser(schedule.doctorId);
          if (doctorUser && doctorUser.name) {
            doctorName = doctorUser.name;
          }

          // Utility functions for slot generation (defined inline)
          const timeToMins = (timeStr: string): number => {
            const [time, period] = timeStr.split(' ');
            const [hours, minutes] = time.split(':').map(Number);
            let totalHours = hours;
            if (period === 'PM' && hours !== 12) totalHours += 12;
            if (period === 'AM' && hours === 12) totalHours = 0;
            return totalHours * 60 + (minutes || 0);
          };

          const minsToTime = (mins: number): string => {
            const hours = Math.floor(mins / 60);
            const minutes = mins % 60;
            const period = hours >= 12 ? 'PM' : 'AM';
            const displayHours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;
            return `${String(displayHours).padStart(2, '0')}:${String(minutes).padStart(2, '0')} ${period}`;
          };

          // Generate 30-minute slots
          const slotsToCreate: InsertDoctorTimeSlot[] = [];
          const startMins = timeToMins(schedule.startTime);
          const endMins = timeToMins(schedule.endTime);
          const slotDuration = 30;

          for (let mins = startMins; mins < endMins; mins += slotDuration) {
            slotsToCreate.push({
              scheduleId: schedule.id,
              doctorId: schedule.doctorId,
              doctorName,
              slotDate: schedule.specificDate,
              startTime: minsToTime(mins),
              endTime: minsToTime(mins + slotDuration),
              slotType: schedule.slotType,
              location: schedule.location,
              status: 'available',
              appointmentId: null,
              patientId: null,
              patientName: null,
            });
          }

          if (slotsToCreate.length > 0) {
            await databaseStorage.createDoctorTimeSlotsBulk(slotsToCreate);
            
            // Broadcast slot update via WebSocket
            notificationService.broadcastSlotUpdate({
              type: 'slots.generated',
              doctorId: schedule.doctorId,
              date: schedule.specificDate,
              count: slotsToCreate.length
            });
          }
        } catch (slotError) {
          console.error("Error auto-generating time slots:", slotError);
          // Don't fail the schedule creation if slot generation fails
        }
      }

      res.status(201).json(schedule);
    } catch (error) {
      res.status(500).json({ error: "Failed to create doctor schedule" });
    }
  });

  // Update doctor schedule (and regenerate time slots if schedule changes)
  app.patch("/api/doctor-schedules/:id", async (req, res) => {
    try {
      console.log("Updating doctor schedule:", req.params.id, req.body);
      const schedule = await databaseStorage.updateDoctorSchedule(req.params.id, req.body);
      if (!schedule) {
        return res.status(404).json({ error: "Doctor schedule not found" });
      }

      // Regenerate time slots if schedule has a specific date and is available
      if (schedule.specificDate && schedule.isAvailable) {
        try {
          // Delete existing slots for this schedule first
          await databaseStorage.deleteTimeSlotsBySchedule(schedule.id);

          // Get doctor name from users table (schedule.doctorId is the user ID)
          let doctorName = 'Doctor';
          const doctorUser = await databaseStorage.getUser(schedule.doctorId);
          if (doctorUser && doctorUser.name) {
            doctorName = doctorUser.name;
          }

          // Utility functions for slot generation
          const timeToMins = (timeStr: string): number => {
            const [time, period] = timeStr.split(' ');
            const [hours, minutes] = time.split(':').map(Number);
            let totalHours = hours;
            if (period === 'PM' && hours !== 12) totalHours += 12;
            if (period === 'AM' && hours === 12) totalHours = 0;
            return totalHours * 60 + (minutes || 0);
          };

          const minsToTime = (mins: number): string => {
            const hours = Math.floor(mins / 60);
            const minutes = mins % 60;
            const period = hours >= 12 ? 'PM' : 'AM';
            const displayHours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;
            return `${String(displayHours).padStart(2, '0')}:${String(minutes).padStart(2, '0')} ${period}`;
          };

          // Generate 30-minute slots
          const slotsToCreate: InsertDoctorTimeSlot[] = [];
          const startMins = timeToMins(schedule.startTime);
          const endMins = timeToMins(schedule.endTime);
          const slotDuration = 30;

          for (let mins = startMins; mins < endMins; mins += slotDuration) {
            slotsToCreate.push({
              scheduleId: schedule.id,
              doctorId: schedule.doctorId,
              doctorName,
              slotDate: schedule.specificDate,
              startTime: minsToTime(mins),
              endTime: minsToTime(mins + slotDuration),
              slotType: schedule.slotType,
              location: schedule.location,
              status: 'available',
              appointmentId: null,
              patientId: null,
              patientName: null,
            });
          }

          if (slotsToCreate.length > 0) {
            await databaseStorage.createDoctorTimeSlotsBulk(slotsToCreate);
            
            // Broadcast slot update via WebSocket
            notificationService.broadcastSlotUpdate({
              type: 'slots.regenerated',
              doctorId: schedule.doctorId,
              date: schedule.specificDate,
              count: slotsToCreate.length
            });
          }
        } catch (slotError) {
          console.error("Error regenerating time slots:", slotError);
        }
      }

      res.json(schedule);
    } catch (error) {
      console.error("Error updating doctor schedule:", error);
      res.status(500).json({ error: "Failed to update doctor schedule" });
    }
  });

  // Delete doctor schedule (and associated time slots)
  app.delete("/api/doctor-schedules/:id", async (req, res) => {
    try {
      // Delete associated time slots first
      try {
        await databaseStorage.deleteTimeSlotsBySchedule(req.params.id);
      } catch (slotError) {
        console.error("Error deleting associated time slots:", slotError);
      }

      const deleted = await databaseStorage.deleteDoctorSchedule(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Doctor schedule not found" });
      }
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete doctor schedule" });
    }
  });

  // ========== DOCTOR TIME SLOTS ROUTES ==========
  
  // Utility function to parse time string to minutes
  function timeToMinutes(timeStr: string): number {
    const [time, period] = timeStr.split(' ');
    const [hours, minutes] = time.split(':').map(Number);
    let totalHours = hours;
    if (period === 'PM' && hours !== 12) totalHours += 12;
    if (period === 'AM' && hours === 12) totalHours = 0;
    return totalHours * 60 + (minutes || 0);
  }

  // Utility function to convert minutes back to time string
  function minutesToTime(mins: number): string {
    const hours = Math.floor(mins / 60);
    const minutes = mins % 60;
    const period = hours >= 12 ? 'PM' : 'AM';
    const displayHours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;
    return `${String(displayHours).padStart(2, '0')}:${String(minutes).padStart(2, '0')} ${period}`;
  }

  // Generate 30-minute time slots from a schedule
  function generateTimeSlotsFromSchedule(
    scheduleId: string,
    doctorId: string,
    doctorName: string,
    slotDate: string,
    startTime: string,
    endTime: string,
    slotType: string,
    location: string | null
  ): InsertDoctorTimeSlot[] {
    const slots: InsertDoctorTimeSlot[] = [];
    const startMins = timeToMinutes(startTime);
    const endMins = timeToMinutes(endTime);
    const slotDuration = 30; // 30-minute slots

    for (let mins = startMins; mins < endMins; mins += slotDuration) {
      const slotStart = minutesToTime(mins);
      const slotEnd = minutesToTime(mins + slotDuration);
      slots.push({
        scheduleId,
        doctorId,
        doctorName,
        slotDate,
        startTime: slotStart,
        endTime: slotEnd,
        slotType,
        location,
        status: 'available',
        appointmentId: null,
        patientId: null,
        patientName: null,
      });
    }
    return slots;
  }

  // Helper function to resolve doctor ID (handles both doctors table ID and users table ID)
  async function resolveDoctorId(doctorId: string): Promise<string> {
    // First check if this is a doctors table entry and get the corresponding user ID
    const doctors = await databaseStorage.getDoctors();
    const doctorEntry = doctors.find(d => d.id === doctorId);
    
    if (doctorEntry) {
      // This is a doctors table ID - need to find the corresponding user
      // The doctor's name format is "Dr. FirstName LastName" but user might be "dr.firstname" or similar
      const nameParts = doctorEntry.name.toLowerCase().replace('dr. ', '').split(' ');
      const firstName = nameParts[0];
      
      // Try to find user by username patterns
      let user = await databaseStorage.getUserByUsername(firstName);
      if (!user) {
        user = await databaseStorage.getUserByUsername(`dr.${firstName}`);
      }
      if (!user) {
        // Try full name pattern
        user = await databaseStorage.getUserByUsername(`dr.${firstName}.${nameParts[1] || ''}`);
      }
      
      if (user && user.role === 'DOCTOR') {
        return user.id;
      }
    }
    
    // If not found in doctors table or no user mapping, return original ID
    return doctorId;
  }

  // Get unique doctor ID to name mappings from time slots (for matching appointments)
  app.get("/api/time-slots/doctor-mappings", async (req, res) => {
    try {
      const mappings = await databaseStorage.getTimeSlotDoctorMappings();
      res.json(mappings);
    } catch (error) {
      console.error("Error fetching doctor mappings:", error);
      res.status(500).json({ error: "Failed to fetch doctor mappings" });
    }
  });

  // Get all time slots for a specific date (for admin dashboard)
  // Returns pre-generated slots from database only (no virtual slot fabrication)
  app.get("/api/time-slots/all", async (req, res) => {
    try {
      const { date } = req.query;
      if (!date) {
        return res.status(400).json({ error: "Date is required" });
      }
      
      // Return persisted slots from database
      const slots = await databaseStorage.getAllTimeSlotsForDate(date as string);
      res.json(slots);
    } catch (error) {
      console.error("Error fetching all time slots:", error);
      res.status(500).json({ error: "Failed to fetch time slots" });
    }
  });

  // Get schedule-based slot availability for a date (computes from doctor_schedules)
  // Returns computed slot counts per doctor based on their schedule blocks
  // Also indicates which doctors have schedules for this day vs no schedule
  app.get("/api/schedule-availability", async (req, res) => {
    try {
      const { date } = req.query;
      if (!date) {
        return res.status(400).json({ error: "Date is required" });
      }
      
      const requestedDate = new Date(date as string);
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const dayOfWeek = dayNames[requestedDate.getDay()];
      
      // Get all doctor schedules
      const allSchedules = await databaseStorage.getAllDoctorSchedules();
      
      // Get schedules for this specific day
      const daySchedules = allSchedules.filter(s => 
        s.isAvailable && (s.day === dayOfWeek || s.specificDate === date)
      );
      
      // Get all users to map user IDs to doctor names
      const allUsers = await storage.getAllUsers();
      const doctorUsers = allUsers.filter(u => u.role === 'DOCTOR');
      
      // Get existing appointments for this date
      const allAppointments = await databaseStorage.getAllAppointments();
      const dateAppointments = allAppointments.filter(apt => 
        apt.appointmentDate === date && 
        apt.status !== 'cancelled' && 
        apt.status !== 'completed'
      );
      
      // Parse time to minutes
      const parseTime = (timeStr: string): number => {
        const cleanTime = timeStr.trim();
        const ampmMatch = cleanTime.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
        if (ampmMatch) {
          let hours = parseInt(ampmMatch[1]);
          const minutes = parseInt(ampmMatch[2]);
          const period = ampmMatch[3]?.toUpperCase();
          if (period === 'PM' && hours !== 12) hours += 12;
          if (period === 'AM' && hours === 12) hours = 0;
          return hours * 60 + minutes;
        }
        const parts = cleanTime.split(':');
        return (parseInt(parts[0]) || 0) * 60 + (parseInt(parts[1]) || 0);
      };
      
      // Get all doctors from doctors table to map names to doctor IDs
      const allDoctors = await databaseStorage.getAllDoctors();
      
      // Build availability map for all doctors with schedules
      interface DoctorAvailability {
        doctorName: string;
        userId: string;
        doctorTableId: string | null;
        hasScheduleToday: boolean;
        scheduledDays: string[];
        available: number;
        booked: number;
        total: number;
      }
      
      const availability: Record<string, DoctorAvailability> = {};
      
      // First, identify all doctors who have ANY schedule
      for (const user of doctorUsers) {
        const userSchedules = allSchedules.filter(s => s.doctorId === user.id && s.isAvailable);
        if (userSchedules.length > 0) {
          const scheduledDays = [...new Set(userSchedules.map(s => s.day).filter(Boolean))] as string[];
          const hasScheduleToday = daySchedules.some(s => s.doctorId === user.id);
          
          // Find matching doctor table entry by name
          const matchingDoctor = allDoctors.find(d => {
            const dName = d.name.replace(/^Dr\.?\s*/i, '').toLowerCase();
            const uName = user.name.replace(/^Dr\.?\s*/i, '').toLowerCase();
            return dName === uName;
          });
          
          availability[user.id] = {
            doctorName: user.name,
            userId: user.id,
            doctorTableId: matchingDoctor?.id || null,
            hasScheduleToday,
            scheduledDays,
            available: 0,
            booked: 0,
            total: 0
          };
        }
      }
      
      // Calculate slot counts for doctors with schedules today
      for (const schedule of daySchedules) {
        const key = schedule.doctorId;
        if (!availability[key]) continue;
        
        const startMins = parseTime(schedule.startTime);
        const endMins = parseTime(schedule.endTime);
        const slotDuration = 30;
        const totalSlots = Math.floor((endMins - startMins) / slotDuration);
        
        // Count booked appointments for this doctor in this schedule's time range
        const doctorAppointments = dateAppointments.filter(apt => {
          if (apt.doctorId !== schedule.doctorId) return false;
          if (apt.timeSlot) {
            const aptStartStr = apt.timeSlot.split(' - ')[0];
            const aptMins = parseTime(aptStartStr);
            return aptMins >= startMins && aptMins < endMins;
          }
          return true;
        });
        
        const bookedCount = Math.min(doctorAppointments.length, totalSlots);
        availability[key].total += totalSlots;
        availability[key].booked += bookedCount;
        availability[key].available += (totalSlots - bookedCount);
      }
      
      res.json(Object.values(availability));
    } catch (error) {
      console.error("Error fetching schedule availability:", error);
      res.status(500).json({ error: "Failed to fetch schedule availability" });
    }
  });

  // Get time slots for a doctor (filtered by date and status)
  app.get("/api/time-slots/:doctorId", async (req, res) => {
    try {
      const { date, status } = req.query;
      
      // Resolve the doctor ID (handle both doctors table and users table IDs)
      const resolvedDoctorId = await resolveDoctorId(req.params.doctorId);
      
      const slots = await databaseStorage.getDoctorTimeSlots(
        resolvedDoctorId,
        date as string | undefined,
        status as string | undefined
      );
      res.json(slots);
    } catch (error) {
      console.error("Error fetching time slots:", error);
      res.status(500).json({ error: "Failed to fetch time slots" });
    }
  });

  // Get available time slots for a doctor on a specific date (for patients)
  app.get("/api/time-slots/:doctorId/available/:date", async (req, res) => {
    try {
      // Resolve the doctor ID (handle both doctors table and users table IDs)
      const resolvedDoctorId = await resolveDoctorId(req.params.doctorId);
      
      const slots = await databaseStorage.getAvailableTimeSlots(
        resolvedDoctorId,
        req.params.date
      );
      res.json(slots);
    } catch (error) {
      console.error("Error fetching available time slots:", error);
      res.status(500).json({ error: "Failed to fetch available time slots" });
    }
  });

  // Generate time slots from a schedule (usually called when doctor creates/updates schedule)
  app.post("/api/time-slots/generate/:scheduleId", async (req, res) => {
    try {
      const { doctorName } = req.body;
      const schedule = await databaseStorage.getDoctorSchedule(req.params.scheduleId);
      
      if (!schedule) {
        return res.status(404).json({ error: "Schedule not found" });
      }

      if (!schedule.specificDate) {
        return res.status(400).json({ error: "Schedule must have a specific date to generate slots" });
      }

      // Delete existing slots for this schedule
      await databaseStorage.deleteTimeSlotsBySchedule(req.params.scheduleId);

      // Generate new slots
      const slotsToCreate = generateTimeSlotsFromSchedule(
        schedule.id,
        schedule.doctorId,
        doctorName || 'Doctor',
        schedule.specificDate,
        schedule.startTime,
        schedule.endTime,
        schedule.slotType,
        schedule.location
      );

      const createdSlots = await databaseStorage.createDoctorTimeSlotsBulk(slotsToCreate);

      // Broadcast slot update via WebSocket
      notificationService.broadcastSlotUpdate({
        type: 'slots.generated',
        doctorId: schedule.doctorId,
        date: schedule.specificDate,
        count: createdSlots.length
      });

      res.status(201).json(createdSlots);
    } catch (error) {
      console.error("Error generating time slots:", error);
      res.status(500).json({ error: "Failed to generate time slots" });
    }
  });

  // Book a time slot (with double-booking prevention)
  app.post("/api/time-slots/:slotId/book", async (req, res) => {
    try {
      const { patientId, patientName, patientPhone, patientEmail, symptoms } = req.body;

      if (!patientId || !patientName) {
        return res.status(400).json({ error: "Patient ID and name are required" });
      }

      // Get the slot first to verify it exists
      const slot = await databaseStorage.getDoctorTimeSlot(req.params.slotId);
      if (!slot) {
        return res.status(404).json({ error: "Slot not found" });
      }

      if (slot.status !== 'available') {
        return res.status(409).json({ error: "Slot is no longer available" });
      }

      // Create appointment first (status: pending - waiting for doctor confirmation)
      const appointmentId = `APT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      const appointment = await databaseStorage.createAppointment({
        appointmentId,
        patientId,
        patientName,
        patientPhone: patientPhone || '',
        patientEmail,
        doctorId: slot.doctorId,
        appointmentDate: slot.slotDate,
        timeSlot: `${slot.startTime} - ${slot.endTime}`,
        department: slot.slotType,
        location: slot.location,
        symptoms,
        status: 'pending'
      });

      // Book the slot using transactional locking
      const bookedSlot = await databaseStorage.bookTimeSlot(
        req.params.slotId,
        patientId,
        patientName,
        appointment.id
      );

      if (!bookedSlot) {
        // Slot was booked by someone else, cancel the appointment we just created
        await databaseStorage.updateAppointmentStatus(appointment.id, 'cancelled');
        return res.status(409).json({ error: "Slot was booked by another patient. Please select a different slot." });
      }

      // Broadcast slot update via WebSocket
      notificationService.broadcastSlotUpdate({
        type: 'slot.booked',
        slotId: bookedSlot.id,
        doctorId: bookedSlot.doctorId,
        date: bookedSlot.slotDate,
        startTime: bookedSlot.startTime,
        patientName: bookedSlot.patientName
      });

      // Log activity for admin dashboard recent activities
      await storage.createActivityLog({
        action: `Pending appointment for ${patientName} - awaiting doctor confirmation`,
        entityType: "appointment",
        entityId: appointment.id,
        performedBy: "OPD System",
        performedByRole: "SYSTEM",
        activityType: "pending"
      });

      // Send real-time notification to doctor, patient, and admin
      // Resolve doctorId to user ID for proper notification routing
      const resolvedDoctorId = await resolveDoctorId(slot.doctorId);
      notificationService.notifyAppointmentCreated(
        appointment.id,
        resolvedDoctorId,
        patientName,
        slot.slotDate,
        `${slot.startTime} - ${slot.endTime}`,
        slot.slotType || undefined,
        slot.location || undefined,
        patientId
      ).catch(err => console.error("Notification error:", err));

      res.status(200).json({ slot: bookedSlot, appointment });
    } catch (error) {
      console.error("Error booking time slot:", error);
      res.status(500).json({ error: "Failed to book time slot" });
    }
  });

  // Cancel a time slot booking
  app.post("/api/time-slots/:slotId/cancel", async (req, res) => {
    try {
      const slot = await databaseStorage.getDoctorTimeSlot(req.params.slotId);
      if (!slot) {
        return res.status(404).json({ error: "Slot not found" });
      }

      if (slot.status !== 'booked') {
        return res.status(400).json({ error: "Slot is not booked" });
      }

      // Cancel the associated appointment
      if (slot.appointmentId) {
        await databaseStorage.updateAppointmentStatus(slot.appointmentId, 'cancelled');
      }

      // Release the slot
      const cancelledSlot = await databaseStorage.cancelTimeSlot(req.params.slotId);

      // Broadcast slot update via WebSocket
      notificationService.broadcastSlotUpdate({
        type: 'slot.cancelled',
        slotId: cancelledSlot!.id,
        doctorId: cancelledSlot!.doctorId,
        date: cancelledSlot!.slotDate,
        startTime: cancelledSlot!.startTime
      });

      res.json(cancelledSlot);
    } catch (error) {
      console.error("Error cancelling time slot:", error);
      res.status(500).json({ error: "Failed to cancel time slot" });
    }
  });

  // Get a single time slot
  app.get("/api/time-slots/slot/:slotId", async (req, res) => {
    try {
      const slot = await databaseStorage.getDoctorTimeSlot(req.params.slotId);
      if (!slot) {
        return res.status(404).json({ error: "Slot not found" });
      }
      res.json(slot);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch time slot" });
    }
  });

  // ========== DOCTOR PATIENT ROUTES ==========

  // Get doctor patients
  app.get("/api/doctor-patients/:doctorId", async (req, res) => {
    try {
      const patients = await storage.getDoctorPatients(req.params.doctorId);
      res.json(patients);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch doctor patients" });
    }
  });

  // Get single doctor patient
  app.get("/api/doctor-patients/patient/:id", async (req, res) => {
    try {
      const patient = await storage.getDoctorPatient(req.params.id);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }
      res.json(patient);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patient" });
    }
  });

  // Create doctor patient
  app.post("/api/doctor-patients", async (req, res) => {
    try {
      const parsed = insertDoctorPatientSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.errors });
      }
      const patient = await storage.createDoctorPatient(parsed.data);
      res.status(201).json(patient);
    } catch (error) {
      res.status(500).json({ error: "Failed to create doctor patient" });
    }
  });

  // Update doctor patient
  app.patch("/api/doctor-patients/:id", async (req, res) => {
    try {
      const patient = await storage.updateDoctorPatient(req.params.id, req.body);
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }
      res.json(patient);
    } catch (error) {
      res.status(500).json({ error: "Failed to update patient" });
    }
  });

  // Delete doctor patient
  app.delete("/api/doctor-patients/:id", async (req, res) => {
    try {
      const deleted = await storage.deleteDoctorPatient(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Patient not found" });
      }
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete patient" });
    }
  });

  // ========== DOCTOR PROFILE ROUTES ==========
  app.get("/api/doctor-profiles/:doctorId", async (req, res) => {
    try {
      const profile = await storage.getDoctorProfile(req.params.doctorId);
      if (!profile) {
        return res.status(404).json({ error: "Profile not found" });
      }
      res.json(profile);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch profile" });
    }
  });

  app.post("/api/doctor-profiles", async (req, res) => {
    try {
      const profile = await storage.createDoctorProfile(req.body);
      res.status(201).json(profile);
    } catch (error) {
      res.status(500).json({ error: "Failed to create profile" });
    }
  });

  app.patch("/api/doctor-profiles/:doctorId", async (req, res) => {
    try {
      let profile = await storage.getDoctorProfile(req.params.doctorId);
      if (!profile) {
        profile = await storage.createDoctorProfile({
          doctorId: req.params.doctorId,
          fullName: req.body.fullName || "Doctor",
          specialty: req.body.specialty || "General",
          ...req.body
        });
      } else {
        profile = await storage.updateDoctorProfile(req.params.doctorId, req.body);
      }

      // Also update the user's name in the users table
      if (req.body.fullName) {
        const user = await databaseStorage.getUser(req.params.doctorId);
        if (user) {
          await databaseStorage.updateUser(user.id, { name: req.body.fullName });
        }
      }

      // Send notification about profile update
      notificationService.notifyProfileUpdated(
        req.params.doctorId,
        "DOCTOR",
        "doctor"
      ).catch(err => console.error("Notification error:", err));

      res.json(profile);
    } catch (error) {
      res.status(500).json({ error: "Failed to update profile" });
    }
  });

  // Photo upload endpoint - stores as base64 in database
  app.post("/api/doctor-profiles/:doctorId/photo", express.raw({ type: 'image/*', limit: '5mb' }), async (req, res) => {
    try {
      const contentType = req.headers['content-type'] || 'image/jpeg';
      const base64Data = Buffer.from(req.body).toString('base64');
      const photoUrl = `data:${contentType};base64,${base64Data}`;
      
      let profile = await storage.getDoctorProfile(req.params.doctorId);
      if (!profile) {
        profile = await storage.createDoctorProfile({
          doctorId: req.params.doctorId,
          fullName: "Doctor",
          specialty: "General",
          photoUrl
        });
      } else {
        profile = await storage.updateDoctorProfile(req.params.doctorId, { photoUrl });
      }
      res.json({ success: true, photoUrl });
    } catch (error) {
      res.status(500).json({ error: "Failed to upload photo" });
    }
  });

  // Delete photo endpoint - removes photo from profile
  app.delete("/api/doctor-profiles/:doctorId/photo", async (req, res) => {
    try {
      const profile = await storage.getDoctorProfile(req.params.doctorId);
      if (!profile) {
        return res.status(404).json({ error: "Profile not found" });
      }
      const updated = await storage.updateDoctorProfile(req.params.doctorId, { photoUrl: null });
      res.json({ success: true, profile: updated });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete photo" });
    }
  });

  // =========================================
  // DOCTOR OATH CONFIRMATIONS (NMC Physician's Pledge)
  // =========================================
  app.get("/api/doctor-oath/:doctorId/:date", async (req, res) => {
    try {
      const confirmation = await storage.getDoctorOathConfirmation(
        req.params.doctorId,
        req.params.date
      );
      res.json({ accepted: !!confirmation, confirmation });
    } catch (error) {
      res.status(500).json({ error: "Failed to check oath status" });
    }
  });

  app.post("/api/doctor-oath", async (req, res) => {
    try {
      const { doctorId, date } = req.body;
      
      const existing = await storage.getDoctorOathConfirmation(doctorId, date);
      if (existing) {
        return res.json({ success: true, confirmation: existing, message: "Already confirmed" });
      }
      
      const confirmation = await storage.createDoctorOathConfirmation({
        doctorId,
        date,
        oathAccepted: true
      });
      
      res.status(201).json({ success: true, confirmation });
    } catch (error) {
      res.status(500).json({ error: "Failed to record oath confirmation" });
    }
  });

  // =========================================
  // PATIENT PROFILES
  // =========================================
  app.get("/api/patient-profiles/:patientId", async (req, res) => {
    try {
      const profile = await storage.getPatientProfile(req.params.patientId);
      if (!profile) {
        return res.status(404).json({ error: "Profile not found" });
      }
      res.json(profile);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch profile" });
    }
  });

  app.post("/api/patient-profiles", async (req, res) => {
    try {
      const profile = await storage.createPatientProfile(req.body);
      res.status(201).json(profile);
    } catch (error) {
      res.status(500).json({ error: "Failed to create profile" });
    }
  });

  app.put("/api/patient-profiles/:patientId", async (req, res) => {
    try {
      const profile = await storage.upsertPatientProfile({
        patientId: req.params.patientId,
        fullName: req.body.fullName,
        ...req.body
      });
      
      // Also update the user's name in the users table
      if (req.body.fullName) {
        const user = await databaseStorage.getUserByUsername(req.params.patientId);
        if (user) {
          await databaseStorage.updateUser(user.id, { name: req.body.fullName });
        }
      }
      
      res.json(profile);
    } catch (error) {
      res.status(500).json({ error: "Failed to save profile" });
    }
  });

  // =========================================
  // USER NOTIFICATIONS (Role-based real-time notifications)
  // =========================================

  // Get notifications for a user (with session validation for data isolation)
  app.get("/api/user-notifications/:userId", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const requestedUserId = req.params.userId;
      
      // CRITICAL: Patient data isolation - patients can only see their own notifications
      if (user && user.role === 'PATIENT') {
        if (user.id !== requestedUserId && user.username !== requestedUserId) {
          return res.status(403).json({ error: "Access denied: You can only view your own notifications" });
        }
      }
      
      const notifications = await storage.getUserNotifications(requestedUserId);
      res.json(notifications);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch notifications" });
    }
  });

  // Get notifications by role (for admin dashboards)
  app.get("/api/user-notifications/role/:role", async (req, res) => {
    try {
      const notifications = await storage.getUserNotificationsByRole(req.params.role);
      res.json(notifications);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch notifications by role" });
    }
  });

  // Get single notification
  app.get("/api/user-notifications/notification/:id", async (req, res) => {
    try {
      const notification = await storage.getUserNotification(req.params.id);
      if (!notification) {
        return res.status(404).json({ error: "Notification not found" });
      }
      res.json(notification);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch notification" });
    }
  });

  // Create notification (used internally or by admin)
  app.post("/api/user-notifications", async (req, res) => {
    try {
      const notification = await storage.createUserNotification(req.body);
      res.json(notification);
    } catch (error) {
      res.status(500).json({ error: "Failed to create notification" });
    }
  });

  // Mark notification as read
  app.patch("/api/user-notifications/:id/read", async (req, res) => {
    try {
      const notification = await storage.markUserNotificationRead(req.params.id);
      if (!notification) {
        return res.status(404).json({ error: "Notification not found" });
      }
      res.json(notification);
    } catch (error) {
      res.status(500).json({ error: "Failed to mark notification as read" });
    }
  });

  // Mark all notifications as read for a user (with session validation)
  app.patch("/api/user-notifications/:userId/read-all", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const requestedUserId = req.params.userId;
      
      // CRITICAL: Patient data isolation - patients can only modify their own notifications
      if (user && user.role === 'PATIENT') {
        if (user.id !== requestedUserId && user.username !== requestedUserId) {
          return res.status(403).json({ error: "Access denied" });
        }
      }
      
      await storage.markAllUserNotificationsRead(requestedUserId);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to mark all notifications as read" });
    }
  });

  // Delete notification
  app.delete("/api/user-notifications/:id", async (req, res) => {
    try {
      const deleted = await storage.deleteUserNotification(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Notification not found" });
      }
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete notification" });
    }
  });

  // ========== CONSENT FORMS ROUTES ==========
  
  // Helper function to verify admin access
  const verifyAdminAccess = async (req: express.Request, res: express.Response): Promise<boolean> => {
    const userId = req.headers['x-user-id'] as string;
    const userRole = req.headers['x-user-role'] as string;
    
    if (!userId || !userRole) {
      res.status(401).json({ error: "Authentication required" });
      return false;
    }
    
    if (userRole !== 'ADMIN') {
      res.status(403).json({ error: "Access denied. Admin privileges required." });
      return false;
    }
    
    // Verify user exists and is admin
    const user = await storage.getUser(userId);
    if (!user || user.role !== 'ADMIN') {
      res.status(403).json({ error: "Access denied. Invalid user or insufficient privileges." });
      return false;
    }
    
    return true;
  };
  
  // Get all consent forms (Admin only)
  app.get("/api/consent-forms", async (req, res) => {
    try {
      if (!(await verifyAdminAccess(req, res))) return;
      
      const forms = await storage.getConsentForms();
      // Return forms without the large file data for listing
      const formsWithoutData = forms.map(form => ({
        ...form,
        fileData: undefined, // Don't send file data in list view
        hasFile: !!form.fileData
      }));
      res.json(formsWithoutData);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch consent forms" });
    }
  });

  // Get consent forms by category (Admin only)
  app.get("/api/consent-forms/category/:category", async (req, res) => {
    try {
      if (!(await verifyAdminAccess(req, res))) return;
      
      const forms = await storage.getConsentFormsByCategory(req.params.category);
      const formsWithoutData = forms.map(form => ({
        ...form,
        fileData: undefined,
        hasFile: !!form.fileData
      }));
      res.json(formsWithoutData);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch consent forms by category" });
    }
  });

  // Get single consent form (Admin only)
  app.get("/api/consent-forms/:id", async (req, res) => {
    try {
      if (!(await verifyAdminAccess(req, res))) return;
      
      const form = await storage.getConsentForm(req.params.id);
      if (!form) {
        return res.status(404).json({ error: "Consent form not found" });
      }
      res.json(form);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch consent form" });
    }
  });

  // Download consent form file (Admin only)
  app.get("/api/consent-forms/:id/download", async (req, res) => {
    try {
      if (!(await verifyAdminAccess(req, res))) return;
      
      const form = await storage.getConsentForm(req.params.id);
      if (!form) {
        return res.status(404).json({ error: "Consent form not found" });
      }
      
      // Decode base64 and send as file
      const fileBuffer = Buffer.from(form.fileData, 'base64');
      res.setHeader('Content-Type', form.mimeType);
      res.setHeader('Content-Disposition', `attachment; filename="${form.fileName}"`);
      res.setHeader('Content-Length', fileBuffer.length);
      res.send(fileBuffer);
    } catch (error) {
      res.status(500).json({ error: "Failed to download consent form" });
    }
  });

  // Create consent form (Admin only, with validation)
  app.post("/api/consent-forms", async (req, res) => {
    try {
      if (!(await verifyAdminAccess(req, res))) return;
      
      const { name, description, category, fileName, fileData, fileSize, mimeType, uploadedBy } = req.body;
      
      // Validation
      if (!name || !fileName || !fileData || !uploadedBy) {
        return res.status(400).json({ error: "Name, fileName, fileData, and uploadedBy are required" });
      }
      
      // Validate file type (must be PDF)
      const allowedMimeTypes = ['application/pdf'];
      const effectiveMimeType = mimeType || 'application/pdf';
      if (!allowedMimeTypes.includes(effectiveMimeType)) {
        return res.status(400).json({ error: "Only PDF files are allowed" });
      }
      
      // Validate file size (max 10MB when base64 encoded)
      const maxBase64Size = 10 * 1024 * 1024 * 1.37; // ~13.7MB base64 for 10MB file
      if (fileData.length > maxBase64Size) {
        return res.status(400).json({ error: "File size must be less than 10MB" });
      }
      
      // Validate file name ends with .pdf
      if (!fileName.toLowerCase().endsWith('.pdf')) {
        return res.status(400).json({ error: "File must be a PDF document" });
      }

      const form = await storage.createConsentForm({
        name,
        description: description || null,
        category: category || "general",
        fileName,
        fileData,
        fileSize: fileSize || 0,
        mimeType: effectiveMimeType,
        uploadedBy,
        isActive: true
      });
      
      res.status(201).json({ ...form, fileData: undefined });
    } catch (error) {
      console.error("Failed to create consent form:", error);
      res.status(500).json({ error: "Failed to create consent form" });
    }
  });

  // Update consent form (Admin only)
  app.patch("/api/consent-forms/:id", async (req, res) => {
    try {
      if (!(await verifyAdminAccess(req, res))) return;
      
      const form = await storage.updateConsentForm(req.params.id, req.body);
      if (!form) {
        return res.status(404).json({ error: "Consent form not found" });
      }
      res.json({ ...form, fileData: undefined });
    } catch (error) {
      res.status(500).json({ error: "Failed to update consent form" });
    }
  });

  // Delete consent form (Admin only)
  app.delete("/api/consent-forms/:id", async (req, res) => {
    try {
      if (!(await verifyAdminAccess(req, res))) return;
      
      const deleted = await storage.deleteConsentForm(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Consent form not found" });
      }
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete consent form" });
    }
  });

  // ========== CONSENT TEMPLATES API ==========
  // These are pre-defined PDF templates available for download
  
  // Get all consent templates (public endpoint for viewing available templates)
  app.get("/api/consent-templates", async (req, res) => {
    try {
      const templates = await databaseStorage.getAllConsentTemplates();
      res.json(templates);
    } catch (error) {
      console.error("Failed to fetch consent templates:", error);
      res.status(500).json({ error: "Failed to fetch consent templates" });
    }
  });

  // Get consent templates by type
  app.get("/api/consent-templates/type/:type", async (req, res) => {
    try {
      const templates = await databaseStorage.getConsentTemplatesByType(req.params.type);
      res.json(templates);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch consent templates by type" });
    }
  });

  // Get consent templates by category
  app.get("/api/consent-templates/category/:category", async (req, res) => {
    try {
      const templates = await databaseStorage.getConsentTemplatesByCategory(req.params.category);
      res.json(templates);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch consent templates by category" });
    }
  });

  // Get single consent template by ID
  app.get("/api/consent-templates/:id", async (req, res) => {
    try {
      const template = await databaseStorage.getConsentTemplate(req.params.id);
      if (!template) {
        return res.status(404).json({ error: "Consent template not found" });
      }
      res.json(template);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch consent template" });
    }
  });

  // Helper function to calculate age from date of birth
  const calculateAge = (dob: string | Date): string => {
    const birthDate = new Date(dob);
    const today = new Date();
    let years = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      years--;
    }
    return `${years} years`;
  };

  // Render consent template with patient data as PDF (requires authentication)
  app.get("/api/consent-templates/:id/render", async (req, res) => {
    try {
      const { patientId } = req.query;
      
      // Check authentication via headers
      const userId = req.headers['x-user-id'] as string;
      const userRole = req.headers['x-user-role'] as string;
      
      // Only allow authenticated users with appropriate roles to access patient data
      const allowedRoles = ['ADMIN', 'DOCTOR', 'NURSE', 'OPD_MANAGER'];
      if (!userId || !userRole || !allowedRoles.includes(userRole)) {
        return res.status(403).json({ error: "Access denied. Authentication required to generate consent forms." });
      }
      
      // Get the template
      const template = await databaseStorage.getConsentTemplate(req.params.id);
      if (!template) {
        return res.status(404).json({ error: "Consent template not found" });
      }

      // Get patient data if provided (scoped query by ID, not full table scan)
      let patient = null;
      if (patientId && typeof patientId === 'string' && patientId !== 'none') {
        const [foundPatient] = await db.select().from(servicePatients).where(eq(servicePatients.id, patientId));
        if (!foundPatient) {
          return res.status(404).json({ error: "Patient not found" });
        }
        patient = foundPatient;
      }

      // Handle dynamic consent forms that are generated on the fly (not from PDF files)
      if (template.pdfPath.startsWith('/consents/dynamic/')) {
        // Generate dynamic consent form as HTML for print
        const consentType = template.pdfPath.split('/').pop();
        
        // Hospital logo as base64 for embedding in HTML
        const hospitalLogoBase64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABLAAAAGMCAIAAABFw8zpAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAEs2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4KPHg6eG1wbWV0YSB4bWxuczp4PSdhZG9iZTpuczptZXRhLyc+CjxyZGY6UkRGIHhtbG5zOnJkZj0naHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyc+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4bWxuczpBdHRyaWI9J2h0dHA6Ly9ucy5hdHRyaWJ1dGlvbi5jb20vYWRzLzEuMC8nPgogIDxBdHRyaWI6QWRzPgogICA8cmRmOlNlcT4KICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0nUmVzb3VyY2UnPgogICAgIDxBdHRyaWI6Q3JlYXRlZD4yMDI1LTEyLTEwPC9BdHRyaWI6Q3JlYXRlZD4KICAgICA8QXR0cmliOkV4dElkPjJmMDM5ZjI2LTRkMjktNDA3ZS05Y2QyLWQyNTQ3N2Y4ODEyMzwvQXR0cmliOkV4dElkPgogICAgIDxBdHRyaWI6RmJJZD41MjUyNjU5MTQxNzk1ODA8L0F0dHJpYjpGYklkPgogICAgIDxBdHRyaWI6VG91Y2hUeXBlPjI8L0F0dHJpYjpUb3VjaFR5cGU+CiAgICA8L3JkZjpsaT4KICAgPC9yZGY6U2VxPgogIDwvQXR0cmliOkFkcz4KIDwvcmRmOkRlc2NyaXB0aW9uPgoKIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PScnCiAgeG1sbnM6ZGM9J2h0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvJz4KICA8ZGM6dGl0bGU+CiAgIDxyZGY6QWx0PgogICAgPHJkZjpsaSB4bWw6bGFuZz0neC1kZWZhdWx0Jz5VbnRpdGxlZCBkZXNpZ24gLSAxPC9yZGY6bGk+CiAgIDwvcmRmOkFsdD4KICA8L2RjOnRpdGxlPgogPC9yZGY6RGVzY3JpcHRpb24+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4bWxuczpwZGY9J2h0dHA6Ly9ucy5hZG9iZS5jb20vcGRmLzEuMy8nPgogIDxwZGY6QXV0aG9yPlByYXRpayBCaW5nZXdhcjwvcGRmOkF1dGhvcj4KIDwvcmRmOkRlc2NyaXB0aW9uPgoKIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PScnCiAgeG1sbnM6eG1wPSdodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvJz4KICA8eG1wOkNyZWF0b3JUb29sPkNhbnZhIGRvYz1EQUc3RllZNzZ0TSB1c2VyPVVBQzh2OFlaamVJIGJyYW5kPUJBQzh2M2hyeHVNIHRlbXBsYXRlPTwveG1wOkNyZWF0b3JUb29sPgogPC9yZGY6RGVzY3JpcHRpb24+CjwvcmRmOlJERj4KPC94OnhtcG1ldGE+Cjw/eHBhY2tldCBlbmQ9J3InPz5PbvWhAAAgAElEQVR4nOy9B5ycZbk+/P993/+TkmRbenbemdkNRSC90o8Hjx4VFTHUlM2WFPTQU7Znd2fmnd1N2WxJQgkIqMgRQY7lKIoKKiJFQERERVA6SSC97zzP/T33c9/P80706LGACex9/d7Mb3bm7S3vNdd9X9f/AYFAIBAIBAKBQCAQDEj8n8O9AgKBQCAQCAQCgUAgODwQQigQCAQCgUAgEAgEAxRCCAUCgUAgEAgEAoFggEIIoUAgEAgEAoFAIBAMUAghFAgEAoFAIBAIBIIBCiGEAoFAIBAIBAKBQDBAIYRQIBAIBAKBQCAQCAYohBAKBAKBQCAQCAQCwQCFEEKBQCAQCAQCgUAgGKAQQigQCAQCgUAgEAgEAxRCCAUCgUAgEAgEAoFggEIIoUAgEAgEAoFAIBAMUAghFAgEAoFAIBAIBIIBCiGEAoFAIBAIBAKBQDBAIYRQIBAIBAKBQCAQCAYohBAKBAKBQCAQCAQCwQCFEEKBQCAQCAQCgUAgGKAQQigQCAQCgUAgEAgEAxRCCAUCgUAgEAgEAoFggEIIoUAgEAgEAoFAIBAMUAghFAgEAoFAIBAIBIIBCiGEAoFAIBAIBAKBQDBAIYRQIBAIBAKBQCAQCAYohBAKBAKBQCAQCAQCwQCFEEKBQCAQCAQCgUAgGKAQQigQCAQCgUAgEAgEAxRCCAUCgUAgEAgEAoFggEIIoUAgEAgEAoFAIBAMUAghFAgEAoFAIBAIBIIBCiGEAoFAIBAIBAKBQDBAIYRQIBAIBAKBQCAQCAYohBAKBAKBQCAQCAQCwQCFEEKBQCAQCAQCgUAgGKAQQig4IqG1+Qda2SEHql/nDoIZVD++5vbr/n2QOwD9+/TBPXBwD74e2K1pwE/24oDj7NdmNJrQzETlcODZKlyEQCAQCAQCgUAwgCGEUHC4YPmeMmTvIFE7w+hg/0477IC9W2H3Ztj5ut7+sn7rBf3m83rLb/Ubv9Kbfw2bntGvPK5f+Rm89pR++VH9wg/17+7XLzygn7tP//a7+rnv6+cf0H94UP/+Qf2Hh/SrT8Ibz8AmnBBnsvVF2PGa3vmGmTPOf89W2Lsd9u3Q+8xCd+EKGDLZvx/XxxBIQ0S1MEaBQCAQCAQCwXsZQggF/0xoy7L6UdPbt03veFlv+qV+7rvqsZvU91r0ndV640fUhrNhw2nQPRlWnQTZMmiLQfNoaB2pm0dC03BoxkHjMAIahkF9CdQVw9IiWF4AdQV6WQEsK4Ja81oIywuh2YxQDA0l0FiCY9YPg4YR0DgCmkfqptG6Ja5Sx6uOCarrtP7ec3IbP5H7YkXuq1fnvt+Re/x2/fsf67ee14adGnIotFAgEAgEAoFA8B6FEELB2w2VQxJlKN+uN/Rrj+d+eZd6oFPfc7m+7QJ987mw8aPQdyZ0T4FVE6DjFJ19P2SOg1Rct46EFcOhoRDqBkPdIFh+LCw9BgfzpvYYHOoLodZ8NcQQP6grtEMR1A+FhsHQMATqh+CE+GreF+DI5rV2iJ3kWKgfBPWDYfkxsOxonOeSo+Hao+Cao2CJ+WSQNsOSwfraAr2kRNeO0M2jdWsc0sdD9hRYORXWnAY3fhxuuUDfPkff/Rl9b7P+6Q3qN/eqTb/Se7agsImlpwKBQCAQCAQCwbsSQggFfy+0lfsM8dvxin7+fnhovfqvJfr2Srh9Ntx+Cdw6CzZ+HHrP1qsmQ+o4aB4FjcXQUIQsbvlgJHiGmy07Ft+bwZC3FUMhPQpSY1Sb4WNjAF9HQ6oUh3RMZ8boTKDTAb7SGxxikIlBOAYypTptRjMDvocwZv8co1IxsKPhmOZ9Wym0jlGt5nWUTo2xs43Zudn5GBLYGkDLKNQVm6yoaNaWWGVdMSwvgbrhurlUp8ZC+zi9eqbu+QCs+yhc/0m46UK4vQq+sVT9pE//7vuw7UW9fyc2LkqDokAgEAgEAoHgiIcQQsFfDdUPhuq89Tv13PfUI9er+9r0N2vhq1fqL1XCxo/BqomqpRRLNOsLobEAGgqYVjWW6KZhqP61jtQ4DNdtIyA1AtpG6tQopHA0hIFuT0BHme4oN6/QkYSOhG5PQnsZtJdrHJI6m6BXaMdB21cc03yIg/2kI6nNhPZDlS3TWZpDEsybMAFmDviGxjdjlun2MnxdWaY7x8LKsdBZhuOECV5K1pDJMZAabTgktIzRLaOhbZR9PwqahiK5RT2zABqHIkHtmqg3fhTM3rj7Srhnmf7vZvjBav3El+CVx/W+7bj3BAKBQCAQCASCIwxCCAV/Hgf3ws7X9MuPwS/vgUdvhp/0wvfb9T1XqZvPy60ep9pG6cZiTRpawxDdVKRXDFUtI3QLkj3keIZZGWrXmTRcyw7H65XHwUrzZwI6LfczNGxlOXIww+Wyccvx4panmSFuCCGxPuSB2TIVxs04OqQhBtkAwrgleDiteVXZuBnc5MwANY5jh+hNDAkhzcd+rsMA2uNuBcxQZpik6hirOo8zK6wNS1yFb2CVWX+zFWX4aj7vKLOMcYzOjALDbFuHQWsxNBdh1WtjEdQXQdNwnS7TPafBHZX6vgz8ZAM8/nn9i7vhxYdg+8vQv1dqTQUCgUAgEAgEhx1CCAUOKoc2mztfg9d/oX/3A/3re/UTt8P9K/Ud8/XaaaiSNRVgk17tIL18EAuAK4ajYpYu1eEY1R5XHQmFfKkMiOmtLFed5XqVeWMJIbLBseYrZnod5ajddZB8x7xOhYHKmiGBH6IYaEhagCwO5b44CXeGGSrH5YBYImp69tUKgKgBIvdLQCauMwmdsaPhq+GBCTD0D195fBwttIMdAW1ssigb5gwnbC9X7WPBbAJqjLSqZqqAhUqzhoZ2rsQN1KvMBpoVjuHaYtnqaGgz/HAorChBflg7CBsdW0dAezmsnaa/cCl8Pwtm3z7zTXj+Af36L2D3FgzGEOsagUAgEAgEAsE/HUIIBza0QiPN7S/B5mfhpUfgmW/oB7r0F2erlSf1t45Bs5al74NlR0HtsVb4KobmEaiGGQaIfXckshkSiIKebjccrJRIEbKmdpb4UADsKDf0D2syO8tRMGQl0JAxS/ms7oc0DyU+1yWIg2FxMQhLgTr9MrhE5nihoYU0DvYHogxouCJyP6R2+EkmnkOCF+h0XNn1RPaI0wbKzsRT0Ig6pi3TC6kq1VDHpGo3nBCLTs26EWt13NVS02gmtrTVbGw2QEJIW212Ag5WqMyUYnukGVqGoReOodNmf9YNQrvUVRMO3j5bP3IT/P5BeO0p2PRrve1FvW8bRnEIBAKBQCAQCATvPIQQDkBoDHk/uEfv3QbbX9HPfl3dVaFWnwBNQ2DJ/4Wr/l+46v/qJUehvWfdEGguhrbhKA+GtqKSOutC1tyQECJbQ4Jk2VpgdTbHvizTgwzJd4byWboVxnPo8hIodIix3Cwd16kAB/zEzAfnj+QwTbKeHcfMJB2AHchUBqcy76nyk9gjfmImL4M0MsNcSDSvlL5VbgRaNNCfliICzTAVxwnTNLcAhUS7RfhVaEidbUHM2M1Eo5qEXZatSs3Qetpvzcx58jKdSdrBbLIVLc0I6G1TCq2jMTyjvohNUJcfBfXHYtdl8zC98hR1R4V64vN6y2/B0MKDe1C2FQgEAoFAIBAI3jEIIRxg0Ar2bFG/+U7univV6snQPAauLYQrjtGXHwXXHo2SYMtw3TZKt5VyaWWmXIdlChWzhKbSytDVaiJzS2I7nxXoLHMLHC0MSIWzc0hG7CtMqEyCbD+ZENKs+HNiXAk/svaSYBplOvM5fkuMy0yeihHnVG6hlkMa3kVTxXm5PAT+DRFCXpYVEnE10m6gRWeZAeJCw4D2BomTdjSzUUj5nPDI9JjWlvVG2hDDMw0tzJZZukh010xVhrvFfNU2BtpGmH0OzUOx/7BxEIZk1BXpptL+zsn9dy/ULz+CtFAgEAgEAoFAIHhnIIRwYKB/v37xYfXd1tzN56mumRCepJtHYTrfsmOgthAT3ltG6tQYLLBMW2uWkF6T2tCerG2is+wO6RPqb0lHArHsU+FoSevyEmB+Q8byK+RaSdYAM4FnjCjWkUCXsfPHaRP+T0/StKOFjmJZJhYJdDQC15HyyJFwh4PyAiBJiLhphnbiK7E+sGuikEkS80xYPTBGFadMLNNOwEw7lmu2lHld4DRGZqq8f5DcWinSrRUQvcwkHMO0e4Y1VTsfux9U1nxeqltHwIpiaCzUDUXQMBzCcXrNmepzF8FD18OW34pVqUAgEAgEAoHg7YUQwvcuVA49Qp/+qrrnKn3LxdB3tg7H6sYSTfHuTcXQNkxnDA/Eokrr5oJSGyp1SFHilp84nkOuLZZWEZXydaFW3+PaSGrSi3Q/rvkMXFmpr+10iYKGBeXROdtuRwIdFXkathbTTMPi7Pvi1D8SGG3SIJeDqkgMRDKm0rQ5VJjqZsLkjVbbLshFGuL7VIwrSElsTBGVjVlC6Lbarr8tWLXSn6WmKk00j6pYEyrlKCuR29BxVOKKVERq95hCG5sE7up2bLNUWUsL0eomjuY0zcOhsVjXFui6YZA5GXr/DW6dA99aoX//IBzYKSalAoFAIBAIBIJ/HEII33Po369ff1o/eiv8d6P+YrXuPls1jsZeNfS6LNDNxbplmM0ALNXZmO5g7kc8RIcseSGPCh2ZCROuU85135HFC1VahiyRkR7IDXVel6PyS1drqh1LzKUD5m/ECYlfsWjGE/oeQiZ7tFC3AiodJdRboS+PECJP8597ykfqH3FRR2utJIj8jTTMNG8mTsttjaVWMEy4alW7MoaFGi6XsmyZ+xITefWoiVwbUda4ypMQNbdQsvmNItZKyRmWGVonG7vDs2Rqav/MmBUYrVtHGCaPWm5tCbSU6Rs/CXdfob/Tpn/5Vb31D9JnKBAIBAKBQCD4uyGE8D0BncPo85cegye+pH+4Vt2xQK+cDPUlsHQQ1BZB43DdPBRaRkBqNBE5TRadZAdKKQ6OtrF+RTQMmWHSWqoQpYl7KqUPke8SlgEmI48W5JPW+RMH67RJbIcIlf3W+ceUkdMMky7PSFGFowpSZFw5NqHBek7rKxOnRSjLDBUyvbxGwYydMEWfxIjdEeuzJa8BO9nwDP1XVM/pSGYqsGokuZjm1bVSEakngbj5ZU7k5MFyRcdySRu0pap2tZPkRsN+M1b5ZCtU0h5dO6Jm2TCpzNBZhsmKhoG3jYHGYdA4FOqH6NbR+voP6m8sg4dugGe/BTtfN6fB4T4RBQKBQCAQCATvMgghfDdDa713m379afj1vfrhjfqOCmg/HlPRlw/Sy4bohhJoG4W6U3s58jEf8o48KoZcyEb8eZqn8wcrCVIFacTfULxKaCfZkUbHzYTmDSpd1Ghn9T2areWB2H9ItjQ0z9BxKks+ge1ALS9yZZzWUNTVYXKzn9UYkRDGPOdULLgFzqoUyzuBGh3baClWtUvFrLZpHW4s6cJPnA1MnpsoCYyWfLLBDFWTJhVT0zjbzGAjYhJcN6DyRjhp7jy05ay0Y5PcMZhO5PVMUtdl0hnnBJ5AolqYsXkYZpL2sdBRrtqTGNrRYaMdVx0H5rWzHEMsWodht2FTkW4dpdefre9fBU9/DeMrdrwKuQOH+9QUCAQCgUAgELw7IITwXQit4eA+vfVFeO1p/eQd+j+rIByLbYENR2NdaMswjHboKLOyUhmWg2ZiyNbaEyobw6C/LPEuzu4j+gRc7miJYuhkN5IKbUuhV89IrLMD0yEru8XyiSXXoIZe+PKVqMh2FPNJV1Tpxb3Q+tNw3oObkIs8ORAisjB1NaK26ZHWgXU/8OWmXLcZTYVcLhUjldKSyWSeuWjALYIhNfslta9fDb18R5SSZMaAOxtDJw+SDJiyMYle6GODmaTy9bS8MxNcK2vrTr0PDTUZWtpsDlmZai9Xhg0aSt+exKGjzEY7lsPqMlhjyGEZ5jS2DoWGQXjo60qgZ4a+f41+/sew5Xd695uiGQoEAoFAIBAI/jKEEL6roHKGCsLerfDiQ7kvzFYtMVhyDCwdDHVDoWkUpMbkDIXoKLNiIJeDWh5INi0xDHPPunjArHOLYeplayNRZ0NKo9psc10mcO1zUced/TxG9aJeRgNKjffimGVEjvkEUQxDaPVG18unSAnkCZ33jC86zS+htJO4bImoLdCw1oPpmBuHVhUnzKXI04V9RDkbEKct5Sx7qyXqFDrH+GJRiGaLtbKkCsIhq8SJhZo2P6K7fjcGVDKqmWPHSPy0nwR51ae8V5XNSzTrgLSWSk/JdQbTPhIKCWGZTbenMMMyPF7ZJBJCfBPAyqReWa47y6DDEN2R2GS45H1wzdFqWVH/2rNyP+yBt34PB3ZLk6FAIBAIBAKB4M9BCOG7B1rBlt/q76ZV9xQ0olw+SF99FCw7FppLDBWEEAspVei8T9gR1OXFk9Wn7dazhZHIeWx4usv6S5Hohwl7lOigUjFXXMqcTfkWO3aLIZmRCaFPicBPsi4VMJ1kJkmszNqH9qfzpT+ifKSMESekQlbqu3P1n9Q9GJJXDep+OTaV8SkRxFcpm56W6BILafPDgAltJpZLx1yFpyWEVHeaorpTZ2Sa5nZBpzoG0b4KHUW0xa7KJxzi+1Jf+WlLT2P5+YdclUoOPZZvK26b9GKjjzd07YUkNkYtl3Yl2frV9hnSa5jkA9E2Gs+HusFoI9RQAuHx8MVL4M0XJK9CIBAIBAKBQPA/QgjhuwB6/079zD3qzipYOxVaYrCswBaIYvMYUg5kBWUUpG57z+JU9ulcQzFGIsfJB0mykFEc65eMeBGLeCRVOfcXx8qoaZAdX1K2Wy9DQe1JW+gYuKC/wHGbuCV1FFFoe/9cESnKd1QSmeFiVEs7bSkp9hYGkTOnKzEFKhZNObXQr57V3Li0lf1jiIImqVkxx3TReaKyphdDrhuFGSYOtZOJU0GsJ89Ww0xoxzZdzWfS5dfbglVig8xsE4qiOA4pJaViUbS68WxTufJUazDDW6fI48e2U4J1zeFCVpw8Cc69RnGfZ5KOr7JSMBamYqGpJeFtpdA6Eslh4zDIngLrPgSP3w673sB6Y4FAIBAIBAKBwEEI4REMrWD3ZvWTPv2fFXrtVN00DOqOhaYSvWKkbhuFgQShYxRZsmaJOVpCdZJ5UXhpRx6obpN8UIhgWHFMZ3y2BJnEJMEpVGxzQg14bCET9319Ub9f6JIqeBHWUZN4Ef6JXEU5+sdJEmGcmWHGcTPiabxctrfhqImUH43pay7jggS9dme9XsjMRqUj51Jb0Wq7HNO+8tN3Ntp2Po61SLjGxTiHyId214WJqBswZQMnUgnnGpqIOGrociawCdNFDvK3Sa/7eYdSJoSOHke7gki7TSN0tj1uVTPeDJZbFu2CEo6+JnGSbBlky4GtVmPmbIGGYr2sADomwk2f1N8L1UuPSRGpQCAQCAQCgYAghPAIhIZ9O/TLj+j72+GrC/XqcWgcWjcYGksMD1Qk/WVZW/NUxFqbxFzjX8AGJ3lqG7AZppOwOA0v7utLXeElcw9Ob3dKndW7EswSXWmopSuuNy+MRfWNJAlaSpaz2RWeGbLTDJnT2BrXqBMvlafOZfKSCakzMGTTUe/OoogFZaLSU4g6+vKoXbRDbH9ghuMQwTcBZniVeMIojRCVQJW23JK3OqFdWSnRSO9ek1cp6iRBr7tSZyZ9G8U20l7FPeP8dRL5nDDHUqQ7LlTImmErGvDbmImC7y2DDSwtLGNHU+uPiqWqLYYWFkFToe48Ud1yvv52s/r5nXBwD55sAoFAIBAIBIIBDCGERxh2b9G//Tbc16zNU3ureYgfbNPkhwPmyCfRc9JajCibZg7M65LWG8bRGE7bszkH6YjjYf2h5TzKBST4UkZHlnyJI3ls8jxdZWMetyQ26AeU72Ke70He55Z8kjjJiQtew/RFqs6ZhkxWAuqsowpJoqD2faDCwHO8Q9mXsw9N+xlaYTDr19a2R6byJEEmhPFIRw0TfobA204VpKSOUnGsS6fgItKoFjQqQPUlnSnfOogHAlIJzdWwviLXiXt5U3nF0s+fOWHab7u3eI27nRMJnsDEmAkhbwgelDKUDSnmvnW4oYXQMkJ1zdTfqNc/3ajffF7nDh7u814gEAgEAoFAcHgghPCIwd639O++rx9YpW/+KObL1Q7RDUW6ZRQ+x7djgIT1Dk3qrA++85yNGYVzH4kzeyFTGVdtaHlFzIlXgVecWChzieqata8kMRbNyQ2ObYY2x4/5nqsmNR+mAu+fyZ4ufpxsglfYdgNCtJLBITKX46XE0MBXn3ItJTrB5Mi6xlE7V5/pClAdIaTZEpXyhE05TxdwX7k524bA0BqBciehM+Yx71MBBUJQBab7FkfI+aVzSScH0B/KWhNuSGrH4vK3l6pMXV4ip9hzQiMRP+4t5GOk0i4Yw43jLFvtsUvZYIw0p96Dbae0XjVlQLSwYyzalqL3zChdj3mVqv0E/Y1a/cSX9GtP6/59h/saEAgEAoFAIBD8syGE8HBDK9i7DV55DB6/RV//L3pFIdQdq+uKsftr5XF69Vi9yjzHG06IcREcZU6FlFxwyLkOQJWWGCbBAhe7bnI8ILWfxW3SoIuR4JzAGMt0Gdc4l0F2ZB0yHTkh8xicWxlEOptLUAgdU+Kcd87TI5qkyA8zTEC+DmaLMG3SfVJxHIUvmExEPYQhUyYe8uiW76MjzZPNbzgz0JFP6zETaaTZhOuBTLiIwrgrSeU+SfCWLWkre9p8RaAkeg6U59GQgNHcbIAHbV3O1dZaRpoknVZ5xTX03ZhBXkVuIjI1zST8kXJlscwG3fi0XeYAJfgou+MLfLDMkUoy/abURKwgTbKYbM6fzrGq8zjdcbzuKIfW4dA4BGqPUW0xfddn4TffhTefk1B7gUAgEAgEggEFIYSHD4YKHtij33xePXmH7hoHLUW6abB5hXAkMsCVZbozCZ1lmDXXkbT58uTyYvPxXDsfeHZBepf3fSEigfYklBaYpJg7r4zlxaDHc+m4jpxLAqqoxHbErPNTCXGcHJmLpimjgpkbVWYq149nnU7RXBQoCCF0AiZZodBAAYA8VeBYaGDXwebFW51QEYXLUsMht9jlZWmw1GkT7Yk4xV2LoyVdKV4ikSUgKS/lMw8Dxaw18LPCNynyg/FSZ5zrb83ec+pczqt/Idff0j5hluiOC+pymGJPfDXBO5/MYNPO5oeqRn3SIzdhek+dhEs7DDz3c6Q66Wx4bIkpsWtSEfFAl7MtEHHFbJKdaTrKYNXxsPJ4sJwQVh6HMfdtw5AW1hfqzFi4swZe/pnevVlcZwQCgUAgEAgGCIQQHjbofdvVL+7qz46F5e+DpkG6uUSFo7Whf6sMCYxj1HhnOZgn+PYylzXH7XmKKh6zXPqIeQxUiJhyA7MFG8HHVYWxHLuw2MxA26enXIGlSiVVmtidZyBUdpjMZZJsCmqYUipwqXpYwEkVqsBuLgEmFrbF2CMUuxyJ2CS5QS4MfPAD28lkYp6Gac6yN9zJmuJYz082mMGvgpwZsi4EghLkyZSFgiWYZ8YhHXVR5lnLBKSmqgxN7sizbWskcdVtXQKcQSvnNxItZBrpxE/igSkXfZHxbYRWkUu5ZI4ox8JssiWZlFeRtpTYzcF8lUsluA6WciZoA3mVSKvE1A1N60meqHYEUgWtnGu+LYV0Kem9FFABrsuRmaE5uO1lSAJXnwCrToQOwwnLUSc0FLEjidGRbaVQO0w1jMh9abbe+qJEFwoEAoFAIBAMBAghPAzQe7flHlyf6zsDRaTaY6CxENpGUnUiFvVZWQy5UzbIK4ykOkCiVTEXRUCUL+7MY6wQ5ERCriRE1YtYk/Vlccn1ikLeSWJy/X4qZclJxn2ecbkUnE7h3E042S/uNSjbI5fgfjaW3Wxue+gVLdcIl2GLUWwIDF09KvHGPN8X7iT0vXxMz9i+xXIqypSPDGw4dsJyPG82k7eS5O9iuVaba2XEHU5diAly3KGGPdq9ENHCvHpa7sAMiEJH3YBpV3ZLwh3V1nrS6BoFXZcgHSOitUEu2vB4RIN9ZS8LoXY+IUVNJJ3ZqTsBbImvct424OIfcf+nXI8o67Rs9mObUVHIpa5Uc+xsqP1QqB+ia4ugpQzuqICXHxNaKBAIBAKBQPDehhDCfy5Uv/r5nfr2ebrjZFgxAlYM020jUVujlLx2ekx3rW5Eq1I+EyLhaCHXHzJbSLn6zzDp0xe8XwtzGCZXPtQuYL2Rk9YtMXC6mbKlj5z+50MIfbceVU5y4LvzX2ETTu/VyV2OKrS9bdwfSIkXKB4qH62e9bmIfiWTKm9ZVljDxjkVMS7HwVBYS+KGeJNVqqXkjkRyprGUibho6Kw+U7aIlNsmiRyWUTWsy1SkhSbyyR4HOVCJZtr5mlodlZsYKYcwS62VScfiqMSUQj4SOur0S0SVt5n81wQFYCjuJAws04tFRqMpW85qfWXArYlLy0hyxWzonEvdrwlsO4QaY8wVrBL19YTfUl9zyqVLITUamoqgeSR0naa/k9KvPS1x9gKBQCAQCATvVQgh/Gchd0C/9Ah8Y7nuPR2ahkFjMRX4sSGnfRa3alW+NUvAVYuHECFvG5OXuZd2ZiTRmFYro3Y112BGghLzhJBa45KOTvh6S45N57QGYnFEeKik09OMMOKlrO9FZJVWiahdPOqLCxN5FjIBr5hrUyRuCeSUw8Y2rjMwTWWcjgZb31Hu7osyFfND7Z2zC69nZMHKo7lSVc4bRF0x8GIgW5hSMkTKGefwobFyaMofC2ov5N4/HJ/UOVx6oNjmlOIfXSehTwRJRUuxdjVOJMzj/HmBE3E2jLF2MpB19jaeBmdcgmLo6n7TvqExCS7aUeV5n3LLpSfGdPpl6SjE8AeLukLInqQ/N0v9qBd2bzrcl5BAIBAIBAKB4O2HEMJ3HDrXj5ejZBcAACAASURBVFFvP1yrP38xNI2EhkJoLtGp0TZGgmVAm+UQcP9b6HxKfPmiowqOKwaUoedb1Lg+MI83Ej/JS4CgAtEg4m+htyQ5tDTRCkoQkROev+Lc9rg+5CuficfyneeTToYKmBf5TXAdg+wEk2cfCmkXGW9b4FQUJuG3KOksbQIqgiUW51xb/LpZBpgKtG8XTEelmFEJa8gSnDWVCfL2Xl4Xoq1NhUMKUN0GRhuVcAkczirG0jOV38foXpWjmkQL85xX7b6iss8w7otRWbT0zD9D3Z5E9Ylzxrha2PY6csOkr851lbFRUkjkHJsvq0b5GVxsTAWlqVJoGobxJ6sm6K8v1U/cpvdtRzMkgUAgEAgEAsF7BUII32HseFU/+2399VrVEoPaY3R9kU6NsaWhlg5liQKRS0rMFXMGnIrOD/RU7ph0Kh/RNkqfpwZCn/Hg9LSMDY1g9hjLa/lzWQ6RzJjMr5wEVs8SLlE9yaws4ypI025BvA6BdR9NYCGiV9vIopN9OK3NqWNr+Q1yUaFjmk1KgTbWjeCInCN4tibTNdQxhWY26FbSBf0lbKFm4KpbA2f6wlooMyKrpCkX5WdT+2jX0e6KMu69Sun2Xpx7I13FrF9biBxc8+o/3er50tk8jc7z2MAxfO+Iw/TVp1NEZbTOOjXirmnrLeRMaCAT0T+XtUinFi/XUuj8Nkj2m8VzrD1JcRrWLbYMG1bbRsKKYdBQrFefrH/Uo//wEOzbcbivK4FAIBAIBALB2wMhhO8Ycvth07Pqh12q53RYdizUDobW4fiQ3VGOcQ5oHIpkCR/EUwG3b9FrGLj8AOtCiUQIgxx8Cp8rrXQdcWxfGWg2kiFZiVklE8JIYvKP/kkO1rOlg5wbQQaYZmhzXqPejJSZiS9T9A4xWEJpRc6E8jwkw9l9lBpv+/ri1tWGLDq5cpUrJ107Iq0JO6Bm7IannVIaqZTcvOdJrOKMxMCJjVwvys17XtzjnroktkdmXNYfK5CBK8iMMdv841JMJoRg1z8S6HjnO/qXdspeKu5D6pmJUf2qL9dMJfJiP9DIh0tzHbe0mxlT5AdjfyBw6Y52/bNE0RO062xdq9uKSNIk9TVJXkEsL2fdzrGH3gZsuIAQ2kXoMUN6oxVprQKJVredY6FtDNQNhmWD9OcvgKfuhG0vgTp4uK8xgUAgEAgEAsE/CiGE7wz2bkWHxi9cBHUFsPxY3TYcOst1p2GD+DRvs8ITkMWmQWA6FOOsOYqbs/l+zDR8ix27XNI4NkCCFEJvNxqVlZLFS+BEwjj2udnZKs/o2E0kIE8UbiczE6ZcDkQmGtkzQEUxeimnlXE5a9I171nbFd+ySCTKjMxtdXYFsuxfws1yzKasUue0xKhS1LI1qyu6JslUpGGyhyqXvwZOmXT1nKkka6fpGMubqRi27fmi2bRzUnFCKziF03Xf5fma5hXuRsImu/UETg51tjG866L6TDa58T17fpzQebry0YmzoU6KD2jOBn7YhAneYyrtAy0SeXJrkFcLGpX1ev8Y3lehW7EwzsfaZlS6nlV72vjGzgzHkEB7ElYfD2tPgjUnolRYOwjaAvh2M7zxDBzYfbivNIFAIBAIBALBPwQhhO8I9LfrDAeD5UdDc5HOxnRnAhPAkRCW22CJckufrKtKmnoCY2agBDwn8gQuJ8AWXmYpY93WjpJrCz7Tl1IEBfXjRcH0rvjQeU7ab7Nx52AZRAohG13atjcfY+iFLKdZeUsY8EunVSUqSGwKjTqt3JemiL9EnuWptfEk4xZkWWWkQeEcUCwt0xTgblir2TO+CTBN/IdrSs0m5MJ4FE3BG0j1ognaWKJb1gsnrtsol6Isb6sDrorkYksibIHPNlQu1VDZrA6VKnU5HwmWCtldJuETLJzBqa2ezSRy3keUzGYyCTY1zSZVlviVK/7EXVTmOjOt2JuJOVrLOfJUmMphkraWmAgqWvuEVjf2QSDRIbM+tKgnJ/I7MDVnRfKuw53Wxm6rytW12m0kITFJP0mgjk17oDMJq8r1GkML3w/t5eg3s2wwrD0DnvzS4b7UBAKBQCAQCAT/EIQQvp3QuYN682/09R+C+hFQPxTt+zFfvky3IxXEiPl2in0rsxpa4OLaE5YNlnIFaTQElBboaZWrKU1ylh3zN0ompAx6bjnjkIbQ1Y6G+d6k3KUGNl4CF5p2DX4p4gneiNLTuYBbGTP5GhTxohgv1zuUkLFKNum610j/ZGrBiw5J5Ew4G1LL93A9y1hsdOkOHMhOfY+unJKzFlIBe8akuNyUdgtKaiHuHMX8yheF+m7AuG8+tAnvtMkxJoRec8twUjwv0Zfm8mbGc2nnI0qbz+pfZO0DHD+YoIBEV+/qwgxTZAOTYHHSe8BkuaXQLjqBo7VhES/tCnt8Y54KRr8gpPN0wqhJ0nWBuiBE18xpFu0rV8lv1te+uobV0FXnmqPWntAry8AMq8bCyuM0VpCOhvoS1XZ87sv/ofdul1wKgUAgEAgEgncphBC+fdi9CZ68HdafBfWDoH4ItI7UYQzauV1QZzGQgJQ95bMZMuz/yV18Yb7LSJIogaIEc/KfPMQ8xjFA24aHJKTN1XCGLgIhxR2Avo/OETxuUFQkixFVCy1tI56Q8dzGl7PGmV2kyKwlwR4z1N6WiufxrrxCU8eLeOU9U+KUeVe/yuTHudq4+kzFxZzOwcXTLWI4qTivasY3XlpFkdMdKFHDt2UGUUyi94mhBXGVaaRnEvGzXCjBq8EiYdwmhXgXluBQ5hxwhCB55xBhi4o2uffPW+C48lfSVz3fpgLamJM0XYCk9xkKubcwanRM8W5xJawJiOhfQrEpq7M29RsYupnnF+i6mJOoVTVN2R5W88zSUGbYPs6kZZSuK9aNo+Dmj8OzX4f9Ow/3FSgQCAQCgUAg+JshhPBtwmtPwb0rdNc0ZINNxZAphWxg+wBdaIHlgVaHibvKQ3oKj7EG6GIhuGwvzQ1dTJlSPmQv7hMLvKkmaz4Z26GX5i5EJgBhwkcpgPNH4dZE7+GZjnPchfNZcXJfXs1niuhWfkZC4BmayieEPDl1uBHTI+5hs9qxMJIcOwPnfMONgqidWo3OSVU+/iHOvW2Uh4GtgDGihbawM2KbUf9hhp1sSE/j9MVIe4xzWx3rkFz4qjK+g44TJgB7JpNe+WRCRcTeZwxm3B4O83YdHSlm3U7YDCM/T1f16lMH88s7g2hPklIXOq2SOJ6vJWaWSMwz37k0iMg5k1Xae0kWJ2kz024+zgTVOdn6MAyncGYiDZa1RBqzbTQ0DTUnvO47Xd/bDFueO9zXoUAgEAgEAoHgb4MQwn8YuQPq2Xv1lxdCOBZqj4GW4Rjq3ZHEIZvvzEnR6vEoip0ZQuAcVuJR6oCbyg8QlR1ypR86XlL7XF70n+LHfTeVKzf1IqH2KpntNMuRsWQmHn3IulDCT07cycpQbE9iFxp4lmVJWiIak2eVdK2GtuCTYzPYK0X5+kyfZpHxwYnWFMc15uWRQ64a5eY9ZlA4h5yrL3V7gD5PHrLh/G3A1JqITcbRZmcZqkJP8OJRFWVE/JgvMZl0UiqLgWGe2sYHMSq+1X7/RIW1nELhHGiikk7tGWye0OomTHIQCFUdWyKqom+jBeXpsQl/RJybqB1SbiUzjmfyWZcAv9Vs9Mq7xZcua2bL1uandSQ0DEGefM9V8OLD5oo43NekQCAQCAQCgeCvhRDCfwh633b99H+pjeeqxmJoKIDWEWjI0R6ADZ1XYR7BS8dUPqs5tH6S6ESkboURN3M1n+4TGs3zioyvEvT1h2ygotIxX0jp+ZXKKywk6xFfnKmcpqTIgtJXfjqly3t7qnS+iuU0pWhBTv6KNEO/AjFgShmzxIwVQnCh9sw2XUAfe11GARt+j7kKT54wickKnhDa5eZsZ6BKR2Pa9kJUF9k4NJ8vpdmn1DUEOhrGVbWODoW+bJXzOVyvXeCPlxf3lOswJDqtieimE5Gax/wzzyiVmjnzfgtwpaeHcH7lHINccGV+5W2pbYNM6PwdFa1e1CgIIcdj+J5SRVY39tDjOZmKs++osx51krWztOXGVGqLLdWNBdA8DL40Tz/zTb3zjcN9aQoEAoFAIBAI/ioIIfx7ofr1jlfUk3fqrunQMBhaSqwdSDIa2pMseXkfSEoRSPtH/4hf+T/JKMV3dkHaiWNhXvEnPsoHrlSS9UDiBo5z+lzBqF7R1TEykwQuCGTK6oLp3SRWivRKILG1nHWdgXSUDJFHz7wa5j+PoW0mMZlUPOr0s/SJohTIxwXSbjWsVqlI6yMvGdot2UQkrLG6xT114HaXst2DbktxNXI2GhFcZ6B2/jEqHVFQUhod2/GfJ1yuQx6lpDpSLjTldkEblUHJgb661b6maLdHQfP5wiDX1nqh0snFXgemaEftYujzKkv5PFH8M0GCDzQlkaTizkYVt+iQFER/CmWckY9dE6TH5MHjRVqOrbf6rTd0jX4UoFiRvJ0WcnGsarcHpbkY6o7RvWeon1yvt/z2cF+iAoFAIBAIBIL/HUII/y6og/DWC7n70v0rYqp2MKRGoalme7kZwLJBzOvDgbmfK6SMMgaY7aQ5a85qNZ5AUvMY6YpkLZNQTvpT1h5Tp2KGnuX8n05hoxLEXJpJptPZAkqDcA4lRESTRBgU24Q63kJ8L0QaRpkN3qFEcY4fzTPpKETcVZMm8xxZ8oo8ybQmy9F2luTEXEteQJyEhT5kuaW5PCqiWLqMofdp2kt5dvyUs9XJ+KLZJEbqpROREOeooHLypm6LDFScLacjTpRKTzEe6Txhlhs7E0y8cXExH+zh2vZ4e/lgtSXIABZS3HZ4SN0p0d1U4Opm8SCCU0rtaEkmt7jCgXah82zkk3F5HmmO01C+hjYT/fTAXX9RgiL9oJBw7Z1ECEvxBwimpkRrE+S5astlk0w16bCmXctlyAmNJBKqbBlR9BzaIJXpFcNg+VHQMkp9uUrveB107nBfqwKBQCAQCASCvwQhhH8XNj2rbrsQrjkWWoZCejRyJ4qUwFQJK5swM+SeNBKRwCpm/EQeGtoWz6Vc3SPl4KUOda0Mk5g1x2YzzjskU5ozz/HpUm9Awln2GV9SGEAqjzW50PNcJq/TzCZecPJBVGVKlCPP7iUT0Sdto/kgFQNKsbMWptob3rDAZScMXSYhZwnGLHGN2eyKOMdL+G7JjA2Ot0amluhGVaZYQxsSfWJBUuUlN6BFCtdPsnRJzEr57rg0R1CwjkpyItFFZt0BV5BSDiTvh1LL0+JeayXOCVEDYcwSwhhwRW4ZG7T4xIs0pUGy4EnSXI62Dmk2fqVStMJx99NA4BxrLMGjlQ/LFJbCxkjVVEwFk9i4GAYQEVrqTU2A68Pk840DM9he1a2h24qMo80p2v9x7ctlQ+L2SXMQcZUok4Pnb38LyFL7ojnEZaghm81sL7OGQFYq7Cw3pyjUHqOXDTq4/gOw8w3Q6nBfrgKBQCAQCASCPwshhH8z9HM/UNd/EFaMMOQht+p41ZHUHWUKCaGhhVg1itJKe5JTyFFCSVBqvOUSeRSLdLxMjAUfpIgxRcohx6lbA8zQpreHHCdgm+4sg3Is0YVY4IN7PztP+kLBBJEoFZblbGgE22OyDSnl+MUoMJBSLiwBi2HqHbPEvFyH8JCQvUjtJO6UTWpXd+pD+VhqS5NP5iGrxMqbL5hMxV2RaoJHTge+dDZqcotaJa3xJstuZS5LkNfK8kC7T6jJjb5FQhuHDId/cPFqutRlLfjEwmgRimo1I+cVFi01Vc9Gxi00SRJVylQUsxGZhRKFdmEVikJEKAKRRwg4id63HdoxcynmyTRbiMInLTm0IiEGk2TzrWsCqgulk4qbPMM8fZU+x3GI9MaAvG3cCrgaXX/KWdbH7rg2PCO0taOWoCrbiaqwRrocVyNLkwfQPFzXj8itnalf+CEc3HO4r1qBQCAQCAQCwf8MIYR/C1S/euor/RvOyTWP0G0j1eqxufYy6ED/GBQDLdFCXYWC2sLEIcQpE7cKFYlIbCuaI3qQKlXsdBJQMLoNNiC2k7RamZ0zP6NbsSvP+wQch8mlEzliL2kKnbeBgZZi5cgkJmqKIwkLCYDrRktwEno6zkWe6XzuGrC/i0/8i6Lq7UxQtKQywsAVoAa+YpNpZOiyEJFO+FiLhPNETTgilHCFmjxDXgGrpClX7KrZrZRIV4I5rWePaV4T+pBj3FPWySblNyfuhNAEUzIX7ei0u5hzjgmcR+uhzX5EkLif0GZv5JG3iCpTQgbvYRsOSbplinsanatq1ETKDZl5vjJA69/mK3sD5zwU/b7gLIXcqRU6p5+Ur3F1raRcbRuAo4iuL5R0zijG0J/AtlEzoDNT5w1kQWQIITFDbvLMWovd1lLdMDy39szcz26HPVsO99UrEAgEAoFAIPgfIITwr8bBffqxW9T6s1VTkV5RgraKq8ptrx2XiXoXStevFXf2MJGPCzC3cSJbGPd2JtoVjnLrnZsWonJB3/kWvbHzpMf9yJjU1yI6Z5RDLDrZUJQSHVwfnZOkqH/Mln1yjWWciiqJZxJR9DWuHCMRehsYJzw6DsNmlfmT+M5DT358+Si5y6QC153o4tdZSg1csajzIM1QaoLjOa5TzmqqcU6id817diUd2UvFo4h2Xw5q1S0Xt+CsdHCJSfD9eF6Cc8QYWMlkuY9dapgD29BFS5v9EXeGLi4Jw5JDIOOf0Ld3Rq2A3hWGCCFbAZGpLJ0/3Aga5JE0X6Ucj4xqU+5wcCdknI+v96rxBq2urtidaT6Zg7aiLDp8/EuBpeJZ+o3AhY4Y3tiOv4zY8PpC3Xea/uFq2Cw2MwKBQCAQCARHHIQQ/nU4sFs9vFH1ngpNBbCiWGdGQzbQneS8Ys1gonB5aiFLeHPOvMf0Q5628xhj3LEmbz7Jlo+KFJtMPC/OLhFJYWnHNjPERuIuQS5KVuBqTO8hmSGdja1o1CFrks8KkkwYUs4+xNEAtkuJCF7gogu8C4vjcmQl2sZSmH2NuQjBfAfOOPuORjTMW5ty8oSLYk+yt0rI5bgQOtLoKiRRwgp9vnyCDw1/7pWuPw6uAD6IzjfFt+RlbCGo53gkPBIrdgImcBVoQB13fk+6byO3GIjy/ZwGGFF3r9HFwRmc2t8XgjwCFnMpjqzuOn+XgNs10xEhjLx23EHxJjQ8odMDuS405RpQM97pNBqANVuX95h30rLkSMWiUaaF5YQdY6GjHNtHG4uga7K+d4V+9anDfSULBAKBQCAQCA6BEML/BVorvX+X/tltavUEzfESpdgriFb7tneLCyBd81vUphUVQPrgB3byYG5AkQyW8rU5d5ZUwqt5URmke9wH7try4QF2DockSSQcsfQk0MfNodilOViPCEmgXOmmo2e2ajR0MQ8pFgmZm2Wcc0xElrhjMD+ZkAgnkqtUPMds0FXDchK991z10YgBOdMwi3PyoJcu7SYndbYsClHgIUaNglyg6xmga5NDa58wwUpsSF2ORCajLfLSnCavmjwLGeu6GWlodpVsTkab5UXoK8MCpmL+HO12cAatrL/Zo++0OG6GJHOXvJnHXT2w/Zx+Vgjzfkqg6lOz3KyVNG07ok1WjJM3qSa3GMoSZPLmZeqk5+q07bl0Ijoc1iXIpSbSaWmtZZx5bLRdTvGm9af0QnfgyLrWslbzZ0e57hzbv+r9eDY2FOmO96tvLNdv/OpwX9MCgUAgEAgEgghCCP8idE7v3qKfugupSP2x0DYM2mOaeKA1z9DtCeuxkV9rl7SOL0TwuIVPkX0L190lXcVjkp7Csf2vzZFAHL+MmEAk+6TzuuMy3IDnRELHfEKWpyJ7FSoUdMrhH1WcMiHklMLI0YTLGsk4NOX7FQOqGiUbUq8Z2tSEGK82NbkRYbOsSXEdacyFK5LPajwyhnHamsqrbnUGLV6TDJxLSmAb1dj/E9iPxxJC8rMJWejTHJrHfY+aAjyQNCaJpdtID8/Sk9Q/GVWoRjWfcS+dOWoasBjbRhpmDI++M4BhG57I39XrqFFDYJ4Y6wTVDPm1RNGR4I6OdxsiP54oPCN0x503wWnRjt05ZpgALlK1fZJZQ9Ki+lV7qkQBj05gzM+loJ2TdHY7Xg5NUhEp/dCAMSeuslenfcGwXb1smSHkqmOs6jwBj2xDEYTH6a8vha0viPWoQCAQCAQCwRECIYR/AdqwQfXEl1RzCdQeDa0lOhvTHQkwQ7s1esk6suEoAZEQtl3hxq24i6HHkIn8J35FFDHib9bnEykNpf9ZQpiK+0d2Yke22cwFFaS4EZEH+8iuUnk9dWnfVejaAp31CylImo1Agmh8SvBrc2JgGLgGwjxeZAkGp7FzmattlouoCHYeKk8R8VtHmahglWlJ4Cx2KIsvwU4nSH5KFXNFDLjntHqMvIvz+thBubJM75HjjgIGSDBRD71y6KQ/Sx0tOSQmzCqrnTzminXJGNYeo4xPGnS+OI4xOi7HbYd0aCDPG4aFX7tQH2Wh0AEosEEgCcqfJFdVpwPTVtiUwqgwNciryw0gb7tcqW30FYuldlWVOze8DxDvBx+TmGJjIUpx5DyMrF8frFt2qZgxR0rZU4claEP8KLDEl8UiDy+DsNwmUpSZKyVnaKHZJ/VDoK1Uf/0K2PYSqP7DfYELBAKBQCAQCIQQ/gUc2KV/fmd/g3mELYH0SN1u2KB1K8kSFaGMwUC5RHIdOrMQz8GY/MQsw0lo9vBwmkyKaji5VA8z6H39J7JE174VvXLsHkSR6463UJQCsUqbrWcDAy3tsSKe4kCLWI5qGlkic8/0bIDJGhGlO6gw5sQ6V+2Zoaj6JNit9pMoFhLJmsU24+EmoHWqYsUPpTzD0IiIImuyS8c/s9x+ptoTHEHBvp0xzSsZWO5dboacWbrhGFlDM8qVGawABWRomTUsPQntcTuQQ0ygbF2lyjiaSlWjJIKtLIPOMk0TWmPYfg5Yj3ERqeWWqs3uSbtKlE9oD58dx7ApVNicPaw7AbTdasxs9J2Ezo+HD0RboHyyYtSFyPW0LnIwiLx/Mq5d01ZyWsIZA6fEUokvJ0PQ4QtdESxvBW110rcvOkLoIgpZkCTRz5yNSZXKP9/ivgyYIxNTrgaVZWE/AgmMdCraNcQUTXvI7MrksslcuhTqB+vmwf23fRq2/uFwX+ECgUAgEAgEAiGEfwb64F79+O06e6JuKsbq0Pa46kwqbB0MLP0IUEKxD9zk5cj1hKHr1nMtdpYbBK7FK+6MPZ1IGLpuutDVN7Ksl1RtJAfFwBt7Rk4h3tbFf5hUzjIUCWG+UkSx9UQvU/lBgpgHSIGBbIviqaztImO6GLmeUHR7kvPTvckku1/aiL9orVDiA2I4GbbQZPEzW5ZDyag813Gc7jC7FFMcSUeylZ+YaKeyjhPiQkfr1pG6eYRuHgU4jITmEXYYDk0joH4o1BZDXRHUm1c71JdA41BoHmo+0csL8ZOGEm0+aRqOU60YBS2joLUUVoyA1lGWNluyigSyTHUgz4SOMuhI6vaEarfrGdqMeF+fGdr2vyxpenHXNcdf+eAKS+FizlGWOTYqum2cr0g8X/nEQs78cKkSthrWK70u9d5FhmS41pfZI1eoWn3P/+LATa1Jb64TNf7ZP3PUf5ilZlevACfoVwkqAbV9jH4Oce2sWZ1i7EqXSdL0anYYdx6n5ZYQmiNebhs4A92OlrzQWKjrR+pbZ8ErTxzuC10gEAgEAoFgoEMI4f+E3EH9+Bdy605XqVGYMYguMoao2BasrBMJswnyFHVujQluw3P9b6Tm5TlzOkbBliEJW4yX5E+88aNLjXfpc/xYrzL8rK+YHiSBPUKYEypLOP1jOjhpiDIhgCf3pppEYCjk0KbGhYeUntqsPHqmT7oMDDfPdNS0ZslAzLnFOCqC7i9JZaU/Q65U1rIpfE3a7kQrYLYamjfaMDdtuJwZlhXoJYOhbhAsPVpfezRce7S+5ih8vfZ9gMNRcM0xcOXR+or36Sv+PzDDVe+Dq8yHR+OwtADMtEsH6yWDcCZLhpg/9bWD1NXHIkusLYDlg2DZsbDMjHk0LDkKZ2imutLO54r3wZVHwdVH6avNQs3kx8LywdBUDK3DoG0EtBnqONrlE8Z8OyXX67pY9kP8Y1NMqqNAC0urSEq1xZnW75SPPnfcKc+yqCPR2Q5FjY6kTDp11wy5NLdBKlfC6n1oldfr0tHKqEjspQOXcOXNfFLlaBK2b3X9k9ZUJup1THk3I6oOTboy48hHx5cW2/Ot3HZIGsI/VmfHcvuruXxSpZAag642/1mjX3zkcF/tAoFAIBAIBAMaQgj/BLl+9dRd6voPqrZRSAI7kqgHuoJGyoi3ehc/fGuu2HS1iFFanS+rix9aR8o6jBV8ohDC6I1Pq8O6vqSvHVVOHnTu/1zXp7kn0DUlOqKYry9B2jlAehPUjFtJSgiIZK6IRXDHGqU1tDnTFK4y9RoUp0Gw5Qx5b6ZLddso3TISVgzXhvUZYlZviF+hpWeDYdkgWHIMGPZlmN6So2HZEBT6VoyBjhP16il6/b/Cxk/C52bBFyv0XZfrb9TDvSn4Xid8f42+vxceWAcP9JlB/3A9/Pg6ePB6eOQ2ePg2eOTz8NgX8PWR2/RPP6cfukk/eCM88jl4+GZ46AZ48Dr4UY/+XlZ/qwm+eiUYHnLHQv2F+XrjLL3uw7BqJrQdp+vHQO1QWGbXs34I1BpyaGjkMVA3GGrtUFcA9YXQWATNxbqpBFaYdR4JbWMgFSO7UXcCJMDFIUKYt6sjmhT3e9VZ0bjDSscucnbFIPtDrIC8KouLoJ8J+FcJqxnSKRHYPkAXMW/rUV37ojdojfohSTpWhzjf+JhEdsF1P2HgDP1p7CMlObwkna8nU9ktyoNY7huWQzjW/pmkumLoTEJqpE6Vq7uv1q8/fbiveYFAIBAIBIKB9DZt/AAAIABJREFUCyGEh0Ll9NP/pW74iF4xDNJjdEfClolSX1bgbDm8BUvckz0gE0uX/Ob9S7T3F+Gnaqccppx7Bz1AkwVLXvQ5e4Twk33gvB/zHDhTvmQ0TmWl/LxOs/W5f5m8vq9IsyIKETD3y4+PI4EoZB8RpDS2ZxKcNgW2yBDLO7GFr9yywQDrMJtHQONwaBgGTWYogQZkVrquMIc1nCN1WxK6puvrPqwN0/vyIvjqNfD1evhWiyV77fDAaniwDx69WT/5n/Crb8JzP4AXfgQvPYoRBVv/ADtfQ6/Xvdv0gV1wcC8c2KMP7ME3/ftwUDm0rNQaD5951Tl0K1EHoX8/5A7gYMYxI+/fCbs36+0vwZZfw6tPwGtPwUs/07/7kX72Xv3kV+CnN8EP++AHa+B7q+G7WfhOG3yrGb6+XH/lMv3F2WrDB9Waaapzgk6PxdJTs2nLh6DwaF5rC7FCdcUIZL+to6GtFIdUjOqKIYwB1Ri7JA9FipzhcmYHYv0k62+Kqk9tHymH1NsCVBaKM4HnWt651CnDcd/Ix0eT/oxsTskMhkqCPUEN8oqKSRM2J2RCR6efjy60PaLOC4eMc/NSGa0aiapvXKUOuS6cQF1Gr+Dcca3yGUdnprAUy3qzJxmiDltfPNxXvkAgEAgE73HQs5JA8KcQQngI1PM/yl3/UVVfBC3DoCOAjvxICWKDMZ0ntrhIBq6TdMIgqyjg2gW5AC/tDBh9KSlxM6RbMU8OXUhgLK+zi8tHyZMT0lQBGHUJekdTSpPn9y5FUNOHtCDfqUjrbx1imPVZcxckMKFzVcEcP2KAjttkbFNfahSkkfbo1jHY3ddYbCW1AlVXoprG6PBE6DkNNn4CPj9XfXlR7qtXacOs7svAY7foZ/9b/+EhTB3Y8yYc3HOE+kwahkl8cv8OvfUP+tUn1DNfV4/don5ynb6vHb62DL5yOdy+EG6bo2/4uO46DSmNobsrRkFDCdQZJjwU+XDrcC46TZWSBwySK2yeTGIBsHnTXqY7y1RnOTm+MEu05bsqazsqzQihdxblNk5FKYhco+uSMDj+kWhYYL18KOojAf78SVkbpLQzj7F9nrg+To4mWyNkklbVVByoaH1iOc4+cMqhO3v9zx8ccenaUJ2gHeUxZuLR5Lbo1Br/BGb/YD5h72n6oQ2w563DfeDfszBPALmcOrDv4N6d+3e8ueutN7ZveWXb67/f8trzm195btNLv379ld9uMn+++eq27Zt37dm57+CBnMpppbSWZweBQHAEQOfhbZnbPz6TdyNw9/2ZG/uA3ScCDyGEDuYq2fbSgZtnqbrh0DxUdwSYMJFlpxD7nJ3fsJdwRjJxygZwH1LZnnNz8SIhPamnfUigD6yjAHEmbMQtuXgvFfg6wDxPFxvMkAp80r1yGffEBq1yGHgaECXUp13QQn5WAUe3B0xKyaIzRHVLZZweSDwwPQZaR0CL2TOG8BRCQwE0FEPTUL1iBGSOg9XTYMMH4IYP526dlfvK4tx3Vuif3apffhR2vY606r0HreDgXr3rdf3KY+qJL6rvtqm7P6M/fwnceC70fVCvOQ06TtatMfa8MUPzMLTAaRmjHZ/n6tBsGXSQ2wranCrqIcyirU4uTFKoCR9T5ufWyDRjnWMzvtA0TjY2xPfgkFzHIGpkTTkzW+cgimeXle9IGOTyUat143mVIvYY418ouPbVl5ISLUziCYwEz7qYht70KOFPPxVFL1pKmU2w+ImWsAnUSA1nbirQG87UT90F/QcO96F9L8DcyfbvObBt885XX9j0m5///ulHnnvyJ79+7P5f/uibj3/nyw997ZYH7tpw35e6v3VzeM+NrXdd13xnz/Lb++ru2Ji6+4trvnn39fd9986HHvzWEw/f99TPHvjlL376m2cff+H3v3pl00tv7dq2d++ufYYlHu7tEwgEAw5IY+zwj9+C/gIpGgj4cxuu5d4+4CGEkKBh3/b+/25UTTHdNBRZUHvSq2SKMvRSZMLhquxS1k/FhstxVLprIcszd8kzkvFyX8qlEWTYloMS4TS5v6Rd/x5l2eMiuPkQXLcYkF8lV+VFbJCaEqnTT5HPje0fwwXl28bwc791g0xj4hxGLyD1NVttH9kpXzE1BlKjoI36AIt1fQEqgS2jIF0G4YnQOUH1nKa+cJF6YLV66WG95019cN9ATxtXORQVX3lCP3xT7itX6fXnQuc0SL8fWpNYTLu0QNcNRv2wYRisGKNb47oNgytUe1y1l+uOsdDOPqvkLqPy4hbxiDiqbys2S50nTYLFYYqYt9Eg4Mo1yYeG8k40EzxfROpaBKMfKfKSSML8UlI7B2sIxJGVaa/7OQXSlsJyJ2GG7Y6AwkiswA6OoDqT0hg25WZJf07q1hHQOATWnw2vPqUH+Cn09yLXr3Zt37Pl9W2vv7TlD7959bHv/fKeG36w5srPLzy79fwTr/5I/DPnjFxw1rCq04fOP3No5b8MrzlrVPVZI2vOGll5+vD5pw6dN7147rTi2dOLL5lZMu/M4XPPGDrvzKI554yq/MTY/5g3raH2013X13/l+19+9OF7f2Fm/sbLb27bsnPv7v1moYfxmco8vuzbc2Drph1mZba/uYuHLbu2bjaf7NhuPtyy03xliDG95z8PHczIOD4NZqo3zaz+ZLTN+X+a+ZupDp3cvt/x1m4z7Ny6e/cOZM4H9/ernIIB/4i1Z9c+s1vMoaH9s+Mt82aX2UvmlQ4ZfZL/rf/KDLu2733bVwkffDUc2N+//a3db76x3R87t9Cd280KHDrQKrkzbacb6BM8+m9t2m7e9B84Imte/moYqmCuKbMtb72xfeum7Vs3b6fTG7fxzZ1bt+DgT3tzFbz1xo4tr283+yfXn/tfZ37wQL+5yswkvJ/dUTbXVHT9/tHwVnQ4tm3etXWT2c+43F07/uazwtDItzZv3/La1rc28Ua5rdjxp7cFe9Xv2Jo/bMKBbhR/NEn+fOw4O7f5W4od3P3Hnz+81dvejO4wPE8a2Z+Hf3rX2uwGOzLfsg65TfHi/Bm7zS2aRjAL2vLqNnNwVe6Qe5M59Af2H9z86ltvvr7tzde3b7X7+U83kBbh1+eP7pb+ovDDlte37ti66+CRel2Y/8LMdtHetttFw06/sbhv6czftMPcK8yeMVu0f++B9+qvCUIILcxz/DP/BY3DoKkIOuKYOhB6VcTVf6LEYaMC0zGvw6AUEzrTzjzHF00xAOzan3SxAYF2thxsO8n9YAmXYmf7uDg5PdBWrMPlZrnizrLHgIw6nTrE7YI+78GVsNqEDA5edxIN0kIfk4AqE1YnogZoaCfmv2PPYdtoaCnB7ri6Y+GaQbCsAOqH6tZkbs1M9cV5KP1t/jXs336EVnseaTCPHjvf0L+7Hx7ogBvOwRbE+lJYNhSWFdqojBJoGA6NJdAy2up1CRQGMzY9wgzt5fZ4JcitR5H9bMarf65WmWM/sJcPWEy2xzeFgYe5Nkf/sPiTa4ntm7jligFVh6q0izok4ZGiBUmCTnEcIp/wGd/Q6LPpbWdsaEVsFz2i2d+I3Wi8xM0VziiEJlkkxASXJLZfLhsE3afp3ZuxC1Tw1wAfag/u3rnX/Hf1u1+8tLH1rrkz6z4wqnJmwaWnF1b867DL/r306k+W1V1wfPMl72+be3J27viV88evqTh59byTV1aOW10zae2CKT2Lp/UsnNy9cEpv9eSeigldFeNWzT4xM+fk9OyTM5ec2PapRP1HRl/zbyMv/8Dwz5xZUn12yfwzh1V8/Lgrai/o/eYtP37+l6+Y/yP37Ny7f99Bpf7ZTH7Xtj333v7QFR/PLr+ot3X+xnT1TanKjU2Xblh+/qr6S9c2z17XPGddk3m9dN2K2eta5q5vrdiwYvaGJvPhvPUr5q1vmrO+4ZK++ot76i/ubri4p8m8XtrTNLeveW5f0yW9jRf1NlzYUz+ru/HivqaL1zVeuq5h9rrG2esaLl1fd/H6hovNzNc3z95Qd0Fv7YVrGy7tbanY0HHZTasv/3zvkjtuC792d9/3fvb9Z195frN5gNixdbd5fjX8mSjie/RB4n+Guf/dueG+8DM3t9Xc2L74ZrOLOj97c+d/3Lz6yltXXn5z9rKNZlh5+efWXHVbx2c+1/HZW9o/+7mVl9/a8R+3phfeZCbJLLppY/q/+g++zTcEeph76qe/a7/y1sqzV9Rd3Ne++Lb2y25N1WxsqdyQWnB9eNnG9OIb04s3phbemLlsY7gYh9bKDY1zepor17UtuC5Vc11L5frWqg3N8/rMOWPOgSvObU8tuv7XP/tDLvcu/knLsMHvfvmni/+97TP/nrnmvI6l53cuv2BNw+y+5vnrm+avq5vTVzdnXe3svqUXdi+5oHvZBX1Xf6yv8gPprmV3bHp161+YLdV5/upnv6u7uOuz53S2Vt6QWbixtfrG1irzelPL/I1tlTdlFtwcLrgpXHBjxuzzxRszizamF92UXrgxVYMjh4s21s7asOS89Veeu/aqT3V9rvPr5lH+b9o0wwav/HQ4Z+ayz34sveyi1WZNll2w+trzVy67cE39pd1Nc8013msu5MY5fWZouKR3+adW185aU3thV+1Fa2sv7F76qTVLzzOfdNVf1LPsgq4GM87cvvpLe+su7qm7qGf5hd11F5vJ15lxlp6/2pwP5vPGS818cFbmfrLC3HYuWddScV1b9Q2pmhvbqm5snndd49z1zXPNKbS+blb38k931V241qyDuWs1z15vXlvmrW+dt8HctVrnb1hRsa55nrmb9Zk7T+2FZom9ZrbmrtV4SU+zWfPZvSvmrau7qNusScMlPU2ze81UYc2NqeobVpib3rwN5jZovjJbYeZQO6t78dmpa8/rfPP1Hflaq7k7PfXQb2aNv7L69IbLzslce15X/SXrmuZuMPe95bO6zGlQO2t1/SXdZl+Zq8Cc801z+lbM7V0xv69pdveKuetxDeevMydJ07x19Zf01l7S0zC7x4xc8S91K5fc8stHnz8CGZS5G7/4m9eWXbx6RdW65urehvndjWao6K2fbTazq84Ms9eaQ9Y0d/2yC7uu+Fj7Z/4tW31265zTa3/67af27z14uFf/HYEQQsCyxucegMaRUF+gM6W6M2FbBwPOGIzKL73NBpttKt+txwIgFtH5li2I3DhteV6KIuM5lNzFxyUgxVWdOWdQGZV9Zr2BjTeqIfpH0fOkUtrVa6P1iTFbsBSRKAQnYbgGQl/CikyjwwpT5kOzts2jMLIPExqOwuGa/wdqC1XvafoH7fqlR2H3FjRlObAb95V5Xj/yru0jFih5GfLcvw8O7IJ922HXZv3y4+r+1XrjxyB7AqqF1x6DKRrm1ZDwxhLdOlpnynKZsblsuWofi3knYcC/TWCrZyIvs56qi4kQ8smDPze0ISvLpWKYJNFmpWM2EKLTFcfMmdc2/DDHLrUxqltmQtjmTi32QCKSaYtOW1kVVH6JZDxjsyu1b1vl2mkrCaYom5FyO2y0JgqDCayS7RirqIg0W44ltbVFuTvm4skm+CuwY8vur2y4b/6/NJ1Tvujs0Qv+deRlHytd9unyFbNPbp97yqr549YYynfZ1N4FU/oWTetbOKm3amJ39eTemkm9NRN7qsatNpywclJX9YQ11RO7KietNUPVxLXVE9cuntS7eHLPwqm9i6etWzylr2ZST/Wk7uopa+eN61w0ZW3V+M4LxjZ/NLj6g2MWnVNa/e9jF9d8oGVj6z2vPr/lbX9w/8vY/NrWzqtvOXnwR6YWzJ1ROPfUkrnTi+dMHTJ75pCKGUPmzyisnFE4f3qBGSpnFlbNNH8WzD+rpPr0YQvOGLrg9KELTitZeGrxglOLa2YWVc8oqjlr6IIzhy08vaTmtOLq04oqzTDTDmbyM4bWnD6s5tSS6plDa07FCXEwczh1aNWZQ6vPHFZ9xtDqM0qqzjLvS6pnlMybUVRx2rCqc8Ys/FCw6MPJyz5+whUXTau78rzVX7nuB7998qVd2/b+0W/z71UYNrh98+5Pz7hq8pCLZhbNP7W4yryePtQcghqzo04vqT7V7OFCPFLTCytmFs2ZXlQxpWD2lMLZU4vmTiqYM3HwpRMHX3jupCue+/nL6h1gWY9+75nLz2s/8ZhzJwyZNWHw7IlD5k4cNGdawZxTi+fMLJk7s2ieeTOjaM7MwrnTh8yeXnDpjMI55jSbVmjGmTuzcM7M4orpQ+ZNGzJv6pC5pw+tOnvEwrNGVl31sVV7du1721f1n4Y3XnnzYyctnnDsrInHzJkxpGLmkHkzC8x+mG9OfryUzOVQVDmlcP7kgnmTCyvOHv2Z809cPm3oxTenvrZ1086/PGfzyPCde358wlEfnjDoomlDzI41x71qZnGNuQZPK1pwalGNubjMCWDOhOlF86cUmjOhYmphxTQzmDcFFVMK555RsvCskstOK6qaVnjxgo825g7+bafEay9tnjTs0ycde95Jx55/4tGfOv6Y88YNvsAc3BmF5oKdN7PEnJ+VM4srZ5jDaj4pqJhZUGFW0qzMjILKUwuqZxZUzRyC76cXVs4smTe9pGJ6yfyZJRUzimm3zJ9WVDHVzKe4akZx5TSzkkVV04uqpxctmFZcMx2HqhlD5uIJXzR/pjnbza3JnPl2l04zMyysnllcPaO4Zgbei6qnF9ZML6yeUVgzrWjBdLw65tlhLr4WmH0y3+yWqQX4fvoQu3MGzTNvpg02Q6V5nYof4l3IrL/51pyi0wrmTxs8b9rgudML5p5eUvWR4PLzTrxi26ad+TWi5v2zP3/hX+KVEwadd2rRnDOGzj19WMXpw6rMbjGn9+kllWcW15w5FG+ep9mL9/TimtOK8BI2226+PaOk5lTcZPzTLNcctelF86YWzptWMm/m6Dnr0nfs2XXEdQ+99caOL6//zvhBnzbX8mnDas4YvujskYvPHnnZWcMXn2H+Lxi20Lx+NHHtx8qWnFu+5PwT6s4tu2Z60aVnJS598dev/ZP/s/unQQgh6Od/rNbOgKVHQdsI1R7odtesFbKRDLgwBnb5dyWgTrtjpY5K9VipC725P/NJ+2Ad05Fi4+ZDbpBWh2Evx4xzkcGlcwcjuJxx7lpkE5q44i5BckD1bh/0HO/CA0P/fI8xBsqmw+NXK4br2iEYpYBREMdA3SDdVprb8G/6gdX6dw/ol5+ELb/VuzbbPsAB8QTzTsLtQPMfo9mfu7foN1+A15/RLz6in7qr/87Fufb3K0MIr7bhissHY1ZH82hoGYH8kJv9yvDsynL2ifZ2RFmWEKkJ0Bz0HNvM2l8fqF6U+1oDxb8+WAXSmdbac9VZJaXZisbWJCe5qZWZZxLyf/JgQZLtZ0hXBDY3IidbM3/rbmpe+ecP66aLGRiYPIH1sbZKlpxmdHsSVgzTdUNzD3TrHa8f1oN15AJrunYfePQ7T4eLN1Z/oOWTJ1374dKrP5lovPT92coJa+aP75o/YU3lBEPzuqvHd1dP6KmaaD7pmj9+zfxxq+aNWzlv/OqK8WvMMH/CyvnjOueNXzl/wqr54/GruePNt6vmjV9TNWF15fjV88eb11X0Zr75ZOKaqklrFk3qWTx53cLJhl52V41fOfuk9KyxDZ8qW37eictnTb3mik9kv9z7nRd//cbf+uP934c339h+XdOdH0p8tmramkVT+xZOQepbNaGnBje/y6xtzcQ1+H5iV/WktXaHrK2Z1L3IjGaI8YS1NeZ10tqayfhh5fgew4TNCFUT1lSNX109fhVOO3Gtoc1VZpfi/sGhwu7DivGrKiastp+snHtS59yTV1Wcguy62uw6HHnN7JNWXnJi54XHt114/IqLj2+55MTWC09o/vQJdZ8et+T8SVd9avoV/3F+eHv3va88t/m93ZBpnpl+ePeTHzv5yk+UN1SY03Ly2qpJXQsmd1dP7lpgdu9k3Pnm6JjzrWZS1+IpvYunrDNHx5xaZpyF9qs5J6+8dHy49NKevbvfzqdJZe2Sdm3b88W+b50+asEnjmtaOLUHfxCZ1FMzsWuBOSsmdtWY82fy6oWTu2omm7Nojf0Ev1owqXvhpLUL8b35pLtqgjlnuvEXlgnds45r+/hxV2x+eeu7tBfLXLa//cWLp5VcfPHxrdUTuxdM7KuZ0Fs9oXfBhL4FE9ebNwsn9lbjVWOul7XmkpkzbtW5ZUvPSVz20nN/1SV/39cfOmXwp/49tnTeKSvN5VY1CWdVg9dgd5UdKs3+n9SzAH+xMlcoXsXmGrSXYZe5p83F627N3HHt55Vfe+X52b91J7/60qYZIy/4aGxZ5URzN+ueN3GtuVSrTllddfKaylPWzD/FXLxrKsd3VY5bUzmuCzcfbxpmM9dUT1hdPRF/NTOvVfhmbc0Ec68wq7cWv5qwhgYz1Xw8T3oWTDRnUQ/uqAl0BzZnyNpK88l4s0u7F04x29hdTafZJHPa9FSO78YZ4onUhbeg8d2VE9bOn7gWZzi+Gz+cSD/V2XUzqzG5y97V11ZO6DZ7pnpcl7ntVI3DbTEbYsapGGdu2mvwHmg2x2zjyasqzb3rlFXzTl5pXuee1H7R8Y0XTVz+R4TQYM/OfQ9+68lPnnDthSc21UxauXAq3vMrzXk+xZzhaxdMXrtgSi/+OIgHBW+qVeaKnthtBrP+NWYrxnfVmJunWZNxuD/nmSWesubSce3nxP6j8pzmb33pwb/tdHzn8egDT58/+doPjLrsohPSZm3xf8Zxq81Nnv6/mz9xTYU53FNWV01eXT1l1aKZ3Ref0vrBxKKGip6D+/uPQMHzbcFAJ4T6jafVPVdgxFxqJCpy7YHvstNR3HbSPoJj7Jt2Wd7gyWEmyd1cKQ7mtkHklEUeRDmB6Tyalw6c/OKCBJ1NaF5yILf/RSN4oSYdsUeqR2WzUxccb1XBwDcZ2s/LrJWl+bBUt4zEOPglgwz30EuHqLaEunWW/l4IT9wOz34bKcr2VzGt4T16xh9ZUP1633a96VfquR/A01+Dh2/RX1uqe09Hz55rj8acxqXH4MnZPEy1jsHzrb3cMKj+bMJJvnzQfXAI9gGmA9auU4EjeO4MSbEfqW1B9Cma3kfX8syU7zNMurrQJPcWpgPX4OrONN+LeGheonLLirINXYE0k0/0lSmj8BLunDR/pkth+TG6Y4J+9l40oRXkwfwn9PtnXv5cePdVszorzmz+5PFLP1G+/OKTUvb//l7zPIr/N0/oRq3PPFvgE1tXxTjkfkRdLJlZbQihYX0V4y2fOaXTcJu5p6w0/xfORULItMdwxYoJK+0kncgh7WD+jzQsqNo+Z9Tgw2K3pVX4jFLx/pWXnhCeZ2hh+dI5M5qu/FTnymtuve/OR/bveacsgshocOumHRvbvvqhxBXm8W7RlBsWTbl+weQNNZPWL8RnMvPkap8sJ5jXvhoz0NPtxN4Fk/uq8HHN7LEefJSZ1FM5bm3FKYaBrFs0qW8BPo+aybsN9V04uRffm6dhfELFGVbTc56dqgrZI818nVncAlrcRFxi9cR1VRN6549fOx+f1VB0NTzTkMZLT8jOKm/5RLzuvLG1c2e0XH7eyhULrvvKuu+9+dqOfw6F/idj354DLRU3fOL45eYcWzR5vdlXZucvRI26B5/4zXPz5N5qM+BuNGyw97Ip6xdPNoSwx+5M5Abzxq2ZNbblQ2M/u/mVt5Nl8cOchgfvfXLuGY0fGHX5oqnrzGGaf0p39Xg84uZUsU/23fhwj2eRGfoWTupbNKVv0WQcFkzuwcf9ifjsXomH2Ky/Ofe6Pjh60e2r79225X+Ry45MmNX+2ufuP7u4Yv6ErsVTzQV13cJJGxZN2mA2bdGk9Qsmr180ZR2e5Dj0VU/sm3V8+t/Kr1h97Zf2/XVX+ve/+fCU4os/fXwL0q3J66rtTPB1Uq99bw7B+oVm905dt3BKH54b+DmeJHhzm9A7z1xNyKBWfaps2eWfzPYf+Nskmtdf3nx2fM7HSuvNtiyeen31xA01E/DKNXcGcwbiBT4B6ZkdzBJ7ayabz/vwkp9EFz6uj7l1VE3swzMZL3w8k6uJ/pkbL5I39+dEpHk0WObWNX+cuWn0LTQ70J7/VZZXm/dVE82Nwt5S7L2lapK9h4/DV3PrMPclvMlM5sXRbGnySrtEs9r4FbJNQ5sNJeupsROaTxbiHc+svzl1u/FyG2/nifxz7exT0hdPrX/rjR1/dE2Z62L7ll1LPtV1bvKaivEdhgFaPmyv04nmyl23cDKeBmZ9aug0mGwPE65D7wJ766tBcmjuqPgTm7kBVpg1mdIzZ2L23BOvzlx9wxFVZrlt887be785s2TORe9vMYcP19/uWMO9DWM3vB2v8ck9C6Z0L5jaddnM3spJnecmrq08u+mZnz1/uNf9HcTAJoT7d6ifXqdXngjNJXrVcWgkk/WR62y7b8veiN0lcjbvgbsEyWSfa0GdsyKXcSa47SpF+knCxU7E8ygfPYgnXdUf+cQEzmzGu0cGfjU4sdCHRnDTYMLZe7jKvYxzLqXOsUypTpXi03nrKN00DKPhlxyD1aFrpsHdV+n7u/Wjt6oXfqx3vIJhfWTpIVTwsEDlsCh3y//P3neGxXFl2/557313gmVZWdBNk6EjSHLOCihLIAkROhOVAyggMjQ0dAYUnT3XOWdbnrHlMPbYcs7ZcpAlWzln0VXv7L3PqcYzd+ZaMljI0vnq42ugoaurTlXvddbaa30hf/qk/Ooa+ZnazluyJHeiXHkR9Nct/5NUCchQbhgUJqMg4QtKaYS8PY8hKwqKoJ5APmHUyk9E/yFnrSVOBkbSCIUtrQYdjzQ80DJCdKu7zFKRWa+oVZu6wEt6IeqJbY7AUZr8GOwJMRthMFlFQNjCHmvAzLbsj+HbcqTvXj/PS9M4fuT4h699cZv30UrbqhxjRUZ02ZTYFdnJjfm6VmdaiH1OY02D69DRyzL0AAAgAElEQVQMB5qCBSZYGHYQFGTYD1ZqEfXpEf4BT+jHpVAG/OAnVgP9HJ7GcKMzjSFGgItWtjGgCBtwiexBAdCGQaTRgg5YSg8C1QZVCCsaWKkRzNO6pyfX5hjq5owN+JbeeVf7+u0/7O4htAOA0PXItUOLLYYAqyZZCWLXMwjRzmCY3dhuM7SxisSmZ0VVSGzsgAStxpDVGLQaAhYde9cBq85vTvWxzaFn4DZk1wUYcmMbe3cOYwCX1YOspIMKjAEGE2x2Azu8bfAEAy7eI40AHCzQg6zyC7CvThM9p82pb2OAEzZde6GB1W2rCvQdVq13ZnLDlLiKSXFLHZc1NZTc8hf/U19+sPn40V5UMP36sX/P4ZnpFdMSqgtgEQHKenZA4OwYQqy4t8HpCNlMbVY99LU6TQEnHFL8ij9hZ8Gs9U6Nrb5mcPGGh94+tL/7pZhbNm1bW3ffVf0LZiY123U+a6rfqg3adLBvsJiiD1phw29hIsEii4Of6yBcTTq/RetjE8mmD5WOWDP30rWTY8qKr23e/NW2bt/V32B88+kPy6b7JkQtKATovoaBIqzsEaIYYdrbjSHOorDDogtMjq2aPnz5Rxu/+SWOMjIAwjeG9zNPS663agPs8mQHjR1bi6HNwo6wjl2ebVYtzA0HLGaxlwM4YYMXbYPLVh/K1wYc6R3OtGBW/PLZk5tPHDs1F4NtW3aOSy6YoF7BrkEGb2y6NouWTjTcEGzstsBPN7w1Ou/4BJqrIasuaOsyH2xGnMbwZL5Z9EFLasCiD1gMQTYlzFq/WcduMvCTfJ0vP9ULdxsDm/MBuN+y+w+/IQfxRuSH94i/Yj9nf2WFH/rYP7HiXYvNRnz1ADt07Cv8Ex1MP1zjY78K2KAzPABXDQoW7MB5tsFRZccZDjU+gf0clggDlvSW3EtW7Ny6918VCidPnHz58Xcmpc6fEl9hNXjg00HvZzc0OBFwRtrppOAbwUOnh88Xu4EfDTxT7F0H6TiwU+ZM7yi5fHVmSmXRmMaXHnvrlE5Zj46Nz30wf5J71NBZDpOP3dsBYJvgvm1n6B2pYPZJajexm3+gcFioaEQoM35FdlrF7a2P94R8vfeMcxgQMtjzxbPSLZPlqgvk5ijJn4xejmpODzYLXg6KadTpNWt4wxUCP2gIjPB+wreDfgUPuKqT8zCcohG5hSKckCxJhXWkkJiSNahSvlO+fJPYsaYIdalQQ9QcyIlBSEQkJjMGbEJrLwK6qfIiqapv2BUvrZsg3zcHUtffvVPe/bXceex/gH/nAeEZHwyZH9nduelF6dVV8tM10n2zpI5roc21/P/JS/8LzikkHKKnKAUbQqKDCmTDLRRMoiLrI5572UzKT41iRUPLDdwOt5FziRHMxlcuKMVExVMumkQ2fbOyQkEOSRqlw5CuAmHDq1wOXbx2m8Rqi1skfLrFXHWTPFstLb8wXNUv/Hi5tO2TM30azvA4cfTkWxs+vnfNMxXWtskpi0YNWTg1tsZi8INqCyRPISgI4COZAZhAAUlDjX7akBLEUgMLCDuiQdh0RPr5ARAaOQEIqI+wot4HgNDAn2zR469ATQr40GHwOQx+Bxcgsf/sd+j9rIJnoKgwbSWDpsS/sSo5M7Y2I3pxjrFqdfV9T/333zd/8VO3N13s3rZvXf2D1wwptJsCRcNWQkWiw7oNSitWsUH5ZTVQNQ+HCMovVodR1QWFFxVVPqsWynr2FR/7LFqstOBwea06L/uVHTlVOzGuBjyYuMHbR7WtEJQK7I18LNbNAZvWb4N/GGBgA7AlK3axyIbKgxVMOs/0+MbRAxdNSl7UOOuGx29/edNHP/7C8rqXDwZu33z+kwmxC3OTGkH2lt7uMCGc0IsTRCfFgJsODyBOVKcRz5cOJhirlWckNmYMnbdkZvuP33V/azEDFa8+8+7o6KKpMRVOg88pym46oTao2gNiMvixnhan3gjTSUwbdq6DRUASrs5JqB81tPSD174861qMOk90vrnho7ExJTMSakqHrYE7jInQe5BPe3YdgSKdQTV2jkJ5KS2T4pbNn+I5duSXArMXnnrj4gGWzKRaM10RgBkCZn6QAYPBz/n1Ba9FAEPZzOxWM6zDZvJN0pTPmtR0qkeYAcKRsfYJMcsLjB1sY5c5ezkLzjELIDS64xFIC9CCkTk1gNg1CGdZizdSXAWw6hDO4d/CYy3iQD3+K70/X+9XHtM/NDNop4MN5owObqrwBLy7WmAfvPBDHX8yv1PBzQqfgwcKb9oI/3R8UU/sKr1KABEj3ZPhANLnAk5dAKVWvAshcgO5uyWtdbpp6Zavd/yPx5Cd0LIZvgkJi3L1zYXDOhxpIfZZw6AR7hi/YAGR0oGCzSfQbCBy1cC3AAvtpvbiS1abja2ZqctqC1YdOdArOgl/+Hp7x4q7x6nnZKfUOtNDcHtnU84E7RXgrIY40JmGYNvoLR7ebjO1jotZUDbT/90nv/NmlnMXEEp7N8sPzZarL5Jq+kmtMbInTnL/U+XK69fORjSY4Ub/SiQ3ZkI0aSKNgiKqXghEI72CAkOqI76gESEowc7YCLbkBTfFgmPqoIsX9GF8GhblZDsJ1CVlY8BftagJEoTdKlDf1Q+GzMCKP0k1g+WV10l/ye58ujL81QZwNzk/zqIhhaWDO8IfPio9vFi+YYrkvwSWD2r7yjX94RQ3RWNXoVpuVUmtatkj1gU48BNxJtg4SuAtzAWfwmyGGyOped69yDhRnGB4ML0SSU9PcKkVwpBSWHhOJrWtArWoph5CvorBuxyFRRNPuqcWXKIckc2Gxyq59gIQx77ok87VtHqGCrZu2rbhodfLpvjHxsy7dtBsVsrk67xOEE21OxCc2PgHMyssvBzOIfsHhB6AGR+WF7QF7Dof8YRUFrAn0POhRBB/a4evXodR1Eb4H6xUHMNLeKw6tnlxA2BpgQ46+LfsA5XqZjua2bB6i5WMltTWGfF146IXMVi4tuahT9765ki3+gowQLi25oFrh5Q4oPmnzcorJ6q02Lvz8gd6ksvCzwnimvVes85rBuwHOw9vhN6UAUs0fGtWJEjNBAgBJ+P/wc3Gnqn18INDPKqeji0/MjYdfz4dJZs48rwchD+E+oMhw0KQXa21pHrGRi++dmDJDEOFf/Fdb7/06f7dh7rxQJ2RsW/XwcbCGyfGLGbvvQCJU5Iu81oWlyrgcCELjROMLzHYlVkKG6u2vdNjV1w9uOCD1788VZXgLxlffvjdrLEN46LmFpj8BWltNgIGuGNUstNjPgE45vfDVSZ2mFYBgJlhwCCp5eqLnHe1rd+5dW+372qPjp0/7r2r/elL+9jYtVCS1uE0QeewXVlR0gc4HmaAEAnwzPjqLMOSm1wP/fKXePHpNy8faMuMr7EjnIBDDas2tBrFgZOVr0/5+aZHgKHj6Ighk3xt8+ghc0vGN5yqhPjHzTtG9MsZO7QMJOK6oCXVC0hM78XrEa93IMTg/gY/MfjxPsCBGS4MefmCmoFuIzQ96Cbp67p8RvcZuvxh2ug8yhPwFuFhrws3FnyOhS6ByD+BTj+8YxA2ViAf7CHcx3TiVsPXofhqVNeVKbbDsIZFHwc4P/HmTLd3nwPWMlonJy76+qMt/y4N4un/fiX/8sqspKriER2gcU2DTgSHkW6kvi4bLh0a+YvCJwWtMBqBW6NuBSf2QDpNwanxK3IvWf7yE++c0lnriREOS4/c8qLtsrrJqnIH0IAhfn+GfooAgkOY+U6Y/wwZ+ktGhKYlrsi/tOLOjifO9L73+DhHAaEU7pReXyeFhsnVfSCCzxuPmexoxEIpEc08D5BXzEpePG8dpHpaRY4vEdRH8fGRTq1Y0YjFxaXoxMiLcjD0b1SFXRQmruHyVN5JSA/U3PRfaE0xeICQIe6Gm6jLmE5MroP/g2AAhIWVF0rVA+XmZHnlVeEHCuTNr4Mc8fw4qwf7DDy0K/zZM52PLZZXXS23JMm1g2BFA3SkUWxidDbjNOCJKZpIUmULm11xbAvz7BOYlvCgUa0kXirBg5xLbOQzkJYkUG6K85nNsUY10eMC3cXIjfz5fKWDMjCQ8ROJhbRmQQsuqGcmNMhjD7nnDeJDMJuRm4ZCWv1N48KfPHmuhVuyk3zk4NHP3vlmbeU94zRzRg2aPy2ulqGskuGrC9LaoVLRElzxiWVjAnXc8gTAIQeEXqVapRqCf+zpfAqRRY2CWILDA4fRazcCBygQjlLH+Oy8xPECn0Z4Scf3ATZuV0MaSx8i1RDyYCsZdp2W0DBOXV7rvOGD177sxl78XQwQ1j149eBiKyCHEK618xVrRQfLyzgDr+z5qryB779Ym/fgA4/4rVeBeWYt/IrLa43EYvltWqrzfFjCQk2poD48Gl5eX+roFCCMZAfZ4BPQUaEC6FwEioevKhm+lr1WBsDC4qLrXM/c+dpPm3efpd4kMpZcW77dPja2OCuugqEsZ1qoaylpQVBN5Tirj+149PDIBGha0hSlpQp2wAtMgesHFT607vnd2/Z1+64e2HP4mTtfueRPOVa9uwBKQ79FoHqrjop7L30FWGjgCFCcQa+ownF2pfoKdIGMgfMtl1a//fKn3b6rPTreeumTkoyma/rNKR22GsRyXVQGRDchBwWWVChM8I9XlZVMcG3+cvsvf4kXn37rsgH2TE0VAkJl4+wcQSyrQTm8/CqmNS8S6DqNbXkpTaMHzykaV3eqd5It329PvzA7Y8hiFCT7LSlevJHyWyK/LRj54hqKBfgtDmGbB5Gbn/8KBfZWArR6hbIDaT1uOB94Aza/l/J7gp5Pdb5p4bZDugzCmfyA4+KUWefjUFAnyD32FWWiXdCgl6+kEFA0+MTdHu9RsA9wEVkVSYgeAofs+tYpKYsREP7PKyzHjpxoKF43JX5xbkojNCOA/CRInecol4h8fNjEWomQRfj5hcwtuPxodQbqFWtq6xTNksLRDWfckWXH1r2NpTdmDJ5nSW0pTOvApnpUxoJenX0F5IzHym9Payse3mY3eUZHzWpZdPNP3+86g7v924xzFBDK+3+Sb5koV/9Zdg2VIX0hFgBhC/RThbkNI8bNu8kqQx3J8hbR3kSzcFWeaO0Lc4JFdAk2YfJ4o2i7csVwvCeauHiCBbiPAjgkWkbmiQJqjJFQkbFHWPkrN4FSNcG/cGt82JMArqFsr1o1csWFchm0CEqtyeGHSqVvXpZPdn+w7/lx5seJw/Jnz8p32+TmRLlygLysj1R1UbguKtyAlp5o0wLzuVUoiimnnoIuXbGyIAkl8PxUd/GAEaHzwjI0jEEpEv3EBdeIeCaf1ZwwhLUMlexSia5C8ryJlRQp6c84c1pGUZPOWWEIOS5tiZdbk+TGIVJ1n/A9dvnIWbbW/mtGuDN8aN+RV558J9e09Ko/OzLjatmnb2H6Soc+BGpGrFrMCMCIxUI+MCA4Clp+9li0nMpTjDHFhzctePtsJoKRsMG6OJUXRq/N5MVfQUMLL8350m+k1IAqijNgUCGZifICvBQQ/I8X19QDhMccxuCs4R35yc0T48q8S27rxoTi3dv33djw0NWDitgLsSLPCjtGPTwkc/VbDILGJIDHSnZa3ddh3ab3inV9Vol6LLgkDzWZUSlPvWY8ngLmeamiYuWaHd6+hxd8XXlFBJbiP0OhCVUFZ1wDFs41efA/cPKBPTCzPdQG0LkxlJPimqAqm6haUGe/cdeP+87SfhVWUL7z8qdX97VYtS0F0HsZIvIZD7vPYoT5Y+GAXOFPSO3G+SKu0kSf29JhKydGLbBfUf3uq591+64y1P3D1z9d1S9vSly5lZ0aki9S0a/lhbUlggkF624gvRxnlTnsT4WFiekJ1df2L3j+4Y1nkWqUHYTH7njxiv4F0xNqi0l9DfUxu6zgfRH6tYOtVJBBIGdaMCe5fnzMwtridaf0Ki8+89blg+zT4qpQgE0CB7Szgq90afiIOeSNdiSbNHCsCKagxjaz1j02en7xhPpTfY9bN+9Iv2jm2MFlIOFm99IUjzWVXcuBrhQfbEZYEhKT0y/4Q/6Agzcd3GyRCvPStW8zCBqZYTDQkXpBY2/Aq15wg/iHfn7fpjU7PXCSNOf5Cxlx0/F9sBnpxo7rTbyd20+thlzQwWnJAKes+e6JtT+8ezvwD+0GviwFeN7oy9SVbfpo678DhGy8+vQHcya0TFCXOcFLLFRgFBygsgRJnyx6OEHIqnFPMryKg3hwYJ+BZ0Nf68L0tpyUxoy42V9++MN/eN2eHgyK3hl82jy8enpcFdslKxprA8UKN+oAdoAH7ciNO4z+grSOOZeunpZYMd205KGb/3am9vm3HOcqILynAOwrGgZIrdhx10KG/kqnHwJCN24isFvmEREaYQEaI9r5NLwyBvpFxUWhzdRMhX/VSPpP8g7FRsRIM6FaGH6gyLMJEy8wID7cFI2KO8oDUFN0ocwzMDQMCna6NZ0MDbbEgVtMZR956X9J5f9HrvyzdMsk+bP1EObGMMP5+Pjf8eg8Aazvvi3SBw913j6js7KfXP5HCDNc0UeuHxpu0YRbNTJOJ056s6/u2LAIihDaZhU3m8EQQrFpwo0a/hOcpWEF9TWJkEzF8YhmJv6Kr6co5CTgT4CUsjCk6ewKCN2qiHyU0GCThitUW9DeqaF/uDUx/EzdmT7Qv9348ZsdN7oeHB0zO2NomR3a3MGHw07CJFgGZpCGYzAuPlQURIB8GHppZRjGyh6wEsrgFcIhLKoMkYoWCT0OCG20pE0luFFBjwy0eKAWNAYsEfkWX9WmggPFmUSneC0CXHFqEa0O8E8AlBYZQsVG/4yk5S0Lbj7efUZzu7fvv6H+wWsGFrE9cYAjRYD39hi5EQ5RPRaFstMrrZJUkCEzAL09XexziCE08BV9jljgsLM/8djJrBX8TgDXAUTEOs/SVUaLpSSnArBqxEoRW4N04igRpMQjj+YlAaIcIerDFGI/zEqovK5/geXiqm8+3Xo28oTff/ljQ9EN44fORReWkNAc8rNAJT6XZXJASPYYWPUauRMSVeF2HatHWSlZc81A24bHNvYEQt6740C9Ze3IIYUWnbswvR3XBUggHZECWgQUtHdtoOJtugj7+RIA1JRX9i2+teWJ7T+cNStZu386cJP70SsGFLKrBh0sQeKrMLScITSBC78VHfnHq8qLRja/8OC7p/QqLzz95sX9rVlxNdCmBY2juJKlrDpxLQNiG4OPH1ts+rUgXmK/KjCGzKktY6MXlkxsONUwzx837xh+Ue64oUvt2FOH9CC0Q9s4s8dRGfX45ZOqEwAhXJgWWLXh3CBe5rCmwwWiOl8EUsKTxeVPax/Y8qeo0DmTLGQFQong5c+hWxO+fQKEZrwiUNJPEgOuexfcKV+6wgU7atvDuwoHhLwLwGHkfQS0HANuWKZglrF808db/8Py3NHDJ9qr7s5Qz50eX12U1gEWZehYg32/2FYtSEIL8ZBCRGrTC/bSSFrWIPldO+DO5hs7ZNHMiyt2bN1zSueuG8ehfUcX53gnxS5h07sATMLQfY23UXQFhNA0XpC2ympqvXKA4y9tj+/fc04o7M49QMgw0g9vyf7hYLnJitGWOBntDcnigvwPO7lAlKL8CAGqf8ZyiPQIqGJbqNlPJVE1zPkQtHtBWWkn4Dr+Q8nFAwA4E9ioAqFdI9XTXexAUM4Hf+hSyYqRI3nJMDTYGneyJRZke7WDIEVw2X/Jy/4guVOlvzXIm9+Qdm1CdejZV0acH6czWMF4dL+0+1vpu43hF9s6PSapqq+87I9yRR+pdiCsIHhiAHpRoqZbuIwKvhoXGjQoH1WRR24YZ7KME4/LmPmyRYyQOqMxKQpEwzyjgiPGMDKEcnMsz1ZxCfKc+En6E778AV41PIvCJdZc4DnRmFmvDrfGdjZFhWsHSGvGSnt/ONNHuceHJEnP3f/64izf1JSl0+Pr7Nqgk6ILwNmP6mMsVrQ+s1asXvMahXfCWNjPkRu06IT4ivRXCAgFWkPaCq07FCETLVfzj3Asy6ycQ/t5uxcRYgL88CqHdkYL/S28JYyrqrxcWaTzlaa1F+q9ebqalVX3dqPjKJjK1D14zeAiUHXqQjbhvmBXACGt6+tEo45otuRNYqgXhYMJTCDCZlqYNyj4lmM8tN4Ry/+0QeXXyg4176vBKhD7Er1oO8lVu3YozjyiiAxYhaxLkCFYCkPvGYm+4P+ASY8eHEpzkhvHDpk9O6P5w41fdtcR+22GJMnvv/b5pKR5M+KrC8H6lTeM2ej9AnPrQVaZYDOvie28lPSJzjEuw2M/LzK2O9O81w503Nr66PYfur+UPHHs5OfvfJ+RUDA9vgrUkugSSe1h2CXLZhfOcAUNwgUV4N2G4mw6sH+VVclFptCEIUucVzS9+NiZb5f6hWPDo2+VjmmZqFpSDK1iQeye8imUOBTHOggypffIMPx1g+bUzlq3f+eplcgvPPXmxf0smXHVmIyKPaVGurf4bQoFpyNXErH8RP3JBrpr+QvTgSHMiJrPAOGpyg63bt4xrF/uhKhl0O3J3kUqthAbhLlLhCfk3b8EtEhALvh/H6JEfvEqyuEIxY13AyEE8NLdj7t54aIS28x6/sDyc2ayi7kX3upT8S5kjOj2SadqVhaVEMM4jBw/48yEo4cnzkOt4NAxCBuCSfEWwH4szT/NuPSbT7b+BxKbHd2PNn5dbV85alCpUx/AeJWQnWx1OFXoU1hKh7ELDiR5qtFPDHBBOvUQgjNN4bCOPG1z2p9y3vn758eO9FQo0X8ea2oemG5cmp1cx9AgeLHCchWtRvm7rPgAW8j2mR3tkdGzHddV/+PZd8Phs1Kscarj3AOER/fLt0+XaweFXVFADGKnEwDCFlHvUgnr4u18QhSK8RLCqEMWRa2w11eHhRNjhO5oJmWputOlwlw4rqbj9jNUmhMgpNfq4v4vUfcgUoWUY0EltUxZ3mzPq/pLy/4sL/2jXDtEvi1Lfu0G+asXpT3fQXTB+XFujs6T8v4fpa9ekt64LXzLNKlmCGQYVvaR6wdIzarOVgaxYsKtGrTABeobZlpjNIqQIyY0REQDrmsUwRVkCUPmRo2Qei98cUXyBCbRR0Snikmv0proilHaaHnIYTN50kSDhakLv9J/I8dRT5zUGiO1QlS91DBYbowJP1p2pg9uz47jR4/f6nnEfk3d1OSKnJQmmzZgSw2h8CaEjt4BzmVpPZZUD6tN0TvOb9FxdGHmNAsHOQhsgNzj67XEcuhEZyCWXLAOyjMJlS3gQJs1MIQ0orsGOptT6WMzKv0z3BYPl8NFv4qOKyQVsxmOMLFwmTtiTaHBZ06rW9f4YDceNACEtQ9cM7jQDG1+bZGuJAOBZA8IPqn1y8iLLW4FobjIsEOnhaeRCpdgAL5xn1nrEyY0ooGHC6VAwWUHTtIjeEIqKJEZAEAoHCMMClbnGypIeQnF2zuh9vVaU0UXIjwh6NR3OPUrC9g70jZPVC/wzL3983e/68bj1tNjz/YDD657/rpBxawwBWN6DoOFAtCo1N+Et6l0pgUFznj/rFDWB4oMbaXDV06JKZ81uvmVZ97r9h1m0OL40ZPWq5ZNUC3OS3aDkw2tFLCiPNVj1Xq77I+f28zoOGlPFybv40LPj0JjKDep6fqhc+9of7pXBa/9uxHulG4NPDIudl5+anOhqR0sFrF70I7wxsFNX7nzakFa+7T4+inJS2/xPvavoQX/ebzw1BuXXGTOYoCQkhIM3CqGS7J5HynqRflPvLgiEBA3ogADFQQIi8bXn0YPYVrf7AlRSx3oYWsVjJ9ZJxhgTg8q9J1fUQqIDlJ+j0XOkC9YEDmGTxAuXEKgrsxtel8WMK3xknaD1AcKDiQQJW4jtGwnOhgN5HAj9O1azlKS8w16KdNN3sPv7Uh4KjcrWsCyKh8EOjT9MvmzDEu+/fTH/6xqPnLo2N0dT41Xz5kWV1k0rB3XJZVuSeGzZfTblBuaTrSj6xVM6HdgtD3kK6ZBImvJxe3XD55dOqnpy4+/P6XT9+uHFJb2bj9ov65ySsIydhYgJhHJUkzBCRCfie8CXbuRJMzUVF450Hr/Det3b+/+7uXeOc4tQCgd2Su9/Re5bpBc3x/sN1pj5RY1mnCQ8Qa3QxRJ8SpF+YnRgholP1AJYaN+P+G2rxaKU3WXGG74Q2wjVGEkN6UURshGJGRU3LejS4ZbWLFwbMJWxpY4kPyxf1I/SF5xgbzkD1JTkvzAHPkf6+RNf5ePnDEK/vzodePofunrl6VX1kr3OIGRrvizVHmh1DBQao4iHAhNg7Qe4YrmDkY0FYWvDOXaI1pTpnRMl5yJiGqUkjDxklGJx5FewTBdRKB/5v+c/xW0DiKL6MKQTJKtKq42rTHY0AvLH3BN1Q+UfIbwjx/InWdmTbFHR+fJ8Pbvdt7YeH/u8IqpiSssRg9QghR7BUqbdgySgvrArCXnQ443IuZ4BAgjJBjHIXwdF7VtZAVuo755Y8iZFioc1g7t/ul+u8lvM2GqhNEDLTGGVnsaNP5B5h6mrlGCAkpAgxGfTGXTcyRjEXImTjBShYSiLwYI7fpW26X1fwk+3o2HbtdPe1dX3XfNoEILiC3bKOYLjOwB5pHii7i+iBGoEIJydA0AmyAciGP9+K5xQxknRhEG7RgzWADCpwCmeoBxjkMXsGN7GxCtGL0liEfFiSRCOFg4aOclIJWJVsW2B2VmihUEe12ILtR3FJo6SoZ35CY35Jqq71/93P49h7vx0PXo+HDjVxV5q8ZFL0bTzgBSGaRbpn4wQY3qu1bbClz32rgDkIBYBhAKlqavNKe6xsfMvW/t+h7qzbvD/8TU1EWT1cvJjYmTvVrieLtgQqI6SXdt4M5AVh4lh3a++iDb82sHzqp2rvnkrW97Yle7d2z6eEt9ybqM6HkQBQlh4iHFNcROyBAloyQdZ5X96L+9USUAACAASURBVMELluetfPeVL071hTY8sXHEhXnT4mtFqh7vT+a4K5KG6ueAkCOuAHfahNSWkFnXkhG9oGhC3akyNlu/2z7swpzxQ5dQZA4BQt4dit3X0Fio84kp6hcNhFwxQYQhh3m8nU+QqIpfFOlC9fxGbRVmXdyjyOAVBkUkIlCkql6r0n0tuEebXvTcKqCUHEe1xEx6+SKLkW7yvKObfygYfMrtha8GwqIYb+pGqaQ3S1f+3Wf/exTQp29/01h0w3UDSmDp0BQQHrBKU7rSmujnqlFlqYs9SIMddqSF2B21IL0Nc1xDxcM68vRNlw+wP/fwG91rOv2/jmNHT6xreHBCwryZKQ08WZFSBw1tVoEGFU9ddp83p7rHDJxTPKbh03c3nerax9k7zi1AKO/4Ulp9jVxzocRwICs3oejkkWhkbkEWoCIoQq3AM6xuNeFIFkWMEgnIBaJoMCNap0SuoEvNESY8VonEcOE4Sp6lAj2iUhTjB91YowsJK+5YjNQYBTi2uj/bJH+adF+p9FK7vP2z32WVfH78+iGdPCZteTe8wSvfWwiwcMUFclUfuWEIz6N3Ex8eHfGGEWkooleWz1jFA4n3DQpCO5JP6EYf3WaVAHsCKDapFWk0aLCVxQ4kEik5k9oUuYKUuET2W0xPASW2mzBhlNQw+MTDC35/ERTHjhz/6r1v25feMSFuQWb8Ckeavyi9w07BxwwT8izgNiHU5PYtZqFO7NKOIjqyBCC0kccdMmYWXIzP07bmJDVOj6/JjKvISloxLbVyasKyyQnlk+LKJsYvnhi3aHL84inw7eLJcWWTNEunxq+YllCdnVSfl9pMNRAENuhIEsnJQ4qdAAoFMZXFINbURbgCAcJZw1blJtcXXed6+ObnuvHoESC8dlAR6qAwItkIphcYLCGUV3CgEPXplI27ibIDmI90K7QMaVvztE15qa681MaclIaZSQ3ZiXUzE+HBjKQGs7YJt2az1m3RtZi1LUAcAUPYSgJdTKKD1EGF47IrO6Cn/kOUiindjIoFBYniIib1CAh1oUJDe6GprSi9vWhYe1Zi1ZLpHa8+/X43HrqeGyePd66/9x+ZqUuyk+sL0totJDgk1V/XLlYsXnGNQ9Ssosi2EYWo5daFNkDdbUXGtsI0/6ghs1oX3sYK2Z7Y8y1fbzdfXTFq8LzclGbInY8Eq9BG3AvsJ3cHMSjciFIEo50GnMHgpJgl2ekV9679a0/saveOB254znZFbVb8CjbZQEcHwgSgOu2gIyCzkAC3JzG1gV50QPEtrQ8fPvVAuQ1PbhzeJ4/dUoAhhCNMgnbugalETSjHkx9tMu1k36LxEgHCwvF1p9xD+P2OS/rljxtaziMu+QSjyD6/EgwjIigRgqJ1kC2SEOiL4GQRTqBAIwEIcfmAGxd7hb2z10YyciOp7iMTnnsaC4ilqPpFWqyXeDYCxrhO4SdzabFOF7AScYcLf2ZFBqKPPMeqU8xa4bcOo99p8kxOnv/Np/9JMkrj2OETf3vg9bGaOZM1FWiI6leSLWy8xdRL8lQR1hrRhyPnRqqTICS/p7fbTW0OfajkkpXXD55dX7zus/e+PdUpdNqDvdPvvvhpsnbe1PgK1Li2IQ0YRPVyyBpJkaEFLFgGzY6vGdmv8NFbX9y788Bvtp9nfJxDgFA6skd691658s9yY3/ZmwCFLHGDhAbBr0VFNTE2RAlvGO7ULyLmI/weOjc2UYaEJiziv2Ul1L45UkYT6gs3xgitqboTFKH8ybw/kCv0MDagBVsTW+OkVlYQR8u1A+Xlf5arB8qBi+W7HdI/VsuHd55rdvznx+mMzhPSnu+kv9XKt2ZLrTqpbiiEUtZH06LGyWaRQEj5mU2k/1TLjRqeeqLETggQSOQh589dEBsYhqUQNDWNLG0oeRUxgkXXcGNSDgj/2aFUUvYB1NEqHlnBLgTwfFLJ9X1PVg2Uvn1VPnn0TB/QbhsH9h56a8NHgYW3X9OvdKK6EvpPeJEB4d1WLWUf87JDeJZgkaTlDJhVZAkqCQe4hIz2JGAJGECk0Zqf0pSTVJsZt2xa0lLLxZWlGfWLsluWOwJLbb4lltYlFg/7utTSWmH3VzpDKxyhFebg4pneOZOaLFdUZ6YumxS7dEpsRVZ8dWZ8zcykJgYIoZ+EgVUd0GgEhCC60IhpzhGFpEKbBEqGrcyKWz5/oueFR97qxgO486e9qyrvBUCo9YMLK4rKgIYywsYVVrxdx8OrecK01Auk5So1ts8zkupy9LXmYXUzdSuyEpdmJi3NTF6albx0WuqSGfrllmF17Ffm9DqzsS5PVzsztWZ6YtX0hBXZiSumxi5lpdL0hPr8lBYbOzIYnefUgUElX6rHjkQQ3OoQEwq4LlbTvXyB36Ak3QWdBlY2gRNDgRG6bqzG1kma8uZZt2zd1P3J7N0+tm/ec2PjwyOHzIHal1Woit7YwBkSrh3lcEuRjCrMG7osCs9J0ssVGNvBlyg9NDGm3HpF7RN/ebkn9lySpGWW0PiYBTOTGxxpQSpqQb+HEkEeSacXCXVaWhPpUnkLsRlSmhCXd/3QWe5Ftxza36tvWcePnGiYfePY6IX5Kc3F6SudBqA3iUOLhC5i5Cn7YfHwlZNVy/JHrPjbQ6+dxms9/8TG4Rfm5aQ0ONOCGHROnIzodqZWZ8WbBFGHmQMwH94DGZJpY9+OVS0uGHfqgHDzjquHOkYPXpCX7DantjLYb9Z5GB6gCFPsHAtaddz9iEImuBsqNcEC9ysQIGm/MQSCVOKwQkRSUl2L0qIcSYAwcA7cbowwoiRStfNAiABGcXD5PWiVtegXjR6knKfFLFnYQx05/XCbVhvaOztw+nG9Bt5YIECIGgFwfjpoisLV58lNqZ2YNOeXAEI2vv74h7qCGy65wDojoQ4TDvmuWsVb483n+Pllw014AgWwNyFAehPAhGnt7FOj9JLV2Yn1GTFzHrltw9HDvxGfsWfH/tu9j4+JLrUaPE6QvZBtjB/zEgPUHhz5ODOELLrWyZrFC8e37vrxrLGG6pZxzgBCdr///vXOG8bI1X2khkHQMchqTcCE3E5GJENoKMubsxlIpIDfBpfAKeShhlhBKIhd0WFBgFB4d1hI5ngCmxDRdUYoEVKQIj8DWDQO7B+BFYkFaWiLRvbEyB4NtFGx/ay7SFrRV2pMkG6d1vn2HeeNQ8+P0xnHDp58dXXnzZmSWyfXRsl1gyVX1ElcBCFGWuqigpYxPBMNdWNx6qpoFUPChY+waK+VhIWS6JilhkM1JyExeUI4MAk6XUGGisq6WZiXEq8O/1Ax11WBtNUdLTX0l8v/EH5svrznmzN9HLtnHD545JUn3144yXNV39KZiS0OaGPwE3fEaQe+Ok7+JYqJpVe4etLnMfRsOEDBiDboWr+TVTPsqyFUmN7mZIV1Sr1VW2VNqyq5pmbWqNoaS8f9Hc9+svHrvTsOhP+NuQu7TXaeCB87fOKHL7c/fcerrQtunzOpxXxl9bThFROTl0zVLMtJbihMC5aY2ktMHcVp+JVtw9pRZolCLFp656l98NFbevHqyTFLqiyrP97Ynadv109725fdec2AAiuYsoQs2oA5NZCv5eLVLmJR6CcU7UmRJHFe8hr8eanNE+MWL81a015+n7v0tgbnTa6iW5qKbnGX3uqZe3tb+d1B2O7yL7zDPeuWOsfaZdmhuRNaSjNcpaMaHNdW5YxYnpW6LDN+eXZclT3VXaANFGr99hQvLx/1wk+f3Gv01NboIZNSkX7BCUNuGEhOG1h1gWrXEJysWZ4/vOZO7/ozaNf+C8frz360aEpw9JAFkJmZiuYxSuwHWeoLsSWbKjYtNmFC8AlG/OkUfkYJNwNT+AITw8bB4vSO7KT6UUNnhVb8dzdaE3UdD96wwXllw/SESkcangUjBrTg5KFSmDppIxyO0GPbCNXryHgGcIvTFBwTNW9+puf9Vzb1xK521/jivc3zMn0ZQ8sBFOlDQq8YEO+OnZSgQ9/m0AcKDW3Fw9quvNB2Q90DP35zOoFswBD2zZmRXOcwBYnv4oYriFuQtOch7IobFkkiUWwMS06F6e0MQY1XlxVNqD1Vv9ltP+waEzvr0j628VFl7IKaHLdsWkJNXmpLbqp7ZpIrN7lpZlJTdoJrRkJjVlz9tPiGmUmN+SAZcOWmsN+6cpJdMxMbZyQ2zEhqzE6oz0msz01smJnQkB1XP0NTNyO2LiexwZzcxL7ahOGwMEziLtDcTcpASx48jROvelwKRGwJMFLbmpPQMDOxITe5ITu5Ljel0ZzalM82bXN+aos5xc12NSepaSb7mtKUCxvsW15yU35yc06SKzvJNSOxcWZyY57WlZ/aaNaxry4zPs5LaWR372nxK8ar5kzTLdq6accvuY7Ycz7Y+NVlQ+wZUQvytG4gGFFRrIhTbCZ4R4gJ/byt0YhaALxYInEUiHvZ3cxpZCcxOC66zLvwji/e/y06CTtPdn781tcZMaUzExoBDRp5kBJGJQHaR4gI/RRsnoMxsiEwPbF2im7+Z29/1405SWfFOFcAoXTisPzOXXLFn+TKvjIJPqGBMBbTJkgvp4JUdxeHeUrcPMnkwrzG1QjfFypw1ZTTzd0Um5Q4NUH0gct/LDQf/twwRm5EVgSZEPQphQ7GMEOD6FkKPVSeONkTz7CrvOwP4cq+netGhz9+/Lw69Pz4tePY/vD793XeNEmqGgqrDPX9ZdfQMOAuSCPkGfHNSq9sLG4avn5BPrpdDHg7OZeO/DbY56rJdUlh0dklEG5Slk4IDcYSyJSVza0gQ43wqlHiKFSgF20aKjVHgTsOuxy+fP53YJvEPp9efeqt+ROarupbnJvsnjVsjcPQhjJRvzUi+OzaZiaCCrStXJCpuJwjHwgfuqk+W6qXVRXQgWYKsRJnqmZpdnL5rJGNtzc9sf2HPaddQ0th6cjBY1+8+/0trkdzhi0eHe3MGDInK6bCoffMGt4ByDCtvTi93ZnKCscAX4Q2YoIF7Z4edLDjVWWtC2/f9l13in5BMrri7qv723H9PpSf6jfrgFKwcEMIwl2KUaogVKH6BP9PuyhWspMaJyaVv/Dgu6dE5nSe6Dy078jeHQc/ffO7u0Pr505wj9XMGjVk1pToZQU6z2xTW6EJ7Sj1Ij+aQsMw+ZpyrlFF5okAQjK5IVkpicSwcHSmteekuMepFi2e5t3y9Y5uPIDdPliN/t/Bp8bHLM6KrS0ytVu1CKVSQVFsQ3dcTExh54h6KUFw+zPbRso74VauXFmKLU8MEwYLje2sUBs9eE51wcqfunUiKePw/mN1RWsmxCy0GNwogfPZTX4rZX/ryfbDbxHaQotIIySZqFX0mxGyLUzrmBpXOTVlyarqh3piV7tlSJLUXnFvZuryqXE1wI8Bww9LS2YlXwHeKQgWnMYAu9Jnxtdf2idnw2Ovn16u+IYn37i4r3laQq2dwkiUjFOjIIdFVD2HECbaJb8IfwdLGzYfJqoWF4+vOaUbGnun27bsGptSlN5/2lVDHddrSsckzB6bMH9M7MIxmvkZ8fPHJS4cE79gTBz7yfyMuAVj4xeMjZ07Lm7e+IS54+Pnj4+fx7ZxcfPHxs2bkLRwckr5lNSyydrFU1KXZGqXZaYszUpZmm2oNGtrpyfWmFM9jsiqk+iGReLO3OXezmWo2DrL25LhaR4G2yaqy7JTK7J05Vm6pZPiy8Zr2M7MZ9v4uAVjNPNGqeaOip4zSjV7tHrOGM2c0ZpZGbFsJ+eNZVsc2xaMi184KXHR1KRFU5IXTGF7m7xwUvL8iQkLJsTNnxA3LzOpLC+t0nF97fate35ha9yOrXv8i++4YqBzRkoNu3k6TcD7ia5puhBEgqjIgOV3MB2XqtLqG3HOVn2oMH0VmwaTExffveqZ3yBWZ9e2/Q/f8MLk6HIUiwYoPtHGDz5oNxzEZBoClP2Tm9w4TrVgwdTWnt6xXjjOGUC46eXwrVPl5X/AqAmKekcAxqpPBszIOcYtQCB6yaCtKAYDulTCdl8AQs6cEN0nIt2af5YsL2xmNKjEi/l5tD3+ihffgEgRmmIrI4OpDA26oqSlf5DL/0teebH89Qbp0C7pPBo8P379YJ/knSfkw7vlz9aH20ZAOkX1n6XGwZ0tmk5yLSJPXWS2FadcYO0axZpIcwzvs6XNrSFWXG6O48CvSdCMsCaikiJGTdRMS922/D9L/MJRK96kvAXRTddRNIOCxMzD0smy/xt+fKm84yxz4f/X8fZzH5ZN8183cF5uorvQGGLlsl0btEc+UL3EmViV/hO9YAi11J3CHRotOs4Q2rTAxRUYQ4XG4MxE1/io+VmJiwLz7/j8zW8PHzhy7MiJX/mhC7RhZ/jYkeOH9h/54att6+ofmDliybUDCyZGL7TpXSUjgiXDGP5pd/COGvrsB596m9YDxfGw9nHRi9tX3H2gW51RGCBcWXHPVQOcVnTyyE8FhsHMhYg+HsnFMyS81I0jihhCg7RC7M9Orh8bO+/J2147sPfIqR4WdmDZkTl+9AQ7Mpu/3Pbgmg0T4ucNvyBn9MDZOUkNJJeymTDkShux26E+Rqvw6FMcBa0kZMVuTBsFwVEEnLFtSnzVxJQF7cvu7cYD2O2DHQHXnHUjh8wyk14OVwTo3dkjVrdEAHo4401GMkJ4KZzrvSLQDM4Rm1oF4P0QLBrWPkW9PMdQead/fU/sPzufrQtvzIiePT25zjGszY6Z2kR0UEMUGU6Qag4e6zgTziMooNj1EEp0GNos2paxqoULZ/qOH+2lJMOxwyfmTHJPillmSfU5DO2sUkc066WIFJqKDLw5jdBbWDys46qLZtkurXnvlc9P7+VefOqNS/rlTUuodoCXacimKA/FMaSmPos+0k9o5RCCcGOgwNTBnjMxZnHpxNpT9flgz9+zc//eXQdwO8i2/XsOHdh7+CBt+w7v33vowL7DB/YeYj/fj1/ZY/pV1w2es+fQP/3w4L4jm7/YdtOKRzITlualtKLsMEChHUQS2slSVUcxm1wQi/clijNlaBAAYYExYE5pytYt/eGLHexV2D7s231o/27aGXxd/Mp+uI/v/7/uyWF4U/uO/OvP+c6zt7nn0OGDR3/5AQx3hrdv2TM5Yd6Y6AX5OjcIqkFM68fPKb9NAPiI2QwJgHVkCBQQMaQ8HgM2OPv+qweVtJTdsnvb/lOfSqc2Xnvu/UkJ8/IT6xz4ugKvEjIHmpriKFEszfazdbKm3HpN1eYvt/f0jvXCcW4AQqlT2ngz2GDU9INaEzv0MMiBd/pxAoS7ekZhRjy588d0uon3oEgJLgENi56rsEuJmFfJzaKHivvvI2eIWfZYB6slpVGwSxi3RIkXYKERC2xJ/SC54gKIF2+7WProMXnH55Avfz5U8PzoxsFg4fGD8rZP2ATrDF0sVV4k1fSDEIiWWG7+6abszdifp24K8EYRKS7eVUtLIdRJG8kqbOKZKzyZ0CW8ZJpJiSpCNbtmtHAKMVoWFyN63kTTZdXZEi/X9pEbYuX3HznTh+9XjS/f3VRpaZ8YW56T1FxobLej6YtFF4i47ekV4sgjzDwxYFDP2wUtImwds9F8TgO0srCijdUW46IWT4kvW1v94Lsvf7Zjyx4GVLp9/ztPdO7evu/bz7e++Mjb7tJbpyYuHB81LzelzqJvLR7W7oQ+HHBGAbEovDVoenGmtWWoFqxx3X/8WHfuz04GCFfcc83AIkyKZ/W336KlNA6PDVsZuT2J8AIh4GHXCbN4rhfyTU+sG6UuffK2f/xKvNp5MswKtU2f/vD4rS/lj6gcNWDWjPhqDArD0lDHGQNuNwrGsMKOQucXmdfkOMoRLO42uu2b2rOTXaOGzCu6znX4wLFTNdz/zcZt3kczdWUTVOVOdEKyIya0cN8dj9ItxnO3tQIGA1D0KBEpdsEQKhI7yEkHpyVQDOYkN41TldUWruuhg/Da+g/KsvyTNOXUPwaVK5EhwrMXuwQxCwHzV1Am1zVoEVcZoLIMOo3Biery3MuX//2J7o/K6Jbx1vOfWS+rmR5fV8AQmjEkMBjRJn7BtAcdaR0M3zp03vQ/5T5044Y920+zggfJ6EU5WYnVjrR2G9nVCFNHRAtBK/fB8lHvsd2gACfqLQwWpK1kz5wYUzZrct1pmM2yKSN1Gaf3Lv7dYMDmNtcTE2Lm56a0WCOiYnKaIZMYzgeKJHo/V9djY60DmfCitLbc5Map+vkH9x75zzaqv/FNgH2UPHnb3ydpF2TFVwKmNUE6LqUg2jhV7rVFrHE4ICRsH2kKRYk1mpwF2AfWBNUyy+W1D9+8oUf3fMvX29fWPXD9gBJkAoM2AudKDyQAQg9GU4LLEUOM0xNqpiQuds+7tYfcjHv5ODcA4a5N8pNLpdq+wDkg+pLcDNTFhn9mrkhVL0A+yAAk5wyufIsVLVJKVoS6C9fXJZaQWq1cajKqkTDvO9yoxuej+b7w2UeGUDwN+xhl11C56kKp4g9yKE1eXy1/83fp2AG5t372nx9n/ZDCbIJJm/4efqoyHEiXKvtI1RdxchsmPNrkoguuEIKirBqyKDSysFni10sTmM2EG/kKiKSskgjGTzjTqLivTBMHh8rVBE2JXImNZjZwjUSL/HqQWHe2aGRYK/mz9EJAPmvtRvfv3N84a83kxCXT4hrYJ6ITl+RZccmQDLciUHozsPPNIrITIgF6aIVCPXKotYP+B4cpOCOpcXzMovLMtmfvfW3Lph09AQX/aRzaf3TTxz+88OibN9Y9nJ20bJK6LDuhnr2FAmPIiS5tYI0DkQzweGzM/Js8D3avOmjXtn2rq+67ekAhAsIQAEIdCcy6pE1EksR4oiBiRY9iB8KKlRlJtWM0pU//5bWDp8gQ/ruxb+fBjc99tGR6YIJqYXZCndMUUFgvCl4TVKFP8Z/o2kkovCu9Skq70xhip36ievmU5MUvPPhu72xrOXHsZH3pDSMHz81ObMAUEI5v8d15+Ps18sYwCEoB91dPl/fOlXVKFoUiQoNUa4hgCRSktbG5ND66vGSs69tPesRrdP/uQx1Vd2ZEzcpNdmE6GQSZ4HlB8ZsxYOFJidTt5he+vpHATyWvvMDUNj2+epxmTn3h2p7Y1V8/GpxrpiUvz09pLTCtZKUwQS8RKsMDZuyGIDC0hvYp6hVXDbZ/sPHL0xafP//E6+kX5k5NrC1M60AqRpiLEqJAL1NyIiHhqCIWhW/BnzNQSIBQUzZrSl0P9ZGe9mCA8MbaR8eqZuWlurnGVU8+nDgrtJTOx2Mt+EHWkliaAGGgwBgsTAvNTKmfpJuzd/vBcBgECL1k9Yftxd4dB0ozGsapF+Zqm51pIWoXhOUSHS2u8SQk7kFq9IsUGaEK5uc6QBp+doswaz2T4ssbZq/bvb2nbDzZ0Xv2vlfzh1dNj6/DCKWgIAa5CzSdIAwTQptovWe8atGCTM+nb3/bQ7vUy8c5AQild+6RVl0t1/cHYrAFGTnQpxEgJEMLDWcqoMdJI6wURfo2/JBXsdxr1KVWGgK5hUwjkYH0VVTDWOx2NhJ6xFQ3l5L3jUSlWw37wwrfugHyij9JVX2lv0yX371T2vXVmT5m58e5MqSdX0pv/qXzhomdyyGaQmoYKGMIBDq78IQVaPxrVotZrZG7iqXd1FiokhpVwmU0Rkx+xYRJCTNEDXazuL6Ib3cJktDNldjhSD4hhFvILlUnrJiopKoLpZsnSZ89e6aP2ekM9uG0tv7uySmLp8bW2PQhu74dIBPX1QSVaoxSJSyKIzmHiL58LWxmHQ91oDRCB6ZIz0iqm65dvq7h4Tef+/jwwd/U1fD4sZM/fLX9iVtfapl9+wz9cgYLc5PAdaZoeDsyJ0GbsY3V/eM0C24NPNq9L80A4Zrq+67uXwAx8eALx9BgEJefFWVmJOnBwsPuhLMota5hscIA4ShNyfo7N3YXIJSRLXzrxU8q8trHRS8A7ajJb1Myx4wRn3oRaeDh+F/Po6jtPIWMh6EjhRLMTmycoFpQbV5z5NBvmt/1C8d7L38+Z7xn3NAlZihzA+R+BJJRQH0eHisHzaVB3h8YQcIi4o/P7Qg8JkAIUWaYXeEASBDKiquaqi2/0dVTSoHHbt+QN3z55JilDtLFGf3cHJXcTQjycWk3WfkrPigicAW5NYehLS/FzepL2xWVe7Yd6FVRZuHO8IE9R3LSy9nkZ/cih7EDtZq08xgEL3px2cQrNHY4DcHrB85Zltv243enb3W74ck3hl2Yl5lYW2DqwChCEWrKRaHoHGMI2ETfoEXv7yoftRuDBcBVBibHlpVOrj1Vl9GeHrt/2reu5uHR0aV5qS1WTFnkmmcDd6Pl89kIxDK7JdqUmxIsN0D3NfbKhrIT6yZoZ+/bcQgAYe96i/Ljt72Uf2nlZM1y0tsTJoQL00RBHT6eLmMUahfU5PMLX5xNOsvsbBYOa5+RVOO4qvbBG//WQzv89Yc/uOfckhG1yAFONiFslPUpEZGoiIbLmQBhQVrbjISarNTyNXX3nZv0oHxOAMLOE/Iz1VLdQLlhIPh2NseInqVIxDaSISoiAyOcoegnBM2nmz9WTDW6Rkpg9Dzq4poipouR/9CkqFLVsqLBA09RiFzDVIn+csUfJa8u/PAcedNLvydv/fPj7BgnDoc/eabznkLJp5erLpDr+kFiYbNK4npODbeWwXjMSKMsrowIqScl3as4i87ZP3Ql7do9S65L7si3P5ekajDFXvVPgBDYdTc+rX6AVD9E2uCVTp5lLbVHDh19/oF/TEiaN1lTCZG4hnaLFtOZdWggDlWyH0MReBCCWfAkFpEuaIbNT6kJFAYIBZPBk51cZxlRd3PTQ7u27v8NGvT/x8Fql8/f/f6O0BPzJ7ZmJS7JilthNbQ604LYQNKWl+SeELfoL21PdO+LCobQgU0gbQgIIfqCp3ToOWbmgBA9ZkCLfylOxgAAIABJREFUKxRcFk77+Gck1o1UF62/641uBIQyHpNX17+7KNM3buhCi64FfBSNbDc8ti7aYFskmZ0QbCSsggChmWRXcBhD+Smeyaol0/SL92w/Yyf6P4yVVffO0FZOi63DQh/nrRA8Y1IlaXcDVvKf4BSKT0GDti7IUDksdKywlw9Cw9BgJpSb0pQRvbBoTGPnKfpM/sLx+XvfNs++adSgWTZDq52MRpHxAHqQJ7AFhPNNQAEz3ICUIvt0ihIykBVfMzVl0ZO3v9KreN0jB489e/fGyQkLLNrWwrSVrFYm+xYChNSlzAM29SGnoc2c0nz9kKKXHnv78IHTL07QZTQ/M77GYeqAO57er7jIUJeg2Sj8RbtsFsWkRAc9hAXGwJS4stIpvQ8QbtvPAOHIqOLcVDfc2Pn78nH5qFjaEypxr41nzVMSKaS6O9MChQyTxNeNS5m9b+ehXrWCQIPt1QpL+3j1QnYNOtNQ3gKmnUFFFKqw+vQTqynALh+rkO6bMRERUSJQiwwQOkzerKRl87Oadv64r9v3NtwZvn/tX/NH1LApV5C+Cid5JESRa0eNJHD1Yfymd5xqwdKc4Dsvf9btO3O2jN8/IJR2fyvf65CrL5Bdg2UPEhQ8agK7BF0qHgXhigZikLtiaNDKQi2S01SdTfRXnBhUtKMobyOzDUyZ50HzgippFp2E9EwRQohx3irw028cLNdcKFdeKK0dLb0clPZ8d6aP1vlx7g5p59edG3zhNaMAE1b2kRsGSa6hQimN1wjCOS4BjSQNaihIk2cYkvdSxFY3Fkl1tbigVHLkWyHYFmpSpNCjwVy0CUMOm9glGS3jFQqaaqAKB8uVF0j3l0pnlbXM8aPHP33z6xzTsjFRi+3GNqdplVXfZsO2KDBEAcM9HqeOwQOcLPqnzYwbFGpavqyen9qSGV9lvbzhVvfjxw6f6A3rya88+V5jyY05I5aPHTo/L9XlMEFc4cz4hqlJZXevfrp7XwsAYeW91wxyojQLwsSgCMPmQOKaONfKuSay6iH2JqLuY6VYdlLdKHUxMIT7uhMQynDeT/71/tdmGJdNUi81U+4CpUoYBPATkRhoiBpZt7YKyJSPXWpYcoEmNlNTmRFT8tnb35441ovQBRsMJ5RObBobVZab5OYFPZpVckWlVlBnehE3p+NqWJFEhxhYpLQpB4EDQs5CQNuSE4CEb3Ls8kzToi/e29wTusHjR088etuGkUOLpydWO9Ixz9MEuds2Ton4yRXTxndVSVfnJig4/ThtyKrM3JTmMeo5pRlNh/Z38+z6NWPnT/tmjWmZllBRZGwrMq1ityALb1iFd2Th+JwU6W0OQyArriLbtHjfrgO/5h6zAUxlzFnxtXZDG2+85E1lNB/wXPPQnYBCKNkUaxkdSEYLTAgIJ/c6yeiun/atq3r4uqGFealuu7JSoPMT3Uo2YDwriF/4YsKjTTSbYAxiFaS1ZSfUjUuatXfHwV4ICNl4YN1fzZfVTI5dgRcFZa6EaMXknwEhpVCkCRMXTrBzEhioRVOwZMSqHG1dZtr8R255odt39euPNlfaVo6NLoM0S/Yhy+abKWIBBY5QOuVO63UYg1PjKqYbyh+88a+dJ89RelA+FwBh59t3Sh1XytUXyu4oCLkWHIVM9CB1NxEgbCLz/dgwd0pEWq+Z2v/UwnoRbTDgryKhbaAyJacZYlR4fjdXnFIxTU6kvKqG6jZKqusvV/SRawbJN2VI2z6QT/ZGIdD5cU4N6cQRafMb4RvHQP4Kg4U1/eTGKI7QiC2P0OC0XKLhnklNPLyeY0K8amANBZhzcS24+PoLJwxd3G5UUsLu8d8iboyWmzgylKFrUQWSbPjtUACEoUvDb9x2pg/VKYwfv93evuSOi/84J1/rd5o6rJD3FYQFSx1GPxtpmdzH45vQTsai9Zi1HqqTbBFtIQTZoWtLMC+1ZXpctfXi+tu8TxA8ONVgrh4au7cduGfNs+NT51xxkTM/pZXt8yTVEvOlVU/e1c154hA7UXXvtYMKQfMT4VoDVgqmN5DO1mtOJb0ibVQHUI4W9CaxxzMSa0epS9bf1f2AkI3vv9y+svKBy/s6wG0fOmeCdh7YxRtBFfMJrm4VKEjQC+SzAqyUReefFlc3cnDJE7e+0r1+rb9+vPPCZ9mXrJioXgGZkBAL6e/ii4sWozq/mbSgBk++rtWS2mLDSAmMhybEJSCW0m+JwRtsc1B4tCkECdeGYFF6W25q/Sh1aevs/+6hYOvXnvvAdlXNyEGzC4e3IQfiJ+0oJqcHeGY95zN5J6FwnQEQBRGLiAkdxjaLzjNWvfAaVeGWb35R7NtvMNhubPpky8jBhXkpDcVpK/GOFCDjJauIzbAgYreBjq7drHdPTVrUMvemo4d/VYnywlNvXNzPMh1bTPE6DViF0YhwqiTOXDgP8avDb+FPCBQNW+lMC06KKy+e2OsYwl0/7WeA8NqogvzUFjIv4XpvnTA3hsMLWfM0yc2KVpbHqwQgb9MUzE6sHp9c2msB4YHdh1sX3TZ66NyZyY3ONAD2dlip8VsVBMhdZEg4SmmEgmNXCHZoPoR7dfGwlXaTb3zswpzLl+3bdagbhQ8nT3SurLx7um7ZdDAXbbcIIbTCyirJE+SIk691Xz+kuKFk3aaPt3bXPpyN43cPCKWTD8zurB0i1Q2WMO5PcQpFQxd0c4m0NpGalEpPDedDmhXtaCRBW1HEoYhUzXMLRQY3K5o7m1TcWJ/iKFp42CBFz8NL1wwIL/lTuFbd+cgcsHzsBav758f5wcfJIyeec0utOnn5RVLtULhGmqPQfTQWMB4qSMkSCQEh6ahFdCfvFSSAhyJSl0qO+MrQ+gv57ooGRXw+Xk2xgmZUCcApgjoJYbqi5JoLpfqB4SeXnC2XzIljJ15Z/84V/R1jVQ1mYLFEhgQ1yWA/CbSU8HwqJAOxkrZoub7RDpnvAcpKsuv9RaYQK+MmqCumpa54YM2Gzt7X7XDkwLEXH317TOzcEf9lzkmsvqxvXvl07zsvdrMOZ9e2fSsr77u8n50dJQCE4DIq2lS4ZJEzhGTkwPtbBCBEehBgZFZC9fWqWevvev1QDwBCNt577fORqqLx0YuK0tpZpUgn0aZIRrFrjieLCECoeKsQGkSHHn+hqc1pCIweMi9QdteOrXt6YldPb0iSVJbpnRizOC/V7TS1oR8JNkZqyXDCj++XnR1vTnJzdmLdtOQV2cm1dn1rYVqoML2tAPAegECGncwEqLBQ452fBnJiFGcQSueQWds6NnphZuqy/bsP9QQxvmPL3r/4nr60r232JavQv9dPzZ/oCUR9ngFaWbCKjkGhFMWNcufwW4fel5/ceOUg55O3v3Jwb6+A8ft2HXzitlevutBuTm12Gki4HqCLgmagXUcBIT4HGlZNS6rJGb5s04dbf6VGd8OTGy++KD87uZFBCDOw3x7OJhn9SlgonmshtiRcoaP1HeCjCtPa7eAyWl4ypbE3CCK6jt3b9q+teigjeo4ZAjbpEsA8ej5D+CqPJZVaAISPq46aisGWGe7wBt+0uKqMxNJdW/f3NsSrjLtXrZ+UPH9c9EJ2scMt1IQcPkdW3F1JhEwCIORqUlhVgaZcuwmSeNi3DpPfaQqyO0Beqmu0uviB1RsO/QpB8j+N77/YPm9i66SocpvW6zR0sA8IrlSnnaRLFRZ32A25rSi9fbJq8eSkeU/c8WJ37cBZOn7ngFA6vKvztmlSTX8gGVpjeQlLXJ8QjmJ1G4seM7g1iYYoknpSNndzjPhVzM+2Zm4wwxPbOGhUHPYRUrJXYTjQjQ/Iv7Gmn7TsD52hy8Lv3AGpEr3s1nZ+nB/yyaPhb/5+bHXGyeV95Oq+ctNgcprhqE94wMjcj1RDjkrhJuE0w7NY1FIjbGTbSysmgiHEJl6u3CZYKILpuRsNKrRbVLJbJbuFvZMnXm4cJFf+Wb7bIR3p/q6Dnhhvv/DR7JENV/ebU2BcRfRCV1dJMOVngJB9pcS8n/2KOgl9TrTTYB+lDoAK3tIRK7PUleOi5j5y84YjB3ujrIDVasePnvjkrU1j4maN6GNJ+X/jKqyBj17vZqMsBghXVd53xUV2MwR5tWHvk9+CNToG/XGdLQEJi7CVI8kWATD0PvFnxldery599u6NPQQIt36zwzv39osvMKOjHQVyBCNNdDoRO6FTMicVyEpqYSqzAgVpHQxSToheZL+y7vsve8Rj83SGJB87fDxTvygzZjnGnyAgRBFsxEmVvS+dz5zSOj2uNjelttVxT/mE1dnJdWatx2lkR8NPdTMPqND7eMXMW9rwtwavcLf3EYDJSqiZEDv/87e/7wn1bOfJ8MbnP7xmYGG+th5BSAhPnN9Gnjc6YSUq8kKwmzdAmWbIEPrFSQSGrSg9NGrInCxd2bef9wry4fP3vnNe1TB64Kzi9DYnmItSdLjXpvVZ0e4YMIwWeE42UXOTW8ZFlReP7oaOzReeevOSftYZ8Y1AoBl8itUKMpMB7iaqpNLDicY4Vm5DgndCEwbTxywunlzf29pod/20b1XF/WOiZuUD+82bBm0KIBR4CS9zH5fLRq56mCocEMavyEgs6c2AcN/Og97ym6+9yJmX4GLYHs6jMQLsu9BuQgFOKTJGiF3lbjRgvAzGqk4wCmpzGAOTY8pHRhf/tPn0LYtoKLRqnWPN1PhFOUkNTmOHTdumrHdQkyou2fBGX+Cr9e4rL7Le4nlk+w+9aKHtjIzfOyD84EGp/VK5dgBUny0aqiwlJfdMEb+5ScapAXsYF6rgiCHkoYKKtYaQgJLCDawXkSHB50csFpvIjUNwJggIMYYemRNWXldeIN2RG/7iOenI3jN9hM6P8+PfjBNHwj99evLhBZ31Q+WavrI7Sm5VwwbzOU52x2HTLM52bBpEx1ENpxCblMsBfGL4KomCCZtjeIR9C6K+JoVX1PBEFk7jq8OUzkLrLG4EhAwi1vaVVl/V+eFDZ/oA/e/jyIEjD6xdP2rw7JkJLSVpa22CYVDAnpUAIZjO4foxLS1DPyGqRjG9zQE8Q8AuZEVmbcu1/UruX/M3VoL0tmXyroNhws/f/3bOBPfwvlOa5q7Z9NGW7v3/AAir7ru8n8MCHFob8lG4KQwhBXXoudW7CAcTbp8ICNlPshKqRqlm/e2+jYf294ib17Ejx995+bMRf56Rk1xrM3qJ7qNqCeSjnF+iiopSvEQHnYgsozKLIZOS9FWTVMvGamZv+uSHntjV0xhHDx9/6aF3xmnmzUxocCDRFDF31XF3Hwv16mg902Nq8ww1L97//sOrX8kxVeVpXU4T1MHIhytA62dOM4DeBfPGy009NFWadS2joma5Sm7d9kOPhNBs+nhLWWb71f0LC9KCTlObjZSivDnQzy1wOEmo4F4O8rE3iVAxZGYUGtumx9VccaH5vVc/P+PuhZ0nOzc+/9H1g4qy46oBvetFYyR427IaPWjl8gQySg1O1VTPTKu+p70bfCBffPrNywbasuNdDn0oknPI4yV8HP+LUyxS6SO2PexiKQBKyjdRU1Y6pbEXAsKVy+/PUDFA2IrxBuJuo/NwnST3TfUpzroWPd4B8MiTBsRp8E1PrGSAcPdPB3pJC8C/Dga6Hr/9hZnGJWMGzitK77CL1EEeHKrHhltE9coD8Zjf32xkT5oWsmMUhNMUtGpbL+9ju7fjb78yp559ILLjtuWrnZZLK7JiK2zQnxmKBL3qqUnVTx+mduxmZEd+9JB5M/RL/rH+/TN+eZ7x8TsHhOGH54LezDVEZpAMqk+NsEkUGfFAdESisSOOiBwHYnXr1khd0KOSLC9xf8UuVvv8P4vep6ZI9Dz8YSMI3uS6AfLji+XNb4JS9Pw4P3rxgJvr9s+kp6vkRpVc1UduGiS3RMstalzdoEUT9kC0FyKjHhZBLFwyCnSfSvpnQCjsmtwahVHEyBYeaKFsgA8prrMJqUJPHGDChoHwrx5ddKYPz/8+Xn7izbnjWsZFLytOW1NgXGXhfu4eJSKP1cHgfaJVAhJ8FtFRhr9CQGjAxWN9oMDQ5jQGRg6aGyy76/svfuq1FYMyWOnw/qufl4yruiP02O6fupnRBVOZ6vuv6O9kdZXT0Aap9NqAWUeNXsLknaztRWyjJRVwoEVU7VS3TY2rGqkq/es9PdJDKGOE14/f7RgfP3t6fIVN76FYZBFeR6lrlFnPzSdE/CBVTpxFZEVMQVpbSdqqqbErruxn+/Sdb3pJi9Hubfvmj2udpC6zpHjsuiAACS03F7VxtpamdMCa6s2KqbZdVv/jpt3ffrzNennttIQqZ3qgYFib8Nfh/TxdMCE32oGNF5dYw6G1TEbU/LFxi754//ueWBY5sOfw+nteT/tTtkXX4kQ/G074KIo4vQgkFGaqFJhBRvYW4SvDnumE7kffFX1sbUvv2fzVtm7f1VMaP36765amx6/vV+yEuwoZ8fOYB1yqCBDzyc4jO2Vmbeu46LJZk1q3bPq11I2MpjIXD7DMSHDB8o0eeT9qy1RCJhAQ2gXRKmxIfUQ6gaUQQ+Z676S4JbMye8pj9rQHMoQPjI2ebU5183UN3heAM1nr57NFyNctio+uvgsgNAZmJFWPSSiGnJJe9ga7jh+/3bG69u6r+9tykl3YQxjkpkqkphY3LpvC9+LiF2FCflEjJsTYpIAzLVCQHpoUvSz/koqP3/r6V0L9I4ePNZSszYovz0tsdhjYhAnixyutuEHbhYPuJNDiG2Tzf2ai69I++feuenZXd39CnY3jdw0IwyfDN2TIkKsWjWgQSUIi+njGoDrirY+1KQVLkPkhuWX8s0yUitRm0XAIWFEtCbFcV+tRKoihdG6NBaKjbrBc0UdqjJKeqpB//BDCMM6P8+OsGNs/l59tkFpT5co/SY2DoCFWaa91x8q8e1DEt1D6fMRxNIbEonIX2xjRfxjTpeeQHsTieg22C/Lf0rXGl2DYpSQxQOgaKlf3k2+aKnX26vCJ/bsPrq6+d4K6PD/FVzJsjV3XDgSg1qsIGoEeTPWYERMq1BA1nxBENGOAG64cBwsNIYYJZyTWzNAv/ej1r3+D6PluGZ0nO195+u0vP/iu26V9kENY8wAAQughBIYQAaHPKsS3BAXNXToJqUQzU+1OfBQwhNUgGe2xHkIGV/bs2L8ib+UkTZlV63EaQpwSFLJDmxCS2fQ8qNCioCADp9rA79HUVmRaOTOp7pI+ue++8tnJ42d+Mfv4sZMfv/nNNQMKsjRV1lSUUKKfioVPY+qQBHTB6t28JHeWpnLBxACbCceOnFiUFZgSt9Siby0Y3mEzBWxiNYQ6r4AwVNxHI1nSPkHQQfWcFV9z6QWFz9z52oHd3d+bF+6Uvv1s6/Wq4qma5ezaZKAOxd6K0JGnWnPrSG4TIsItlcZCLP2h+S29fXzU4uy0JW+88NGZJfXfeP6j4uuaJqvLi0espGQ22Mi1BYWjQsDM0FfH9ITaifGLWhbc1i3ghAHC4f3MMxJddrwEzEIbTAwhfvUKKOgTjaOQUmAnBSnoI9rsBu/E2LLSqY29DS8RQwiAUOvGlHavNZKy6LOk+gUryGOELLQyqFPsjgPQYGzwT0+oGpNQtGfbwd72BruOcFhid3XLZRUZQ+cVprU7gEL3WyKNvhTK4osIgDkmDIh1LuIMA2gTBTGGDBA6jaGr+xfc07F+54+nr5s7fuzEF+99PzFxzrS4KhuGpoCNLd6FhCcquFgp/t5sgo1TLbBctuzLD7/vtRrd33L8fgGhFJYPbpPbLgG9aFO01BITdqsph5BLN7sQEWgwo+Y9gZwMJO9E4ADDTV3iBLtEC0KpCrHyIGzDIhiD19ASI0wtT24UxbGtIUquvIhVsdJTy6WdX7FPmzN9dM6P8+MUhrTnO2mDR/YZpeq+kmsoR4D8UtII09EYSfGSwQfUOshzWcjRl/hDQa1H2hHFRccJfJH5qRCPuI6jlj0ayRMLVGH1RXLbNeG9m8/0gflP4/W/vr9gUmCyurrItLrA2OHQt1t4iezhhJWS2U1pE/gTM24IZjiwcRoChYa2AkMoN7lxStLCe0Lre5WF/f86Ok+Ge4LO2r1t39raBy9HQIg9hMGuEWrAr2p9wlcGSzEuHPUJSpYAoXdaIgDC9Xe+1kOeHwwQHj5w9LGbXhoXNz8/tbnA0I7MJOf9ulie+pQwA6vwlbXxrEIkmoxtxWmrLClNl1yY+4/17/eQweYpjR1b9tzS/MQVfQpyk5rJQkZJXBC8maAHdf7suHqzse7m+sfob+8Mrc8bVjMjqb5wRIczvQ2IU5j53E0X10283HFUH1kuUTY7JrWMHDCv3nbT1x/2iIB2784DjcU3j4qaladrhtS1iKZRGEhSw6cgdc3cLCpg0f8Mvtqh6m0z61quGuB46ObnzqC1zNFDxx+68fkxQ2bnaxsL0tsZFARuB2nqLoCQtL5+uyk0XlVWPLphw8NvdcurA0PY35Kd5MJCPMAbRIVImO54dk66Rg6gDVSFAWILC6Cf0ztRU1bS+ySjDMa0L703Q8WOrdtm9Ft42KlPSIt9ZCxM61P83ZGjGHzrxyZVhgn90xIqRycU9nJAKANJuPOmpoeuHmAzpzbBOTJyo1qLCE8SvjKi9Zd/6xPaUWD7Ubfpd0B7fHDOpWvHRy+aleF+84WPT5vz37F1t7/89ozoubnJzXYyTELSGxYNQVaAAmne6Ajxv9kprqsHWx++8bn9u8/r9WD8bgGh1Hki/OVfZY9OrhsINCADhLhRxLyAgjG8PxD8PwnjxfLSFvoDCdQxJBlLYWv/nDWPmrewSNYWkdwACCnqEGhJ9m8bhgAabFTLD5XIB36CNvzz4/w468ahnfLfQ3Jrqlw7IMwwoZswoYbS5zHJE9dEXKi7bqZlEdhkhTxHi1Fo00XbmHAXQIj5hOTQq1I8fnmGp0tYNMEFpZZbNbInVqofILcaOj967EwflH87jh46urb2/szESnOqr9C40q4LOQ0rRfq8hyw3eLcVVcB6D5lqICBshV8ZOJJx6ANFpg4GHbMSly6Y0nzs8InztxAZbf3WVD9w+QBHvtaLyWYhhglBpii4GmJZu1TnPpJp8VpNRwvzvmngMlryzB09BQhlcJo9+ekb345Lmjczud5pCKGpDM95ox0z6xVLIYrh9ipNdGLzOY2hkvRV1pSWy/rmv/DoWz3U8fjLB6vIP35rk/mSmvGDy23QPRjExXi/mXxTFQdOBteNQTalJ6mWzcvwsuNAf/7DVzvmTfJPiVnuTA8UjVjJrwKdQi0KMMzJFpHiLfSZNgipb58WWzslccnLT7zbE7Hv7Kx99NqmUXElWYlVKFglqsHH8apWSQqJiJMxXYP3CSsEEdAg+lDJ8FUjB82pL7rhk7c2dfuu/sLxxXubW+bcPnrQ3II0MDeimBYQLWOoCZcuo7Enq+9zU5vHDJnbMv/mA3u7Z/nphaffvHSgnQFCqzGIqaEidMHAF27MXGrYtY8UGn0xxZ7B7ADaWnonxCwumVzf2/ASA4RtZQgIU914SGn5wCesZdDrGDcFEHJFAPXd6UEGwgBhVlzF6PiCXi4ZlfHy/+Ttr82XLRszdE6evhWTJPxKmqVFQL6fwUL0HbWbeGw9iUgBEKKNdgm7Cejd1/QvvKX10dPrJDx25PgbL3w0MrogM67KogV60KbnBLiFwnuAFeQLOuymlK/zjI9ZNMUwd/+eg725G/+3HL9fQHjiSOfTKyC+jOGxVg2gQYB25Jiv4bYWtDUJUsKFOJCkbug7ij1R8Ff8mZzNABowDI4X1BCl4VJSNyZMQCmskRU7mcahclVfuX6o/ECRfPL4eUPR8+MsHieOys83y55Uua4/9uVqeDOhWyMLSpAwIQVOoAGvitSkipqa2gXDZCpDZk7KAg3APxWty4QjQS9qWsSBC7MF0aAvXmoeKjVGhR+Zf6aPyL8dn775RUXuqixNQ5FxdYG+3aFvLzB0WCNiIc6BIAjEJWSM4aL6AClED/ffM/goe21GctXMYWXP3vXamX5nvWXs/Gnfqqr7rxhgYwWW3dhuZZ/9AAgD1J/D+wb1XnNEu+i1iK4eBlrMWt7KMi2hZmRM6fq7X++hHkIZQ7E2f759XMq8rIRqKPvAJ5MXgrAnOg4tIlGERq9VNNtYeRShj/1hkWmVNdV9+UX5zz34Rg8JXH/5OHr4+PMPv3FlP2dOYlOBoQ3ZnoCVMz+ivw77CR3GUHZS/diohSusa04IpWs4LNUWrZuoKTPrW4ouXklg2EY8OUhGOSbk1C7bjDxO2sqRPGamGwPXDpx9m+f/s/ceYFFd6/r4/f+e595zbk6avdA7U8H0bi/YBVSYPhR7QQTpnYHpgCW9mZwkJqacRJOYoqmm9x5jYmKMJvbYC7P3f33ft9Yezj0tiSCIrGc/PDgOsGfP3nvWu972VAfFAwZaJeNNpWPC8jJVDdCoATNLD7f4qrlb0siDRikKyKP4V80CwYLAlc13L1ueFlM2IWbh43dv7Bx2S5LX3vpimqZocmQJNqDA0QPyDRvhFHiGKakue1LzxPCiCZGL7m5ot0U3KKbvY06PRUAoLGeCKxMxlVrRYy4KHo2c4WHnlQ8qQDSucRFLciZWdZFSR2Xs2XnQn/fg6JA5mDLqIwoUV6bQrhz0E7o4k6amb4BeJvcmu0xACM0AYYy9K4fKyKh6YOfwgd2HHrtl4xUXz5wSU4ZvnNcoqkQtVDyoIUAIKw5mvRcV4CJaRumigMRRr1XvZ6dizhXLRw+aP2tE/UtPvPcHrpHt3/zsL3xgxMC5eMX5wUDI033gNkt6UWz9gewrBghT48qHh9qWlz7IkGRHHKVzcXRbQCifONR66yipop9UPQj4usZwqQEhHINzjoigwk3oRQkQcscg90EJ+5OjbdWEUiwRitXbkbxWG35PKEx/60SMvjNSrg+B6vni3tK9cCdBAAAgAElEQVQDJqiX6Bk949wf0tNFsjMecker++OFE0nhSQG6NKienqfsKtEyYUr7vBI2g7gROfm6SLDsip5PwIS1gsaH7kHh8mW/0Bklu6Nlb4zcGCpX9G5tvqmzD8Y/H+zjsrn4nhnaMmOCL1u3is1cbfoVZLQwKSmj5DjCcDYL0gsGLJ8w6VyKk8qMTEj2Zc0zEmvGRSwozHT1+ByUsQ9DZW7obzPAnIOUbz6KbTBonUZ2GHUw3+KJAmoR2IOL98DIgTrRw/53amzZsIhZz3SYZFRG8PPr3qMTtIumxJZBfYjOh4sCHoNiMVJzepBMONRcb9JwRGTGKkKb1p+lW54ZX3/tpYbn17x1uJ14mz88tn2x07/kgWF9ci0av03jw+msz8xTfDgtQKibPWFyZPHkhPzm4ofb/oaHVrxguapuWnSldYjfoG5QUmTE+c9TN3gji+imI7+ZGSrymrIvWzF84KLcEY7Xn/6wg17mg80bJqvzJ0eVMtQE4ERLOUAYxKLyoE8JYaGKGhSQ2ITzys1zZZAzsenAImVL9gzrP+tO5+PHj3TCBJT90RUVD40YMNeQ2IBtH9RzAE4qeEVcwAzuQbPKa9c3jxwwL3+y990NX7TXDjBAeHlvw/TYWnNSk1E0wdB7baHQID1vq6cAIaT63UauFvYZGCCE2gl3SuSS7C4ICH864Fvy4Ojw2ZmqBhOa0+CWruJBx2YuXKcAZJ4aRf5JIp/NcAWxF+iZFlM0PMq6Z8fBc+JWv+vHPSMjckeFLshUN1j0PpNYtcFrhKM+RPvszfWYhGjfjOjRRG83fOOzJkPDZM5lyzPUtcMHzmop++vvVUC0nm7d9OTbQwfnTk+ot+tWWKH/xgvtKRpMNNVhEpUWejXNsETVlJHoGDV4rvGmwnPFjX92RrcFhNLxX1s9l0vll0rVAwC2NUTSJDWghMrw+Aqlj15whnVCq6ZE5DvC/25qC49HIRMSqgjhZGifD0XCBGM2GpDfYGhw2cXywznSkXYI6eoZPaNLjFPHAi86pXqVXNRLcoQCNqvH8CQi3utEnAyyhTJ9pVAZBIpSW7MuBY3CdRcmN4QpSmyeLCpaXhSfITxeB9EyEHZaeonUmCwH2l8qdubj2OHjeTM848MLoG0JghAovMFLBdxt5v3sq1JJz9NHKcLbJIRzVk2TWe2cELpo8aSGz9/+rrNfWRcae3cdaFn2wLV9TAYgavxGFa7KU46flsroRZedmJebBfMgyBDw8k2JLh0alvP06jc6DmJJAengniPTNAsmRRZBen5Sk0XjUU4DEFVSO5lWwYFBMyEPm4H/9VoSfcaExisuMmx6/N2j7Vfi/MfGi4+9PTE6b2pUaZauxQaiPg8RgyJgkGASlX15xoUsXTTJ9+6LX7b9Dds+/7nYdHNKWIE92WcOdlS4jKKYEd9HSpt0QVyNhhuxKBiTXVM5SctnxlUNH5j94KqnO2gCvfvHA8abyibFlNqGNGMaCq0sUCqmixt9MRdENCWwCbHPmEixsZClCeEZWj+DWOyb4QPmVGbd8sW733fErv778c7zXyyd2pQSko9sjAdLJrxKcCsmmngZMLOqIc14Rmzd0L659zWta8fsoo3r3rrskpnpMdUmlKoiE0gBp0CAA6ek9xJJiAcTCUO1UsTCTjA8hlqQjGaPr+xqHkIIlSl65Kb+9swEhylYrYmMGSz8ucxCG2LilzYynyp2hkCUjkXtseq89iRPWmzZiKjscwUQHj96ctNjHwwPy5oSWQrnud5LvQ7cN0hvsZoTvzwzmW5uOkESUrAWmgltSc0M848PX2q+tuKx21/6XXuyY+ue26oeHzNogQnjoy28dx4pSoTcsCKj8doRFmZftmJaTNlUXf4jKzd2zIE5V0c3BYSSJB/Z11odI5VcKNcOkhqjZAKEUA0f9fcmQIyvqFMatyOEsbBNq0R9sIeQA0JHFPyqWrRROdrm02DbBFXVV/eViy6U18ySd38FCTc9o2d0m3F49+mnK1prIuTSC+WGAZDy0hAevBDQQAvyaaL7aqi3M0JstICiYMIwJaIGiw0jJYUqFFpumfcWhsNV7OCOX7m8j1wTLx0/IHW9i+ultW9kXF0yMarUluSnbGuc0CDjoce6OR3X1WAOWzBTwaxx4tOUukKYCaVFV0yMWOTJu6dnLbPtYIBwRcmD1/U1gaJS7TMkeChXxqxi8w8nBRgaMK/SyGvuuI8FluQ1lFkCdMRkBghDcp6+rwMBYaA1cGD34QkJs6dGF9ugTs1PwYkkFeYzJB6yT4+jclillBBSHD+b0DQZEhzJ/zv9nU2fd0Qh+28fR389vmblcyMGzMXQIz+6gCBi1KRyGRUVJejiALZlqhpHD1rUuOju/3OEjx0+4Vl637jQxQaVw6LzGxKd/AcTKZ3FbeAZjNySZ8IEDqQfAWSyaZ9d689K8g/tm1Mz69bvv+yQRofTp1oXT3ePj87PUNVbdX4L8RtY3U6CWCPF6/NCPyBGsLOB91+THw+y9XX+7OSWyRHLUtXL7m9+tiN29d8Mhi5WlK2ZEpc/PaYyS9/CFx3UfCepgZChVhssOrjtOv/o/nnmq6s2PfFeO+4DA4RXXmpIjapmgBkzSGAFx6DEDiknv9ZLZRgmZYmBxIfs/NejZDQ0L2tsZVfDS1A7Ubx2aF+rQd2AUT1C8s1eggpOabwFuXhNpRorZ1XUj0dNG26bzpuV5EuLLx8ZnbN3569dWTKqDAbLjx46brmuYvSghTPja2w6zp+LrCBPm+Ifrg3mbD8FCGuhlxXea7hM2JN9Vn1zelzN6JBFtXPvYPeH374nzzzwWrp22dTIUqveZxRSAlj4oMAkLSpy9X6rxpOla8qIrxs1aP7iVPfBvUc67uCci6ObAsLWU9LPX0iVIdACXxcKafWOcA7Y6ikehjOB1DbBgy4Uu6BoIORpFvgIzmIjFAwpcXAYGrQOOrjIDdLzq/pDRv+96dKWTV2TxOgZPeNMhrTnm8BTBYHy3nL5pa1OhgZDkCFHOp3ze6F/X0sYLgChEkbKdaGCpY/ARN9QyREubL1hwbUYuloFIJQckXLFAKkivHX3li54fZWafBOi8qfH1WMKAi1/+qmgDPhAvRuN9TDpBwuZBsSNJq0IzNBQX4IXhYKwvDp6wKI5oxwbH32ns19W1xogGS156Lo+JjPwqAxOsAkWedig24PYNj4RIVzBQyBpcdpF03ej1jU5tuymkJxn7n+zYwHhL4dTEnJTY0rseq9NT6V2NBH0moW/kadQ0HwRvnESi4jr6GAltWv8M+Orki9I//itrztXMvfups+LZi5PCVtq0zZZNZgDydlX7pti32Sq2OZkk+Np0WWpicX3utf/H1YnEAg8euuLhivKJkUusyc1M0DIfVZCQKski3BfophJK8SpTefLSV4xIWxp5uVFzzzwage92CfvecV0XcXEiGVWdB/xhH21FzTewZ30GIO+QaU4gRRrHgw8hJBMg6ph5OAFjoV3Hdp/VhW/27f8vHSmZ1zoIobYbbomUW4JYa2goCPtqNrL3kobvEbnjb1zb6l8dMe3u9txH15a//ZVvTPTYqpAMaGBjEeix418A8bVrCyL4GINpY+YdNQWAICQnRjjw5fkpHRBhvBXBghv6mvNTKzHYgM3rTrxEGluNPUoQBdDiXhBC5xUarcNejU86fHlo2NmnSuAkMYrT34w47KiiWGF7JVa9V6qlMCaBw/P5kW+l5a6jEo/oUYJ/ERTHyI3K15B48MLM68qW7Pqud+4A9u+3OlevHr0oAWZCQxk+o0ahVjmizUWWO9gn8V+q645O7klJTTPfH3Z+vte69DDci6O7gkIpROHAp/9Ta7oDzQC1g8iCxEK01beaRYRpAHrlHlnOI+KEX30yFFgxChNSQWpCE9T2rfhEbI5UbRGCPAhRRdJtRHSm7dLx/54p0rP6BldeEjSjvelR2ZLBRdKNf2lRnZxDUaekNZZwnGhJJzWWYRdUOT08kwmwQSK2gkk6kM5Z4geXfxtsFgDZkKu38YLszFKrh4klwxs/eSxLuXOlSTpyMFj068qmBBeCGXiuiZM8/ODiIVkURpeMkHrxzwPE5ZLnXw5mfeSw6epVeebEVc/st88T97q3T/23En+bjBAuKrs4ev6mGEyoUZAqCZzF68hVpalCXubuHuHnGmcLWRPnhJdetOg7Gfu60BAyMDbz9v2j4uflR5bZtOjVA/9WhbKvlP/Xbk5ciYeUVAWTN2AHEKdLz2u7PKLMr788LtOjCdjc/E1N29I0yxLj6vO0jeTdZD8sUYCsXioARAmNrIXOGbQ4sLpK97b9NU//qov39tWlXXr8P7zebUAD91VUmG5u5K322tJgOoVATwudoFkJy2fGV87JnTebfVrTxzrEAr9l+37lszwjug/PzMByB8zLxb3KjFFlJYh3G4irpMDQkxt0ZJ/qcmW1DRm8JLc0Y5Xnuoo0+M/Hfe4npyeXDAlstgG02LkVzk9iJEnKB9FmtfHzrFpUeWjBs55Ye1b7ctCb1z31uW9ZoJlVOdXCFWlp07wgQIK6nh5HY+ZIUIYJKMeBghnTajueoDw4MqStUP7I0MIlJdLLPDRPccTLF0UkhAT71fEhSEChDpvelz5mNhZe346eA4BwuOHT1bYb5kcBzcEix6DQ/U+Aek9ipnQQggf1DE8kjfYUoiqUQKN7I2emdgwPqogb7rnt7ht2Zmw9rYXzNdUpcaWU8+EuU3/ISkvzBDi6reofNnJKzIS60eHLqibf8een3o+Uv/v6KaA8NCu1qeLob26agCfm/L5ZUgb/WeEXBfeVpkmCdMg5ItygSjljlIcYgTv0Raew+DzHaGgl2M4sIahwcGAQosukdcVy7u/7uwj0TN6RoeNwGn521flVaPlZRfIjoF4cYXy/hVYWwkV7DpvpZeVy4d32WPVBBW61IYF3YO0UoMhpXyZplZE0cC1HCE3RAYao+H5y3qffqpAOrqvsw9EcJw+1brp0TfHJy5Jjau0J7HZFXYMYPqlWS3EZmpSE5GZEOwlUEyvU7yFPGuB/IeTwkqmxi59eOVzHVHld04PBghvqVhLgNDcBhByCS4hCoxyNYm2CQrBQ+ZNBCpq3FMZIByc/fS9mzsOEJ48fvrDl74eGzMbaid4r1rQaEd97qL03CPCOT1K5R2tpoPLSOueGrlsZGju1s87s4GTASRP/uqUsDy2e3bkwGluF4zGUQfryDISHUP7zb7d8cQ/Pbxswrfau27kwHnT42qtuiYj1XKqFMmomFWT9Ffj5rXpPJ3CZdP77JDX4hkXsrgwo/njzd90yAuW5JWVaybGLpkaVWZPajbzM4dLeQ2aNgmZwaAUIcjEHkK+af32pJZpMVUTYpe681efNan7iaOn5qbUjR28MDOh3gp5sKILoS0gxPRFK0T1ukf0XzB3VOOnb21t390AD+GlM6dFVcFdUUt2XxFBSTpDtdciigoEukZFJUIL9pUdPTPQRwwQVnU5QPjzr6tKHh060EKAkJdn8Chal6igaNuogeZJ3krPLZ3sfE6LLR8dk7v3nAKEbLyx4ZP5Ke7xoQWYx+uzaAkQeulQ8AJPqhXFZR3xCAZo6TzccKvhyN+W1JIaX51+RdGzD2z+j3/6y/e2FWUuHx9WAIWf0GgiKl7FhqtpHnajsGubs/RNowYtnJPS8NKT7SmH7jajmwLCfd+dvj1FLr1UqgkhO5NUG4KYMIQHIQrhqAIIEeCRjjSCg0AEewGSiTZQ+kWbrFGH0pZGITShIBatDQGxaNEF0s2j5R0f9FgHe0Y3H0f2Sm+vDpQNkisuhUxdAIGc4gvwxN0wJZg3uPgiYKFonG/TSu/gT+AFofXCwUtaUyi6gEqYgDMGnl/c+/StY6RDHeId+mPj2OHjRRm+cZH57HPRnsTDGxgaxOo5oSgTBQO4/k0EiIuTDEopAm8w848YsCBvsvft5z/t7FfW5ca+n3+9teJR8BDCsfJjPD0tD8Mc1xBstBMzMBF0juAQzEtQi6zzTI0rGxqW+/TqDgSEhw8eu7dh3ZhwKK22JzVZYcKE7QUqvv2fSQw5i5S2DAKEKOprHD84b/64hh+/7cxz/vmH35w3xjk1ssSmawJtGAJCI+2wSnj/cEJvT/ZNiiiaqi5Y/8A/V2dJkvTKk+/l3FjL5nNsFmggSKniQjtq5lRcoKLADfP6kV/NwrT67OSm1OjSdF3RPe51HfSS2Xx30RT36EGLrJDP6UdWkGtHDVQyoUOEQ++m8p4S/wO9Dj7iCSH8UOsZHZo3Z1L9nh1/pGztD4yPX/8m84qiSaGF0H6u8xM3RWkupOLjGj8NqEZnxNVef6n9gaYNu9ubP8FQmYxp0VUIGIJFFzyTlq99eNuy9/wRpBPZYWSAkO1tSviS3AlVXdFDWPTIsIHEEPr4bYedsYkuJRdK+CGJQufl9eiGBeBkZUBI70uNLR0ZnbO/a9dO/OM4daL15vK10+KLpkaVgWoUiHFSjXJA2LaNBt5Qvh7hEeKCNpFUWvZGL2c/PiWuaNa4mmNHTv6bkkB2GtxW8+gMfWlaTLVN14LqUDIueoJ3VPwUtmubZg+5OS2mcujAnNsaHj24p6eJ/p+MbgoIf/nqlFMrl1wC6K4BYioYIJSJJFRiKuoilRoJBH4oWquNBAToiAyW10MrPehIA0oABkngOBSM4PK2WpwN1w6Wyy6RyntLHz3SIxbtGefFOLDj9IO5UkkvuZbSZdgVFwacOSpCMXgJRaT1YdxGSHgPeL+gWpv3T4B7kC5S6gsV8b/Yc8hb7MFDGCk1RMNvK+sdaIiVD+7o7EPAB/vcOrj30Lj4uRMilrGPJdCLan00Y8YV07bLw24eMCC0o3yay4sKIbqQ/ZRB5by+d9btDY/t3XWW5o7n0Ni36+At5Wuv72ei6B2c4EKoDDmRjJpgMTSRNhaNIiLimBxFSu6psaVDQ3PX3bP50P6O0h7v/fngvLHOcaGL2RzFntSMOUOkkBRVddxg83eaQ9HVrkTLeAwJjpH95z7g23Cg82Yzp0+1uvPunRiZPzOhnkE4dgCtOh7bgCQP0oNaBpOc7PvsIf6hfXOrsm7/4r1/mav507cQDzi8/2wLYSoR3Uk1bgY1xXgGPZYKA2xWu+xaYOCz9M2GRMeYkEVVs279XUEUv32wWenKyoeHD5ybnlALwBWuVm+bxR0Pz5WBI6DEaSAq1lF4JpsZQ6YFm+xmJTdPjCqadtnSZ+4/S52i3rz7J8Xkp0ZVYUqql3PjOi9V5FFJgAWgtc+s8jBkPnJQ7lcfbmt3Co4DwphKYHK0PkGjiQOF+bocJtHaGQ/d9fAEVzBhNrF3HwDh+K7HEO46uHzZwzf2ZbejRisAQuhcgc4blVMw/4oQGk9pLafFTBqRsakDve7UmJKRMdkHfjl8bgFCNt7c8GneFN+YwYsNagfEt7AzShcM+STUZ1Z7RAUlqmDgk5EQMlHWLgSE7MRosuuXZ6jqR0Zlvf3iZ6dP/8uo2x++3jV3giMlLB/XT5vh9NZ5RKqNSwGE7KtN25w7ZMWw/rNyRlW//uxZFWyfQ6ObAsJdn5+uDJdKLgJazxGFaYchMtKD2CBPbiXB9QGngfwDsBNRvIqQG5+oRkLppldyFGGqGqhTQCObwg6W6wbLFf2l4ktP3zFWPtyFWIue0TM6ckjy4d2t3ivl8t5y7UB2xQUYJmyEegnBw4fxsBm4DLlIm6O7oGYbeUIHpJJiE32EYA5DqTI0UBdKizKQK9MYJTdGw++s7B0o6yvv70z5XNvRerp1x9afhoXb0xIqs5IgJN2K4igzRkpYYLIYnOyiBM4lpkHUvo3/BErEyTY2RUuLqb6xT+6Tq18+5yYHZ2GwGdjN5Y9c39eM4NlPpXAmFQU2eAAZqtw8w5DX/SlQ0M0zS3DGOS22bFho7lP3vH6og3oIJXnHd78MD82dHF1igfRzH6cL+ByIjKOkKBb20baF3RquP2Rfp8dU3TjAtuWj7Z0YMfrTd3uKjC0TIpayHcNeOAhs4Mv/GA4B8ZuQ7+rEdjvntZean37wtZPH/+UOt54KbPrbO8MH5EyPq7ZCgRvlECr+K2LRnRSMKRSkLkrlMat9NhDa+dlRTQnJnzWm7sNXOkY1KsuP3bJpSlzBmLAl2ZevaHM6cYkvVl2jKY6CQ6g+BDu4zVS2pvPj3cCXndw8I6F2ZOiCORPqGbruoL2lIUnSyROn0y5bmhKan5HQAOsmak8QYgm9KKrTYd8yEuuHD5i9MMXTvnEyNMBDeOnMadFVViCWfRbRxRdsgiHeEslDUWWJWFpD+xkEhDkplV2th3AfSEbXXt/HbABrq584cwNf7BNS8DYrBWicw+wl/trd1iSfLck3LaZk1LkJCE8eP3WvZ934yEWTI5bZk/yggwAnIRe/mFAaauI1J268Rjx0HIL8sEapoPRmDVmRc3kL+21zx9Yd2n/kn5KEUkBaUfJQmm7Z9PiarOTlFn2TScTVigpE+CAgkjkrqSUtpvKGfuanVr/UQctG3WB0U0D406enS/rKxZcIXoLCP8OCGrbacKIB2yjTcFaKBdkYjQgbVtVDUqLECwbDRTVFBLZsh3OEWTcYVKk1A+VlF8r1idK+b6XWU6AX7UTjf8/oGWdtsDndF+slR5xccrFc1V+qD5F4C0UkboQAMciX3IC1oQG21YWSUhS2WgxkAtEpl4nyC5MuVXYZOgRD2IAVMo3YLFrd7/SyC+R92zr79fNx7NDR1x97bXhYNvvAy0pabtU2mzVNEHqmhsx0s7aJli2V9m3sTMcSQh16ZjD6kjiHTJWLzQ9SBudPiFjyYk++6D8boNEqWTO0XxY4kaC3GhlC4ewizgHqv1QgQaQqc+7cw9mJkU9TXKnx5cPDZz1552u/7u+QCPITx0699/JXSRekZ6jrrUleXtmHe0IOIpg7Yq25Reeh2CEzxhLypBmQIALyyVQ1TggtHBZm76D9/I1jRcXaNF1Ramy5TQ/nNqA+lQdLAj1cII2bUeWyJzdPDC9KiVn0xguf/Pvf+c6mz9LUBWMH5WUntxgomF7Ni1i4vo5EpDyY14UFLaTE81hxqYX9rWlR5eNCF9Xk3N1BL3zLuzvqsu6+vk+2JbkFvcEecgWbecc65gPpPKJh0oV9aF4MXfSZcEPaxAdz5STv+KiCcdq5P3zxc4fO+xka/PSN70ZFzk6LrsJcK5ore/l7pIESVKvWDScenpbTospGDsr96JWtJ462fzzPxvVvX9HLkB5ba0vym0BD6+G95KKkHusHvGT0JcbVqIUnWLnHzGdPbmE/NS58aVZKTUdj6d87sHbi0Rv6Gg3qRoxR9Zq4ahFejlVHcJcAMN3q4auxDZEFMcJ6b1pc6ajonL0//drVNLG/ZXyy+ZtK080j+801aBvMST4zw4RYsMSjknkMr5L4wplhi1Ys2Kk8JKCFlojklpwrVpmTnVf1yfz6gx/+cQmMQcTjR05lXFs0JboYE2hXiLYPvrjAGw7BrwF/y5bsu7FPTtbIyo/f6on2+JejOwLCQKv84/tS7WC5pHcAqIkokH2KPgkuQqsTWfYUXEGUYAPRgDxLJgCaUtowZoYzG4pqVMTlN0QEGiNa2c9W95Mb4gKvrwA02DN6xnk1Th07dW9agKHB6v7o9CPgJ7o666mqHv4ZqA5vreFMOwb/KlcThPfyy6ouhLrplUp6pOsJJbJfHik7o2VnjFzeR1r4/0k7P4VLvguMvbsO3FLy4OiQOWa10waLo7Te6TVyyRAW0xPRQZBAS3NKhCs0n9ZRWQJITHOSVowZnJd9Q/3bz3/W2a+sKw42A2te9uC1fSwmZAiNKq9B5YVcGTWEVVAxAK4WU4SPR3wjat/Rz8Nmn6lxlcNCcv52BwOEHcIQbv10R94E/9hBC01aJzfP8NVrYapRt9k3mDM5aRMEMkynDFpPakzV+Ii8gqn+Y4c7rZKezcKXpPvHRxbOTHBYgG7CWa+Kcx0mKDAA2ZtV6wWG/LKmGy7O8S164Iev/4NeZveP+1c7n76+d5YVIaUJ2slcFpwsGoXbjRvetCI5FpdUQI+Nayj2pOaZiY4xgxcvmOA+eqhDlv/ZlHTtbS9c1ysrLbYy97IVVkrOoKREnYgI0orJqJa6Q7CLQuczop7WrMevGgjznBZdNjw0t2HOPceP/uccxT882B0pd2TdiIGzjGon2BfJW8VDUHmUMVw+oFf0GxMbGaKeFL/gwJ5DHbGUvWkdAMK0mEpYE1Ghrk/LF26QrsR903lNQUCImw7CJ+GWqPdlD1nO7pBjQ/PsY8u7ICC8pfyxoQOyjKoGjDYRpjiFDxSZQwKx8HPYSC15sLlteve0mNKRsTnnIkPIxsljpx6784VhA3PT4muytM12divQ80UiTvXT9cvDhDxKXBbploWAFj43bUnQ25k1pGnkoHm24dXbt/7fe8jJ46furluXlrhsRnwN1bpgsBMeYWg08VopYwbv9khXOkYOyN387EfHjvTQg/9ydENAyPCY9P0bcs0AAIT1YaD2FFuAIuw5IBT0BTVi1wk0CO3YEQgII0g4KuN/kXRNpM7gf1HMjCNCdkbJdSFSee/AraOkQzs7+wD0jJ7RCSPw7avSiuulkosC1QMwvSkU+PaaMA7neK5vhFQbKdWIFBm8EgO1vKgwoPD5DoED4WcjFDBJrffAEDI06IqTqgfI8/5L2v5+F1mCYR9as0bVTwhbYtf7bOAXIou8R8iiUAqoVRrnhRWKwxUPRTvQR6ZV32zTNQ/rN6el8OHvv9zV2a+sKw422V0OgNCM860mAwBCYhI4ioBiAA4h0JAmCt/NOlqb5/akabHlw0Kyn7j91Y4AhIf2H9vw1zfHhy3MSKjGCa6Ps5c6DPZgp4HOBRvPQWWb06huxOxZYMbAiYcokU3oJ0UUTdPmv/z4B504Ff50820D69UAACAASURBVFbr9VWTwkuwe504EI8S3mNUQaOajWFCrIxPj6+78i+mV9d9+B8FWiePn373pS+u72WZHlOF2NJlFoJeTuQKwGxU+gmJQQWHHpvqgWrUqvdOjFw2/Yrit57/soNe/uYNHxmvKhvaZ1YuIBNyBnqV9QUOtLRkjoIJLtUMmElBqg36DC0a/8y4+hED5k/RLP51/+F/k5lxJkMKSN9/vfP6PuYp0cXsZmLVNsGkGTC8sBEKFgvyLbXemXHQ3uFZeG8HYdSNDBD2NqbFVFu1fhDy0WINvb88WVS5T/JQGTNSagY1HUYEhBrP2EGL7KNKuxwghFrUR27sZzeoGq16v7Lkh0HHlI0kzmThHmenDbpkyUPIAIzXpvNMiy4ZFTvrHAWEbHzzyQ+O+XcCF5e0ArO1+VqnWcBg+MgDtzB/l806L3d3awR9TUy73mtNYu94c6a69rp+9g83b2n7jgdapV3f75s5pHByZCE7vJDiQ+ZYnlIDYhCwauM/2TeZCQ0p4Yu9i+77efu+Ht3evxndEBDKrSfl716VK3pJ5f0gYrQhkiM30RXBS7HrwtuIRTFFBvnAQG0Ezj4jROoMJpE6BItI4jcHTyJlvyrAfn9jpFTZT2qMb32uqrNffM/oGZ00Th0LrMmRyvtLZb0DdSEgoiYG3hFBTZ6SCBolGhCU2LyXQhTTU3O9I4JfqiL7FxXa7JtIpPrxcm6Ilp0MEA6UZ/+XtO0t+XTnr/mxWd3Wz38cF7toGmTTNyF7oFieCAB4ebWakMoE/WxabuyhpiYTAkI2k7i+l+2pe149tK8LFS12ncEA4crSNdcwQAjHzW9QUSG4R/CBIvadYwm36BAHZSat1lPUQVpc5bDBWR0BCNmU7p2Nn80b2zg+dKlFy5voeUs1FjPgnvAEQiOXRDrJL4fKSadRyzAhhEAaVI6JEfn2myoP7j3SiRMa9+LVqaqi9NhqHqCiJWkWr2s3a1xWCG/wsaltdnLTmMH5k+MWb/lk+3/M/2DXzndf/pR5eemEsCVmHb5BNJnWCHAoyNKgbY/X0+OEks0d9f6s5Obp8TUpUYsdc+/poJfPZpN3O/92+UUZ7Jplfw5oB53PrLiVhFaN+xspW18tHkQhHEyRqUdB7Z4UUXzDQNsnm7/poPrE/bsPPX7bS1ddYMhIaLBpmxkK5SI6KmpDNAgYHjSZPrPKNSWsZHzMgs/f/La1Y6AISEZ7G9KiK63E52hE0Cg6fuEGqCe+N3hqtenug3zUrOTlbM9TQpZkjynvoJ38wwNTRh++sb8NAKHOb9ZyDtCkDqpDhTESCyeIIcQcHTDiaoAktOmAIRwVN+fcBYTHDp948bE3bxpgSY2twjuelzJULWivRW28UMeIo2Hh/fV4ZorGQgu/rn1Zyf7h/ec2zL+X3SKUv4IG8rUjBs7KSKxTLkP4KTW2vEANvdeCPC22bromRxaMjZrz+TvfnjzeJdaOu+zojoDw9DF5y4ty6SVSxUAO3sAuGMGLzjggjJDq/z773sE76CUEhDJuRAMq4lL8DaLOXsxlAwwN1oXKZb2kO8YHtve4fXrG+TukTx6TmodKyy4O1A0izSdcLI4IqU5cd7WhdPkQ+8dRoogSlShIph6LQxXTIJHwoNmO4GiQA8JYuWqgPOu/Wre8Ip/qNBGdMlpPt3727tYbB86G9EWwV3mFIFCIZBRzEZgGiVXg/VRG4XmA5+tAymjTt8yIr7vmEuNrz3xw+mTXWgvvIiMICKGgz29UACEPaxWyvWDtBIdeFjRN8UmJ1pMaWzF0sP3x215pd0D46dvfVOfeOipk3syEWguiJgtmYyplGKTc4wmEPFMRMKGZ2EKuGoW5UVpMRbp6WVPBA+27h799sOnpof1HM68qSY2rxBNbidN0m/Cl0cuxQgE0zMases9NfXKb8x/cs/M3pW0z9HJPw/pRIXMy1fUEks3Io5q559bFrZUCPFOzhUXr5pUJ4M1rNkFJ3dLpVxQePXSiI1IoW08H3tr4CUNxE8KKZl++ClJDKUeRFJjURkiFhGouiRThqFwjx5WEeDeYEe8YPmiue8m9u3fub/ddZWPLJz/MHdMwvPc8s8YHffRan0j1JJ8t4C4ChDa935DgmBheYBtaeepfx/+c4dgEHkIjAkIeS0tZu2aBBEwcGJAYGGgiI+lIMbCHze8BEGo9KWFLcsZ1uVCZvTvbAkKfWSz5cRZU4xIfASLrWIhIjXA7YmjQY4XbPrsdlXFA2MViVH/7+OGbndW5q67rbWNnF511/O3WcMIweFi0bRytdA/R8h4OOIZQXOHJSm5Oj62aGLfk1ac/oDed3Yu++nDb5MTFEyMKrbicYSE0qMVuHr2P9/rgX2S/Kj2uckxkbv3c248f7fyF4y4+uiMgPHVU+upZyHepGBggYScReij15LXXbRhCDhTrxXyU1KSCSAxgBxpyhuFKgL4o0YbkDKkxUq4aIFX0lR5fAORkz+gZ5+04tl96eKFc1Av9tBHUPIH5omgOrCHbLbp227Z6BslA3gEjkXvQAWwhhjwhPVgL+cDwa9mDjTEMEEqVA+TZ/9X69UvSqY5qkPvt4+Txk+9u/OS6vrPNarcd4gQ5+WNW4iJVOLvVUgc9claiWs2gxihCggTAkHjt+pZp0RU39LO+8/Jn5+7MoEMHAMKSh67ta4H0DjUCQhXl6buNOqFDa7MmjVVXmE7J80jcVHg9LbbipsH2R295uR0BIXvLPn93a/28O8fH5E2OKraoXRa1F60yLpPK2UZkqOybS1QOkswYYKFR4zSonWyKA/Rg+NJ5Yx0fvPJVe+3h7x0njp58+dH3x8fmGVQuq65J9CXCyxF1ahDeA5JRnd+u86XHVQ8bmPXZm9/+Rvrr9KnWbZ/vHBs5NzWmzKR2Wghf6d0iecKDQTu8n5DrrjXUeIFOwiSINGTAJi2uckTUrLef+7KDaLdvPts+f6Lz6kusOZe1iAxhr8D2qAPUieIEnbLKwyfEprZEIsggvamxFeMS5m359Id2h6+nTpx+7ekPbuxrmxxWwfbTqmkSkjwBXLUkH2VXgc+ub5oeW5WqWXZrzWPtuxttx6Z171zZ25waU2nhgFB0rnDbGImoef8Kzu/RYschNDvrfFlDoJh+HAOEE6paT3UtQLhn5wEGCG8akGVQNVj1HBAaRfesMG3y3hTKE0ZRMSkFAPlYYXOnRpeOjptzcPc5DAjZpffBq19d2y9zSlQ5GX2D9YOcnfaIC0S07GhJyezmPfIM5iXRaosbzYRNI/rNu6X60R3fQfgtO9QPtDx7fW+7Setkp66FZNsarg5FxttLS37sn0ZV4/jwvPQrFn3x7rauxip3wdFNAeGXz8qFF8gVA4Dxg2llJHgC60WuDEeDypSUuD40OIlH6DmBuohAjUCDdRFtyiqI3MAoRTZDLe8lefWB11d29ivvGT2jk0dgo1eqjZbKLuVNnrXACkoO7hKUKLOXAb8Gzr2jgTBCaaHAEJpIfnGJLlC6EuEaJEAIVYfRkjNWruwrz/2vwDevdAVAeOTgkY2PbL7q0hyr1m+DQD8BPNQuahcwi7ksNq05TcE0Ef6JKFIHYM0+K3n5uJDClJj5PZFo/2owQLiq9OHr+gEgtGr8pIWDlEIhM+OljtQSrgT5kIgLo0eJ1UmNrxgamrX25k0H97VPeuf+3Yc+fvPrCuuKlIiFkyNL2aTEpsFkBdgNJ0TLoH2IJkm4n9TGLhAFtSyoG4kZY5ObyZHFabqCW2sebv3XfVwdPfb9fHBxintCVKFN12TXN5tFkTRvSlRTMiqc8Fn6JgYIU0Lz0pIXHTrwOw7p4V+PGq8qnxSx1JBYj5oxBgipyAFModjI4uZZo1oe0EqA0AwcC3BKDBBmqhpGhMwvzrx5/+4Oqe78de+R9atfT7ogNUNVB0ALrMJUwI1nmlosACmd7zDdF9QcxwZeZAu9Vn1z7hXN7AR+6an32j0Hf+f3e2+ve/y6SyyZCW72lpnVIJ/jdxgtHU8v4VILegunRpVkD69mmLx9d6Pt2LT+nSv7mKfFVjHoTvZFDpURBEIwD4SOehQak2hzgAo6YvUZIFwOgDA0L3dCVZfzEO462FK45qaB9kxVI1jBeUElARX6LHCJmDFesWAV7XygcuSYEADhyNjcA+cyIJThHvjr0gzfsMFzZiTUWwgec9E+b55QNBEkDrdovWZFzIzGQiss8cAaCrvGZ1++Ij2mnN0cnn/0TXZY3n35c8PVZRPDi7KHtFCLjxCaeu1Y8Yr+XvgrDC6mRpdNTljUXLS6sw/JuTG6JSA8Jn/1nFz4F7myf8ARxXEgL5ngiI7NNQOOSKVykCaggVqIlpEpBx8bCAN1WDUB3Wg8Op94DKQvkEVkgLB2gFx2ofRItrS705Zve0bP6CJD2rIpcNdUufhCLHoJDaAcNICgTqbLDUKbBB9YLzJ+awVbCOAwkvhDYuCh5BO+wsUYqBcS7kYIlZEr+8gLwEModQEP4YFfDjx+63OXX5QL+Q3wAc9pH6gNQM2YkrItjG1ukc3IJ0BGxV6i89qTlg/vvzDzypIv3v+us19ZFx1Q/FX2yLX9LJlqFzRuQ7K/36TxmYU0ywDN5m6Dyp2pDhoIMRDSQ3QcTY5TEyqHhuSsXbXp1zMDhFJAOn7kxC879j1686YZQwpu6p89LbYsO5nBJ59FgzAPwZ5Fh/tAAircEyVeCP2lmDGjdrLnsD20aLwZ8XVjQhZU5d68Y2v7V8P9xhFolb77/Kcb+9nTE+qykpqx39zDG1MQciN3x4un7QxgqFyjBue6Ft7zuzRax4+eXFG4dnJ0XnpsFZvPWZO81mSY28ECilr8FZRbG7VtyVXeXcZjJLTeiRFFV/cxbt+6qyNUo5Ik79j2yw2DrGMHL4Ykm6QmM5vv6sVbqfbwEkWlUlKtSCK9iBM4N2gEAWTLomtvGTVoXnXObVs/+7Fdd1J67ZkPMi8vGTsgz5a83KKBwm4jhtzwu42QUmP8RtOMOMe02KJyW8euaDNAeFUfy7ToKgiBJJmx1mXUCsgkwKqJ4qA4jeZC9zUFcvps+haLxp0SmpeTUtHVLHZ7dx5YvmzNDf3tGapGqBri1bKYe8Qloy7l1kQNkGZ6Apwe4IKz6X1WrXtaVPGI2JxzHRC2ng789O3eFPX8idHFRnjhXh6sygOEvEphoFnxEyJnyMW0mNhkSfLakvyWJF92kj9riGdUyIJ7fU/t3Xnwibs2DRswmz2Z3Ys4Pw+KYi9G0fio55Cd6jZdk1HVOHrw/AWp9Yf3d/6S8TkxuiMgZLPDrS/LhRfJ5f0IwkHWKPcmsckom1ZGypR5WC/yKmop5JBHxQSU0FEHJsfUhkL5BPgMqXOCTFCYQ9MQIZf1gunvc9VdIdmiZ/SMTh7Hf5Weq4flmIoBAQc4eAOirIVzg1jiItWCJ5ADwvqgGFvmYb9hEjUWYn0oEIn1UXJ9FFyMDZHYQxgjO+Pkil7yov8K/PBuV5Bq7/zu59vK11x18Tw2TWSfYSYdD5SDEjxoUfPymAGqXQITlIuvjkMUm5t6e+ETUQcZ2TZ98/W9ZhXNXL7tq5/+898+L8feXQdXlqy5vp8VUhk0TSaVz0iJHTrOEBIghHp6lOYqGynTeDamxpMeXzNicO6DzS8c3HtGgPDwgWMvPfbepPh5N/S2pYTkGdWOrGS/PQnFw2gLZG865kZ4LVpRhqEW9fRqTzBoFChll4V0U3rf2MF5mVeWsjlQex23PzDYkXnyrtevv9RqT8ZgD8rPJFYQQkHcSGm6sPULch2mRZePjpn1w5e//K5JLZvi79q2b+blBRPCCoxaJ6DBJC+DWxmJLngHuQsLOUkNXi88g5SgNfGEHnbEDKqGy/4y8+W/fXD0UIdYi/fvPpQ/tfnaS81Gncue3GSDDm4vWoW9CtwKVonAwfERPrSoqQ0F14Bg1uvPTl5uSKweOsj2yjPvteMenjpx+vE7X7ipj316bF1W8kqsxYOrw0A7gOJeCxxDF7vPGBPdk0KLsq6rW3f36+24D/84Nq1/96reVgCEXOMnakV4WR/JgAW3j7pWWr4hjSUCwmb2tDHhi7JSulztxJ6dB1oKHrqhr82gbrSCANL1dzZCdl3raMmP1gi4xJFT30iLWSFDhV07yBCes6EybUd19m2T4pdMT6y2JvmRGHRZuFRYiDXYu88Oix6No5g+StARQB1cy+wO4MfDwq6U5mlxFYVpK5sKHmRf0+JqcoaswJ5P/M06t0WPXmLwE3otKCZncDElZMnkxMV3Ov7W2UfinBndERC2noCU0eJL5bK+5FkiQCgLMpDEohQVI7ZQKqYPICsYoGfWBfPukbhgs1u0FNaLxyF6NERedgH7KenNW3tq6HtGz5ClgPzWXXJ1qFzaS4bq+YhWRYZdj2Q7u3BqwgO1QN1TXSFaCsMluga5q5AHOEFRYX0oko3o6a1HhTa77pwxcmOsXN5Lzvt/0vb3pC4ACL/97Ifa7Ftu6J1n1zdjqRTxJ8D2ACCEDznsEhAiIkyUCXZV4aTHS8JRO4jumq69ZNbK0rU/b9/X2a+siw4qpgdACFMNH1pQfEgvuA3Y/0aYkOrdUZBGYSRO3msHGAaiNdITa4eH5q5d9fKvfyjN9cSxU+9v/NK/+H7L1cUTY+aPD1s0PaHSkuRhExTkAyn4BJIzrTBNYaCFRI+YPqJTAGEbuyllVEIGvXdyeMmwgbn3+p48eqgzV7i//uiH7JvqxocssSc1GzVNRtTlkqPPrBaKXDzO9qQmdmKPCV2cevmiP+Dyaj0dmDvGMTZk4Yy4ahuFB0JCvROhMk/tN3LptVtJKTTplKprD4RzaLxD+82x31jz9Uffd8TROH2y9bO3vr1hgCUtvsKa5LMNaYYFIISmgPSIglaJi5reU95R4abQFBOfFrNH/POuXnllr8yHbn7mDAnqtuObj39snHf3iH7zbNpmG7uZ6JusDBNSND9WvRtF0hWDWAw0jhq4qNx+CwO67bUD/3S8tP7da/rY0mJrLOC9BBkt9cEQg8rRPl0UpAAUfBG+xWy3fbakFvacceF5OeOrulqozJ6fDvjzHrixvy1T5WQv0KQVVlIqFoJVDC8PuBKSUVhE0AaVsbgO6E2NKRsZm7N356FuAAh/3Lo7d1T15KhCEP0m+eETkBfDeoxaL68i1KN9lBqY2jCEFqTfrcmgyrbr/DnJLUZd46TY/LGR86YmFOVe0ZJ72SozgEDMF9V7iRukQkJ2h7cnt8yMrx3eL7duboef2N1pdEdAGGiVfnhbLu4tl18q1Q0iYpBLPUUJoRIxCmCPbE611FkfwQNI6zBoVGnTrgWdGweWPHsmQmqIxLbDiwL3TJW2buzsl30+DwHFAZNLgEl6RucN6Yt1gZbr5KX/K9dgzK/QguIKi3LFUdtEqBIwwyXZEDwTKtSkglGksBkIlRGMIiRFhcsVfeVF/0/a8WFX6CH8+oNtRWlNN/XJt2p80K8NzdoeJT4EpwIuypQzBsMSee0EsIWUvg3TIJ9dDyXR11xo+6tnw96dB8/O/h/YffjDV79Zd8/mv93+8pN3vfrkHa88eecr6+56df3drz19z+vr73rtmdVvPHv/5mdWv/70Pa+tv/vV9fe89ux9mzfc/wb7+uzqN568/eWn7nxlPfwXbM/exx5/g/3gc/e/+ezq19ax/7rr1WdXb37slhfuanxky4c/nHl06u6f9nsW33ddHyseTx+20lMbFVYOKmvzal7GzckHjKmAR0QZoEHlmhhV5Fu05s1nvvj8zR++fHv7lvd3fPfJru8///n7z3757tOff9yye8eW3du//mXb57u2fPDjp5u/fevZz9ff8/p97qcb59y7dFqT7fqqKfH5KaGLpkaVGFQNFrSWYawo9AeyrxaldJ6AEwBCJ3oFKSUFSTYVwEKsbfBa1e45l600JTpu7JPTVPTXzmWJ2Tu1+dlPRgycOz2mCtxoGh96NfnZK2qmscBAA5Pa1LgKw1WlL6x964/9uXtd61P1+VOji+zgNBNyOwKE6jb1IepGk8olVKMEsajMzccuwIkRJTf2zdr87MenTrR/ZqYkSQf2HBoTNWtKdBG70m2wGOESsjeelGj6+xARqqonbsTIvXOwQsF2OPfy5SP7z5831vnm85+21x4+fseL07XLpkSW2nUtDHNayLDH4bSbRz7q4EF2q5kcUT45YdmttY92tEZx0/q3r+plYvjTom2C5Ztg4CT/Kip5KFqJEL6b/JakdwWBrtY1NnSRdXRZFwyVWV64ZvjgnExVowmxn0iXpVUAF91zjIohFpc2jMGCSlg5surcU6NLR0bn7O8WDCED7XfW/S1jSFl6fFXWkGYSdVv1XiTzvTyhV3CkmHUkpBO8uR4KJDC3yWMFR4BnRkJtWkzlzIR6exKUzhs1vN2e60W1XntSsxXQY/Psy29mRzJdW/jXpvUdIR3vrqM7AkKGB378QCrpI5ddLNWFiFAZPjHFVrRwkRMTzqvSKAKxlhBjRICLQpEJhDSLKEKSJBYNUAqiIzzQEA2xFhW9pA3l8v4eq0+XGT1UbacO6ZcvAk/kyfl/lqv7yI4oyonhfZ51Yj2FrLwOchKKi4v7DNugQcyVodLCAKaM0kbRMuAhXPT/5F2fy4HOlw998e7WvAmeoX0L2XzUghni3B9Pn/0qbJjQ/t1G+kABC8kEBRHwbMtQ1V1xoeHxW15hOO0s7DybfLzx/Ef5Gd7UK/KnX14w/crC6VcWzMBt5lUFM64qhG+uKcy8tiDjGvbPghlXwzbz6sKMawpnXLN0+lX5aZctmX7l0plXL4XnX7k046qCzGuWse9nsmdek5/O/vfygsyri6dfnj8xKeexmzeeuZyPAUL3onuv62NhM0iL2p+Z4MkETEjiPZcS6SFq64jI8oq4Pw837GEN2vSEuuzrXEunrlqa2pI3zb94mn9JetOSdH9+OvveV5jRtCzDv2xmU+H0pvxUX94U78IU76yhTuuVNTPUFdNiSqdFl6XHVWUk1nPri87PHWUqiodx8TwhFI7yIBaV08w2Uj9q0WiqIr2lO1vrn5XcbNM1Du0zq3Bm80ebv+4IVPPbx/YtP68sXXtTr1wzejXBQMgFty4FoQHSToSI+YxEx6TIwsVTPIf+aGTrlo9+zBpZPiFssQWrO816D9ddq4Ot9HjhOA0qF2VUCokmNnkyUKrxzUhsuP7SnOaCh374alf7Hg0ax4+eqLLfMjE6z6RqsAHyh9UfBSSTmVB4gzEwk1KFgq0PfGOvK0vfNDWyfHTI/IdWbjjVHgUzhw8cW1720IgB82cmOGz6JmBOsJDNrFFYaBccVTxu7DY1LjS/YGbL+x0fYLtp3dtX9TanRddatM1kquSHQitgoZbWF3i0LAFp1N57EU15oM5H4xozeIFlZElXk4yCYGHZwyMG52YmNsAFkuiiez5cGipPpjq4JqjQ2obgSgdWtug8NgYIo4pHROUc2H2kGwBCNr777Kf8dN+E8CVWrZMioOyYFoM5TKKBg64LHVZ3Cv+tUXEIk9eayG2125DopOxWs44v/5m1PJINcmj1zXadb1ZSi03rGz1oXsP8O75tV3dutx/dERCysfOTQGk/qCJ0KPRgmxCLegEIee5oeJstgqtDedMgVNXL0IgdoZidkCoEgiLQGCNX9AZJ2zt3yifPxrytZwQHg/2nj8snDkmHf5F+3SEd/FE68AN8PfwzPHJ4t3z8oHzqqCx1rY+N82KwN+XNO4EhrLxEAuMfL53HsFAlO5Sz9DKn3CN4KWg9xpDWc7OueJp4hIooABCik7Cil5z33/Lub7oCJ/zpW1vmjnQM61PIOyc0FIQo8uWCgeP8n4IndJHVjQqaEEn6rAAI6y/7S8az97/1x3SMv3ew2dUT924cFz/n2j7WcWH5sIXjFraEvh8fsXRcxJKU8LyUSPbPJePYN+yfEfnsK3t8XORi9gh7ckp4mw1+Nm8sezwiL4X9ktAlEyMKU8IWXzcg4x7HusMHzvR17dl5wLtkNdthAIQanyHBY1BhdrkS00JFDiKyhRyDpuC8XASTIIBMj6+dFlM5Jbp0YmTRhIhl49muslfNjkBo3oTIwvHhBRPCCyZFFEyJWjYlqjiVIcDYqumxVZmJ9UZ1IxSy4xq2lU1YUfVkVEImtRwBEiA0cTMhLBBgzKkQDPPwIRc7eXKTWyzaxrFh8+dOaHj9mY8OH+zkOIQ3n/vYek0VxJMQ8wmEWFvk4+a6XBXwXdOiy9PUxcuLHv7Df+7EsVNFJn9K+EIobwQwg+BTRaI7l5ETCDytF0EpOjDb1DlARIfeP25wgfGK8tef/lDqgPXB1tOt77zw+VTN4rTocivaJtEPzJvWaX+C6lBcg7Dwtsa2JQTADLOjalI7h/WZ45h713ftEfL59vOfLZnmHzs4n6JKKIi/zfqIm8hqg9YN95nE+tGhC1dVPXLkYIdXuUKoDAJCs7YJwmzadnJoeIOogpcUQhV9hl5UGAYBobVLAsKVRQ+PHJSTmdAgMIwLLaPACRuEGpwLRHUIbwgQavmlhKuBnqnRxSOju4mHUMYCnns9T2UkF6XGFNuTgUvHTghKAXUHl0g4LPTyriChrTWSwRINusQfCmcmKQKCnS6UK8Punzatd3ZSy6Tw4jTt0nX3v9zVpMVdfHRTQPjz54HqcLn4IlFC2AYQcq4vQm6LA6liHoJGecOEiCSN5BEX/GuY6EzD1BlnrFx2iezVSp/9rStwFOfROPyL/PVG+dXb5ZeXSxvqpaerAuvKpafKpKcrpWdqpWfrpQ2N8ka/9OYdkDd7aFcPZ3hWB4Nnnz4VKO4ll19EaUwBqvTEJRhZEIABCoypawMI215ioqKQqgi5y9cRyQFhYzTQicUXywUXyvu2dfYLhvHx5q+zb6wZ0bcoC5qRCBDyTi1RSOiyaFx/V6eGOsdeGgAAIABJREFU/6SkE+IQKEcEGMKE+sv/krHxkffOwkRNRkD42J0vToxbOClqGUM1Nn0z+wqbjn1ttutbspKas4assCc1WZOabGzT+9n39uRm9nh2cnP2ZS3ZyS32JLY1s8ez4GszeinZk5tzhizPGdKSldw867KVVq17VFjOQ/7njvx6pq9rz879/qX3X9fXBodR7TUkeowqLxV/Q8Gjys3XmLUuIUhDZSPOIbg9KThLg7eAWuCB4uPyXZcF4JwTbSqUEsmmpD7aEPazCZyXC4PVFB/Cc2KNHHYSKyjsdlrODSpTc5RCERqEBj8LBktkqusnx+XPm1i/+dmPOygW5bePY4dOrL31hVED56RH1Vg1fvD1aUkv6qLISqOKGzVJRzohtHDuGOebGz4/kz96p+PxNB3D3kX2ZL/SVkf9FkbOSVL6jpN3IVKPmUbUvmtAdJ2R2DCs/6w1Kzcc+bVDEPXJY6eyhkNJhjGh0YbNDbAYAbiFIoJg2mpAgsjCW7lhXot3A0oVghOSkGR2ctOEkAKGutevfu0M94qh35urHpmWuCw1uhL0vZCxgaH/PFOUlHhwnzFgIs7E8CLjlVXr7jvTv/tbxqb1b1/Z25QeU2vRNVHOJK9GDAJCD8fMPKOVh8fyLBYEhOhQXWgdXXLmmvP2HQwQrip5ZDQDhIkNQF5hQpjCnwdlsWpuiUSU7uLZwvju4M3fPS2mZGT0rIO7j3QboeNX722rsK4YEzrfpHdaNaidQYMo3IQFM4z6edFLoVHWBbiqnzOEOry4dG7uv8XfYNF4lbIKCyBqn1XttancN/bJalxw15aPf+jsV3+Oje4JCKXdW1qbrpby/wywrSEKuT4Rdl8TrkBBWfE1UUQ+5ItGBlFibZiibUNkqOSLiiL7hii56C/S8qulLc939is+v4b0xQapeaQ89wJ54Z/lRf8jL/xveeGf5IX/w7dFf5YX/Ela9KdASS+p+Qb5s/VyF/CYnVdD+mZTwKWSyy7hKynE9dUp2aHhwKvXi++JfkcJdwBdhYIhDOflE+TjpVAZ1ItKDBDWhgMaLB0gH9je2S8Xxkevf5V1Q/WogaVZ+hazjjwhStaFl7gUmv0bVMgU8TI6FxEgIHXDYHprkp8hrozEswsIT7Y+fufGyfFLp0aVYea7B6k2LwYhsG984BxT+yzo18foThcGtLBviJzxgi9I46OcSSy85hv7QZsORLAWNk3XLTeoGoeF2h9Z8QKbpp/hKs2enQf8BQ/c0NeOeMzHAKEBdxhmkCqn6KP30KScA0INhNrBhBgj6WiaTm8NTt2gCJ54RbJasXcEOUYfKdx4VwRN7hM5AWjRim5DPBrcOCTYYCiQ4OErCAjZjiVyQEhnCPwJRINWnTdTVT85umhyYt6SGY0fv76lK9Qof/X+D45Zd40eMA/4TzUWbPJJPDGfnJozopp0Rlx9Skh+/Zy7jh85o5CnD17ZsmBSA5tB2pK8iJPpDXK1AfBoylI5zRxOiEgSER7L9i07efnIQQtrc+/44t2OcnMsL3pgmrogLabarqMqDm/QECVqMKFlDs4cH6JBl1lY+FBA7rHCZeXOTmqeHls9ZvD8pqL7z1A1uv+Xw8Xm5WMGL2JoGaTL8IcAkZq4AAHPXj2SLVoXmz0P6zfPufC+bz89GyZVAIS9jGkxNWZEqsLW6zXxOj68XcB+unjPuJaOJ8q81Vgrl9TCdns0A4RjS7saINwDocePjByUm8Fu71qvAaOt2liXBfelcQtlLBVswtIV3TGsAAiBIRwdM+vgniPndO1E2xFoldbetiFdt3RqdElWcpNV57ISltNx6wQZK+iKMApBB0XLmrm3QuTxKO0dbS2m/P6MHkJ9U7amaVJI4WTV/Nc2vN9DD/7e0T0BIZsjnv6rWV5yAQC5hugAtdJTdkVtBIYchgm8hw4lKJYIw7aJSPQ7RUrBikKkBykDA8MtuLEQAGG0XHSBdPsY6btXOvsFn18jsHFlYM6f5Tn/LS/9i1TeX64YKFcMkMsHwNfqgXLNILl6AOT9FF8q5/9F3uiVj+7t7F0+z8aP70p3jYd+TliI4dkwFA8j8pyUkvoIYdZV8kUpepRoecKKnJ8HGNkQJjeyizpGqomAahlnvHxwR2e/Whgfvval7dqqlNDKnOQV7HOdo0GNCJCEjzr6JKNMEXeQ9wCCi5vsiSFk28yEuiv+YnjxkfcOHzgbisFTJ04/evvGqQmFqdFVmNUJG5ZZ40I+zCzZP70WChTRcFePUS2m4wDDfNhpBoDQqPKKnyUVEOgJDQkM9Poz4xuGh1ifuP2lM+S+JEn6Zcf+poIHru9rRYbQZ1AhIIR6D7dJSXQQ6iPO2aI1BclYNyeUVEGekGbw0HCQCP40LL7DYNJEN8/rVzuBzmU/kgiWPwrqgN8pytnxG6eIEvG0AYpcIGpSCAF2VqiAIDJhYT2bC05PqB4VNnd0nL1mXssv2w+01zt7JoMh9rWrXkyLK5wasSwruZm9fRY4Bzy8Wp1SMdS81M6ib5oaVZ6mLrqj/vEz/Lsnjp5qXHLbiMG5BrUDyTcU3QU9hJ5gxqnQXYMcF2G8cKN5Zw25eXpsVWp8/poVz3QQ2fLDV7/kjq8eF5aHvIffSGe7insaKVCRxKLwYCIPNOLd3AwAgGQAq+FhOuseM3hBqaVl+5ZfzmSXXnjwXdsNNRPDi2yU5IlLGFaebkWLIMiTa1x2vX9mfN3QgXMev+eldvEu/sdBPYTpcbU2DghJeOxt2x1KFJDS544JTF6lrJUko2MZIBxTcrrLhcocXFH08LBBOZnqRrg3qvhyibhAgDA06oDyMutcgmDnpzF9HIBZQOeeErVsZGzur3uPdhtAyMa2L3Z6l9w3vN8sWxK7Utw2sBF6LHrk+vBYGdTUPuKlOGg8IHTDdAqJB18SMgs5MSx2EDKEiFFQath0vtwhLVla/9UXGW6tenTntj2d/brPvdFNAeGRPYFNjXLBX2AC2hBJmYQStqK1OuCfAdEqAV9rI6VacDfBRu6moMoUACFV24syQ8KEEXJDVMCVIBf9ObA6VfrhDyaq9Yw/MiQp8NLy1qUXyuV9ZEdYoCE80BgVcEbDV2ioi8TEkXDZFQngsPAC6eFcaccHnb3T59n4+TPpYZtcckGglr1BUQF0Bsq4ChPg1aCEBjE41BEulmYilLQnWWRB8X7C+nCFOYT3tzFarg6R8y8O3DocJMFdYLz/yhfmKyvGDCqz61tIEgNyF7I/BcNFXWZoHeCdxYK5ol4EoK2sei/7VGOTuYzE+isvNGx69P2zBggfu3PjFNWy1JgqKs5m4IohHyMmneBHr88cdN95aeJr5nmJOO9kEzsVN5VhYKbXyJfDBe5SediRMWqcw8OsT9wGgPAMzV17dh5oXvbg9X0t6OKDlFGDGnGsVkA7Wm9GJtai9fKAB40oQSbn3t+Ho5CuDzgKBjawXi+IMfBV838y/EPzfmjWhoo8I6etnAAaNS7gBwA6QrAE/0Y0DaKW2IsbIAEQYeqdIwcuuOpic/bw2hfWvNN1VrVPHDu1qmLNiH5zMhLqbLpmE/BgXjFxh1NC8b6awK7mTwldWjRz5UevbT3zP/3XlvWpusIpMWVZQ1oA6qs8mYmuTBXnWuHNVfN6SZw+eoIpTTzS05edvDIruWXMwHktJfefuT75nw52AhdZ/SMHz0uPrWFometmFVMcuwRUBP55PT3sM29TxCcgSWLB653BsykRxWlaBqefPJNdWjrdPz48PwPjZDibrYMMDxNvtaGmU5hSZ13eMmbwkhlDSl99+sP2OiD/fry0/p1r+1rT42qsSU2WJC/pJ2EFB1cZ+PKNDpWBGiWik0JlQBVsULmtoMYHQGgZXdLVUkb37jy4fNnDQwflzGQYRuczagUZiIyxUeei+z/eMUAEawAbJ19FotsRLgV6J0cWjozJObSvWwFCNp5Z8+qIwTlTo4qzkmHF06L3m/ReI5H/0DIq7sZiQQc/OGCJx6Dm3S20oies4Oxn/dRdgR0VsJbKLqLc5OVTw8qu6Wv8+pNtnf2Kz8nRTQHh6WOB716VCi+WawaDZNQRGQja/8IDjijUsLXppucpF8AQAk9ISTO1vCEN5KYEEZWNQUoChIV/CjySK+/8pLNf8Pk1pDduk8r7SKUXyVV9GSaUHORDY8ADskZoCQDL6wbIJRfLd0+Rt7zY2bt8no3dX0qPzZEL/4y+wUjFEMhDesmjS4/TJeagy5B3hAo+EGNISSNaHwprOiAZDQO0z2B/5WB5aZ/Ac1XysS5Bp3zwypemKypGDiyD5m6sHDBjeINJqSNT8UfMStAopY9qnGbitSD+wW+Gr76Z8XVXXpjx/EPvnB1AePpk62O3b5wUuzQ1qgprx5Ek5JIt4tlQO0ofwDwax80TArHNz6xMc0VuuAHEkLjQC2vk7PmerKSV7AN+aKjt4eUvnqGzi2HJ3T/tR0BoNUCSpzcTYIMPbISY3QK2QJxH8spj6lLXunkLNupaqQ5evARcwtd4MuG3NVrY+0I5gYmCyFVRAzunpMwqzoxx3MupPxe9oZiB6eSNecA6BhlL9kusZD7UOacnVI0asOCqi0zThxQ+tfqVnd/vOXbkRHu9p2c+3t34xdI0/9iQxTbo+PJbsRgQOtaU6TsgNI8B+/QyEhpTBi+5perRo4fb4SVs/eTHujl3jhg4z57sN6l9FjDZKtJcFzk2Sbcs/Ga4BKDmpiz2dtu0zbmXrZwYsXTeuIZNj7Vn7Xvb8bc7XzJeVz4mZAlxWSJdxiNEyJwQxpOHNJCokeMGYziGkPuiBUw4M6FufERemX35H07I2rvr15zRVVOiiqxQ2deEiTLA7bNvTHqPiSNnH3bfQXjV1RcaHlrx3L6ff23XQ/Ivx6Z1ECozI64WWF8dyvwoPlR4wEg7qvS5UzGdUeuiKzeTQaakZgYIx4UutI3peh5CBggL1wwbmJWR2GiGRgQPyenxfuglTlhUaCBQ1GHQKAIedpcAgivJb03yTIlaNiI2+9D+Y90MEP6wZdfK0jVD+2SZ9Q1WvRvKJ3RitU7nwpJY/lmpuC6JIm4T2ysKXVB9Y8RNKE5xcU3nNyQ6bupvf+KOlw7tb7dWz/NqdE9AKAVOS3u/lUv6yWW9AeY1RnHSz0FgL0J0ElJeBS+sx1b6CKQKI1A1KrRt8IORPGAGfVDQYMEeaYyWl/63/Nh8+ecz8tD3jN83pIC0eZVU0Qt6JmsGStBUHi3z+J9wGRknCejcwXLDIHjOHSnSl8909k6fX0Pau1V6ehk4bGtDII+XQpi4DDuMqHjFXkjpo0Ipig86CCWyqwyrJhgarA9F5E+AMEJimLCit1wRGtj6MoTNdoHx0etfZd9QO2xgUVZSk5lsdRhPQsn4FogidPEiCh23keBGWSMeM6bDM0BIhbyZqoarLzY+fe8bZyll9GTr2ltfnBCVnxpZzRdoFQ8PGZDUsEJv0GCzsDqYlGjmMx4y+ovMTMoNx+wEfIFeikzIuWwFQ5LDwmwP+Z9vj1AZYAhv7GdHuSYF01P1NhgFFRBu4FkFLnQPuimGlDAhiULNUEXo5NpRMhDCPxnkc5kTSdCleIFovR9+1sJFbqKOj8SliFLMGpcwvAk9KkJHMCgyrKhpmBFXOTmicEzIomEDZ1uuqdqw5o1P3/7m4L4ulyt4a91jk1UFU2LKspOXW7S+LHZm8jAMHs+DollvJkNrSc3ToiomRxQ82LShXfSZJ46evNvzxI39cgwqh4mrlAHkEwWNtkwn8Le8x4xzSgYO/iEZiAHC2UNunqGunaIuWFmx5sx36Z+Ondv2FNuar+tjmx5fZUWobBH5MWaR50kwjIci4pIBD0fFc5XIDZvez54/ITx/9rjaLR/9waD8+33PpOnzp8dXZic3A7rQ8xo3LKOn/hsPUuhea5JvUnjp0AG2tzd+ctYY6U3r37m6r3VmQr1V46egJkUfwWsSxfKTUuHIISJwhl4DSkatOvfYsMWWMWWd28Xyj2PPTwdbChggtGcmNlr1frzVCOumxgfuYvZydHyJzYzaUSM173FHHBYOJXmnxhSPiMnqNimjyjh54vQbGz4aFz57UmSBRetk0Neid4tFCjcBQl6LQvcW6mshnS333LrQeaiIFIRFH6UW7DzPSKifGLF05pVLf/5hb1cwYJ+Lo3sCQsAMB36UysPkyr5ICUby5kBOUAj3IE+9D5NqRS92mxYK0IXyyHuMkOGup3BSkAIgdMXIi/8n8JBd+umjzn7B59M4fVza6JGXXSiV94aeSeKaOJcbLvrroLZOdkbIFX0lpz7w5j2dvdPn2dj/nfRcuVx6oVw7CGS9uBAjLiK43ADpAWgPE9pspAcd4Tx1RjgGJQcQgzKJS+uICg6DwgkGCyt7ybXR0sEdXSTg99O3vp47qu6mAUtzhiwn1CTKxyg42yP8TiIjEelBnDICywEJ+1qK0vahx8Z97aVZt1Q88fP2fWdh508eP7321o0TopZODq2wYnAI2gV9RC/w8BWVFye7XmWigwQaSit52r6LG6iEc88szEv0fVZyM4NDNw423du4/szbFBggRA+hDfvogMA0anwUP2DUcphqQmEhX2PmzINXmAP5f7EXkqlxWrR+VL1y5hA2Fdj82JPBo0IJMTpMDVUDXARoh0WCmGHDQ2KM1D1IyQfcVejkLJamcUZiXXp85fSEitT4Yus11Y3zVj96x8Y3n/sE1LNdjw3Ys+NgsbllTOiijMQGdkIakdRCGOxSpFwErdmpwuayKYOXlBtu/fDVLe21A5s3fDRnTOPoQUsy1VjsFgyVIeiOPDBPofCYFHoWO+LZg1atF3Bskm98xNJiw/Jd33fIdcTQ1B3OJybE500KXwbJSVoxYRVJRWYlMFMIlcUiAoYb6VApB2ZC4DemRpdP1Rasql77x/YkZ3TtmLAFM+Nr7SCt9Fl4PCPl63qpoZG+smt8RO95c0Y2fPPJ2UvkopTR6XG1wDOLjF9igSycGMSSCR7JK/AhyVzRkGkH2OwcG5pnHVvR5SSjECqzlgHCDEgZ9VIfPa/AoVY9uM9zNYEJmE8MHNJ5ee2emofKTIktHRWX0/0AIRs/b997S/kj119qM6sbeKaalrzZJKJxcYZQUH/88tGJDideQ+JRILRFNBDa8dKbElU6PWnZhoc2d7VKknNodFNAKEvykT2ttSoAhBAfGgYkQwOnI4R6Tcm3CAVAqMhH6yJE6AU9AhmkuOGTGaoER2IUbK5YeeGfAvekS9vf7uzXex4N6ehe6ZkqKf9/A+V95foQjgCRR5Lr27zFdZHoNBsYKA+RNjZ19l6fX0Pa921gQ6lcdlGgNkSJ54XLjepeaoHog655kmoHL8kITHtSAkhDZY4M+XvKxaVsqx0sl10sudTSqeNdpFPkq/e/zZ/iurbPwlmXraJofjPHISSuo2J0l0CDvG2CVIXEEwqnhNem9duSfNf3yi0z3/7912fDIckA4SO3vjgheumkQeVWbZNF7bOoIFTGrPFDm5kWvpoTIQcVkSE6x/DVYVyKG9yGYBRsI6QM9sIpr8uTndRsUNffMNB4T+O6dgGELYUPXNvbaoC0SfIQQsoo+4uZaN6jySVPIuGJ/1hhp+ZEE4QZgJgThFtWnZ+9apgrs9cLGkUUlIINzGNJ8qJkEfyf8BuAP2Qwr9GoajSr23YJunjnJE1u1Pgc5LWM2saZiTXpiVXLUm+9ufSJv/o3PPPAG19/sP3ksa6bfvz8g+/YbqicFFFopeJBDZ3AbgrFNVLoDiL/7KTlhsSG0YMWrlnxfDsqnH/Zvu9Ox9+uuySLwaTg3FqJ79eI91Gr1E66ghWUMIN0WfX+rOQW9uOW66qfuPPl9tqx/zM+fH1LkWHlyP4LsFucJqke0W8p/I1kkQpGpLpFVj7vn4SYWa1/enz9mPAl2WNrTp34fTPa0ydbt32+a3zcgnGD8jMTGqErkgexknkVMCoIlbU+mwZC+Q0JjmsvsjyyYuP+Xw510GH5x/HiU28NuShjWnS1BRNlFJUBLcqYg3w772ixIBdtFHkz7HsAhGrnuJA8+9iq013GakuDAcLlxQ8PG2DLSKwnTQTedtA/zFXlLqMQFCAJJnKtNBwQMswDPYSxZWPiZ3en2gllnDpx+qv3vx8fNW9qZLEh0WHiVZPuthuPG6WTASGiRahOKDKX9MPUD2RGEYpF76eEpMmxRWXmlUcPneiI6tHzZHRXQAjt2Kebb5JK+0jVA0lyJnExIYZVEOqrJ60azFCBZXJEii4KIgMjFDGb1NaCiOJSaNx2xsmL/tR6+0Rp2+bOfrXn09i/TXoiTyr4X6lyIJBIgvIV0D0c5aOR8D4yQFgbGigZID3v7grd5efPkPZ+E3i6EHoIadmFXUE1oRKGyuD6S5iA7oQVg8whJc0A5IMQmlAh5+aJo1QrCm2EVQOkskshUabLjG8//aHauvLyi+bkJq+i8m4OmdTig1+NswSuFw0CQh4qoCW+BSIWwAKk99/UZ9a8FM/Wz85GhuqJY6ceue2FCTH5qWFVFnUzQ0QM/pmo5x0iQ3FLxNoMEccCikpurqNJD2n5aIaHjRSJvL+B0vYZxMpJajFpHAwQ3u955vDBM5XC7t11YEXxQ9f1thkwVAY9hFiVoUaAyuPdnUYxDyMy1ohxlHxTkc7Qw1s0EhvZE2CdXuvjG/fLYZs8egIRFzk52OOAUNlQyqhxmngTPQhEDfjVpG1Mj6tOjS+/q+bZbz/Z2dXUbv84Aq2Butl3TIrJT4+ttuubjPz9VTL0g9WObMu9bNWksJLMIeWvrm/PeJLW04GXn3x3TMicMYOXWKi7T0mOhUx/t1CQOoOAEN1HuLcu5OR9WUOWZ6gaJkYXlFlXdZA28viRk/d61w0fMGd6fK0tqcmqVexw3uBMFzsGhNGUE+zkkiIIRFFD7PsJkUXThuRv/fin37W3h/YfvaX8sXERi6dFVKIh2WcUVCRBKXZAoPdc57fChdw4Lapk2IDsbz/7fX/lDMfGp96+7OLM1OgaK1R0cLRs1IgcTlXbHXYjIPSITFQkV9XYQ8gAYeiS7JTqrsYCMUDYUvjg0P7WjEQHNwtwMQh3Fwcxj0acxlqup6ClKwt29KXGlI2Ln/NrN6qdaDt+3X9kVemaUSGz02LLcbHMHZQHa7xtFhCDbfUWfgUpB0201euIPfZak5rY95Miiq03VG989N3Ofonn9ui+gPDU0dbHF0jlA+XqQbzMuoEbk+R6IQcFKIjBhjD7xOlmbZisSEPbbJJIzCceA1JqaiNaG2Pl/D+13jxS+randuLsDWn7O9L9RrngAqkGewgAw4dRKgkvBalHEok93gCAUCrqIz9bz+YXnb3j59GQ9nwdeGqxXHGxXDs4QPWDuGG5C/bRI0rklZ4Onjoj1wYVv0TLy0KtTVE0kBiEccFy5YBAVeipJ/M6+4UGx45vdi0vuE//v9k5ySuxlIxzaPiZx3MsBZvBOSsChFhL6OLl0WrSETFA2DR6wELjVZVffrDtLOw8gygP3/L8xNj8mTG1Vk0TmHw0PivmH7LvERoxmOq16zxWPS3NekXEKJnxnDiZo5kcTMcz1RTK4kRZLGJClScbAeGNg8wPNj935nXhDBAuL1lzbW8rFJSrvZmJQUAISTCI/QyQ6efBTjDOFiK15eFxL6LuPDPBMUNdl6GpnaGqnqmuzdTUw6aqN2oaZ8bXZiRUGTUOg7oB02sY0nAaVA2ZiY0MQFrUTotgBXnqCUFQkIk6TTrKIG1ks9iZ8Y7J0aXueQ999sZ3J493XWKQxu4f92ePKk8JzTckuqzQOOJCH6nb2JbT0JAJ05uV1DKi33znvNVbP/2D5rd/Nb5477slkz3D+83BMg9P2+kj5cdSP6Fo/BPyYHyvYVGDnbc0WYwsyvr/2fvv+CjL7H0c/+v3+vx2VTqE9EZIpiYWLFTpvSQESKZPQlN6S2+TZJLpkwSwrmWlig0F7CKKFVdXV1dXZe3SpQhKyzzP9z7n3Pczcd+uq5KQGDiv55VXEibkqZNz3dd1rmtEzbeft1X40DNbXpt1TfH42BV5GQ3WFhGX9IAI7Idha8rUnIYnoCihjpgT6M9OcUzsv/xOx+Nnfvy1WY5SSPrm3wfHxt86NaEsNw1iM/lsnhgGRuMfD4yo6QLssc1NrRkfs2TpJN93By+SnQzVzm1vXN8DcgjB6kbR/ul4hAnup9vSYoDQokyX4XcYPrTp/SZ1/YS45XMndjxAuO9440oGCG25qjqc3sTLDZtbvCEowMZt5kuE9Chxc2MLZtgwQDg+9ZYTnc5llIodFDu0WTeumJy4clZqjVEZKwDCPNDClkxYcFGuLIrwxdoK+PGgJY/HjM+aNSM4I7VmcvLKmlvuOnf2cpt3QdV5AWHofGjvC1J1aqg8QqKho5ponEeKE3HzsbKSPl8jzO5rRWw9OZTQd+BnoYsN1cQQIKS8ilBdslx4RSgwQPrXM+19tJdQSe8/Fmq6WV5xJeKHGLk6Vha55/zy/WRANE4u6ilvd8jNF5SVfLl+U0kHPww9Ml+u7C47oolpp8lAyiQkhpDQu8ytgNBshl1Q4OpRMhre4JqG6Jt1DPlDZKhU2kuq1zb/c1t7H2i4jnzz3UbfE/o/2e36BmhcUDfIl7pRqSj8Y3hmHaqJXDyTQAhjqLWFtXx9cHJ80dikxe+90WpDWb9QZ388t2H1jrEJC2ckO8wIBVlfa0v329IDtvSgnW0ZAYseJDrWdL+wsPeR2YwJo9WVID6yiDCQBQtnCLlfHEMODB0NjjI+uOa5H74/zZqDC9H2HNl/fHXJgzf1sgLBog4Y0nxoMerFST+uOjMAOyeSoLmFndvISVrei+eo6jKTym8dHijJuSP/5pqZ1xRlpxdO163KVK+Yri3MTCvIu7HSnO4wqmsx3wJowJy0utzUOoNgCKEYpxJDAAAgAElEQVSRBQqUnEKATgSEDDOHHrCb11EohS8rtSoztfSe6u3ffHqog2uaHrl9Z5Z2aWZSGUyQ4s1p4s6Z6BmrotR1ssv3zkqpHREx/6Un/n7mh1YGuscPn9x+/+5hPfJm9neYtS6atuWDWOHIQS+JrhWDHxOuCEAQH9vYDZwRzO5Xna0t3rL2hdbdPaW++Gh/w6qNQ3vPsYPvDnqxUuSDMJihB4H2n8vkyOoTFAFestMkp0T2bjAxsWiybvH3x36tTeLpU2fefO6Da680WNnjqQuiPzBOrGm83FEJuHovLuswoOKZnlw+LmnBG099dObiKpZf2Pbmdd0N05KrLOB96kGQj3bEGmE0qnZbRVIr5tEJRgivslXntaf72TM4Lm7Z3EkdDhAeZoBw1ebhffMMaU4r2IOJIUn+xujlyxbhWFrkRYXrrBmNRi1a37SkkrH953dWQEh1l+ORGdqiaYklRk29hU4UrCpyKphs2BTRNZ+6FEpsvBlgsJB9ZMDbnA7P+KSEwrkjnM9uer29j+wPX50WEEKvcfaU5LpWLujWXB0TwhwCZPagDQ2RsFDIQQFOiAA0Dg4xfAI6VHSjQZ1bdDhHuxZ/3Jkol3Vp9qRJ/3yivQ/3EirptbsYGJAKujTXMJwfgxt5k6AiEWSHZB4bg7RhAgDCJ0rkMxdvWOJySfv/EdpslR195KponjfoiKF1FrguAONjkDCME+wfewHPr6eXhYTlDK7a4GtoaaYuTq6KkFddKTfcLJ0+3t4HGq5Tx04+t2n3dVflgYm81k/kGK13WmC1G+kjHWYrCfFhLsXcIfECC6XIGRowCIEBwuz+1Tf1tL29+8OLsPM/fH/mL95Hr+0yc8CfTUN6zh7Y1X7TleYBV5mvu8I44ArTDV3MN1wJH0dHLpiWVJyVXA5YiBQ+FBCMA3t8tAybcjPaUeK8mceCofbskzx9o1FdNzjSsKnhuQt3GWWA8LbyLQN7W9j/aQYfP7YbfmAItXx6CnPqSDJKtp9uHlWnIc0nbOxyzEyrYThtc8OufZ99t/fdb997+dO3X/jXG09+8PLj77746NsvPLTnvd17i2Y2TUspyk6pZLCEHV2Oqt4IgNBFYlF0vKzHzQ2AEF7jYh2tRYvByhhBZkxz56jrx8cVGK6tePiOnRe5F/+tZbqxZHTELTNTqkn3SK05x4Ro8mkW82nsNp4cu2p6WtE/93zW6rvB/oZ/+v7Xo6NvnRJfwJAAdoHCUkKkXGJmJvfuV2xI2WYDsi7I2s08CK5wTYxfZRta0+p7SBVqll7Y+uaN3S1o6NJghoA1INJpCg6WfjCdklvUclqMK0tNwiNRmCUGslOrh0Zbvv73oV+p5/z8o32F2atHRS6anbHarm80IUMo5KnK6DL68mv9BlXd+PgVU69ZcvHnrHZue3NAN+O0xCp2jEbMFSTS3qAW4gKgAf341CAjpMWVFL2f+DT2NgLunWrXeASEHSeuk+rwvmOBZRuHR9hz02otLR4WMVMdDkcxCt9mYm7JgZlC9qxaX2ZiybjUecc7qWSU6sR3p5ZO801KKMhJq2NXHJQyFMzDA5ncGGuEI9yYOMrHLsCalQ+XoiETPDVWXYDdQhPiVwYKNpz54TI9eKHVaQEhltS8dnSooGtzZVSoLknGATNUryWgdwWXhnJNWjVsgPdqhB0ij0SLAzUpERfOWCFpw7bVmSBX9Qo5oqS/rbtMQF20Cu30haoTpOJuUm0ySkZJNUp0LkoNhXms7EpAhrCH9Hih/OPR9t7xS6ikz15pbhooO3pLjuhmZUyXB0vEIcsXBw6itTGKqS9NEiLBy11G+TwhmcrU4oPJHsD6eLmyj1zUVbp7WoeaCz3749k9z757U/fZOWn1Nm2DCXMalOABM87XkfQFoQj2aryFdbWwpydLPY9Nx3qFmhu7m3c/+feLkLjF8MlbOz/0Ln5gyQRf9ey7HbY7Hfa7a+fcUzv7L3Xz7vMsXOde8IBrwQNNq7asWfVo3sD6makOM+ohKfPNgAv5Bu7z4Sa4G54IwjQIi9qfr1+dq3IO6jtrc9NzFy4Z/W7/8bUlW27qZcEZwgDYyVDMlwZ411xOWvJsD2WlWRnpMXKrTPf0/pXjEpc8cttLxw6fZKf63JnzZ0+fO/PjWXZOTv9w5sdTZ9iXB785WpV/97jY5Vn9Kgyp9UgP8sx6DLfgAfRhUxO6piigRYt5MGJhOGFmai3rXfKH1T5+bwedMmBt6LFDJ6eoV0yJL+WyPbR8hP41DZt4pJsM2KjhgdcN7zmvceVD+9rGxvPAV9/V5N8zKmphTprTqEAFHukGyjEMN3dxuknD5XmQc83Ag8bPzrktI8B6x2lJZeP7Lzj0zfE2Mm9895V/2QaVD+91a/41q8FuFBdEMHQO95NgD5FCnB4UyS4040dcOj4s7EYaFjm3cdWWw/t+1YLXO69+NCJ6Tk7/6rz0Jos+QFN5ZKUrjG3gN7Lu2a7zz+xXNTl5uXP+PW1xEn65Xty+Z0APBIRAY9LQoDB84gNjHsoC/cm4HR+uhi9t+iB7Fx0fu3zOhMqOCAhXbBgWac9JrRXZPD7hgOIRiTVe8c7PvsSlK8A5PDeFBmWnJRWN6z/3xJHOzBCePXPes/j+bE3JjLRaKziN8RFlnjiv4XmDRrwBDIoxGMpHzUIXAHktEKASmJlWu3Bc8KlNr8ud9oRdvOrcgFA++2RpqDpZKu8DyRMIEkLOWJgb5Bq2OA4enEIpSlFptSKggshAtJzB78SQDQa0quCknyhX9ZFKu0kvBeUfL4Y7/OViJT3tkMp6S8Vdgb8FC9kYiQxIwIOEBs/iuXzUhRCiuLv08GLpeCvPt1yu/1pSSProKeBpGSDEOUBOElYTeo+B5wjsYcK8Lg99qaEh3piwWJRyJjBBVEaXUZB/l/cKVcU3P1HY3sf5k2o+d/4fr388qNecrKQKe3qjBSzRROCBmmw5fdQWAF1AjjLEVlFQAeYUK7HaIDnLcA/ukb9l9XPf7W/bUR9JkliXfPL4j9/8+9C/P/jmq0/2w/bpga/3HmTbN3sPse/T9vWnB/d9dqTEtGZGWgX7e4zhZoTBlI7WZ+KmMkDQ5aZRv04uGv689NU5qc6b+uZuDLbKDOHxtcVbBvYyAxDVBozg2eMjIwcDgUA6w9iB5YrpMvgnohBpD9WezJTKUbG3rPM8zQDhfzs/7I5+Zcd7KzKbJsSsnNW/GucJ3WIc1M1ZXxAA88ttoPRCrZJb6BZpy56slMrxcUuLc1d//E5HfEc6cfRUU+GWkVGLpifXYAfmM4Xztalvg/Ns5M7vnpkp1ddfZXn7pX/9+pm331Snfzi757kPR8bcMj2l0qQsoxB3xPWinjAbpliVqCF43Uw0Arj5+2emVg/vO5uhrBNtk1h99ND3j9z1woArjWzfrC0AoYlIQhXmaGsUkEZPuhfhos/SwkPVCnEv3nGxK6ZqVnz20bf/8/eym/bRu1+8ufecudc02HQNJhjEwsB3tDXm0jst9dYgT50aX2gaWPjBm61P5/7P2omSUXQZDWI4R3h1hgbGDBruyEoCQj5iR8IKsl9mgFDjGR+/YvZER4cDhN8e8y9bP6wvuIxatCIrT0NjkF5TGOSI/FIkt8OTckB2waj2tKTisf3ndW5AyN5O15ZtmaEvmJ5SZksPCtOvsIcwnTdi0TmWFosC9K5O4NCi9djSA5PiC+tvfeDjv1+8AJVOXJ0cEDZ//kqoaZhU1hNjJ+Ix2Uw4xIQNRQXpBwxhQkiY4KOSjagnys6OD3ErfPwcPibIjgi56Arp8WXSoY/a+1gvlZJ2lEvF3eWSriFQIcaEeEAITzbnVxMvruQCukku6i5tmisd/Fd77/ilUtKZ76U9f5WLusmOPniN4vmlqQbdNdj80NOnmPqS5Ux4shcva3WsMI+lwIl4iBjBR1gu7SatHR76+Ln2PtCflBQKffLel2PiF06KW2WHAGWfSTjLocemVwzHo98JjhSSRSeG2nFAqITtwsTdtcERfRY5Z9/3adv/qZN4yb8sJCN2pWTOmqlpRSY96UK9YlrGrch7EBC6iPcwEw2C0im7viknrW5g39x1/qcuPHYCg78239TTirIrvwCEYKgoVuVxl3BQkw+ekccDIgfE5LDDmSkVw2Pm3l297btftOA/fuTU3bVbJ/dbOTWxBEkq6mK5GNUsUhDMKgKEpAz0il6WwAAYtLAXT0somqEqDK7adBG4399U7OLv+/LIxNSlIyOW5WB6AQnb6IxxQaaGiC+0f1S7MhNKxycu3vfF4TZSILK2+NA3x6aol09OKspV1YPUMOxH/38AoYh9M+tIhOkhQMi6RtY7jo9aNCl18f6vDrfFfjJ88sGevSOi5kyKL7Do/VY9T1Q3oxrQrHLzXaVHnlvgohwAdpW4IwyjQ2/b6f2qB3QxPv/IW/9TWf3uq5+smt40OW7Vgutvs0JcJH8KaIBQBBsAHGV4w5BWNzZ60byJle2iWN65bc+AbqasZAcDhGatX2QkeoSViFdkCfgokZW7y7DP9Ty93Z4Ow4fj4lfkT3B0tBnCQ98c9S/dMLSvNVflFNY4XnFD8itOyXvEhRppmpSgI5wNMDe2MUCYWDI2dW7nlowyQHhH5UPTdSsy+5XaMxqEFFwYzCrXHZ4OxYnHo4T6cDNhrceq81r0gfExK9aUPnTgq6OX0yYuvDo5IJROn2h+wCxVRIQckaH6eDCloEACIWMjQEhxZzR+hppSwBihmjhhh8gxoTDKhwFCzDZkgDBKLrxCumey9EnHak87bYXOh7YVgV60tBtCQRKIJvDZTrx8AhDGgWS0LkEu7CGtt0v732/vXb9USjr2pfxcjbzqCqk6EhBgTYtkea4apYUVJfAzbAsk0TUl1lf5PjKEoNlmj3BVb7mki7zR2gE1wF9+ss9+Y+mkuBV54M/ptQhTGRP6ypC1jMASirwN+mxCLGY+QUFNgyf/6obx0SvNN5S/+vS77X1kP6mVNv+E5JUtjOB4dBhX64nhPbOCl4QuDkxl1PVDokwbAk9dOENIwfQ39rBgjpmfIqoU1o6PDmqF9wl3/OMufyQWBXShdmemlI2Im7ex8XkG+X75N773+qdltttGRNxi0tTbtAFkRzkBKIYJPehiilQhNCsI7zUYq42jd1Zsdo1pdVkJxeYBZVvvefECT0Lr1g/fn37p8b9fC9kAVWYND07gmZMqxe/Bp1Bzs/rXZCaVrJq65ujB70OsmoFKJUKVf8StuZn9E24hKRQKf59eT99kgKr5XPg19B32Jft49MD39sE10/uX56TVkeEEmBsh5ONDR8LWnydeiug/guLEE9p0gezkiow/T9/z/Ietbn5DxVDxqukNI/veYtF7bOgrgzyhlw/FKTJI0guI3G0lWUGJiLDqA+z+GdQ1r8iw+pP3vvyF38jO3jNbXpuYtCQ7uWr+dbejcDqc2kdJm0C14SWzZfgzk0tyri26z7e1LQ7/f9bO7Xuu727K7leNpjLChVU8IBws6cNh9BatQIlicNSeHmRnclzc8jkTqzscIPz2WMPKjcMibAZVnYUspjUiMIPMkBDeKKJHI1cQUCAh5PrAkKfOn5lUOrrfnO/2f9/5gumVYvftA77tudcVsxvSpg+Qy46Zm+vwv4NmrRBX89vAQ1n2Jv5iH4wHpwdt6cEx0YvvcDzMzthlQHjh1ckBIavQs06pXhOq6N1cHyfXs/4yUaqO5/NmCB6AM0RVGxlXgLCtmswPST5KhAZqEUXoOU84IBlb0ZWSSyW9eW97H+ilUWdPhR5bFiruKlX0DIGeMCaceF4rokSIyK2OkVyJUn0iAML7cqSv32zvXb9USvpsd+i+LLngCsJ+P8F1pP/EXFDB/rVwE+UPXaxyHfksqJMAYbzEnt+ybiD5fsbR3kf5M3Xwy8NOa9PkuGU2jdsODgFKqC5rSfm4vNKqmiiTUIeMlkoxIaTWATpFu74xM7F0ZMy8Jzfv7lB/6ZaZXePiloF1YZonV+XJTXPl9q+nIAcxm+emETucrKPAAPC0yM9oNKrrh8VYNzU83SqA0Lds3cCeZvZ7rZqAIQ1T5lUY8sHRoNskYuLZuTVoPQau4RSGqFoAhNOSSkYnLtix7rXvj/2PaMRzZ87v2LB7fNKCaQlFc9JXg3s+tapq7lhDZwAlwS7OBgsLddgxADPwAqvGb1G5pycXWW4o+/f733aczu+rTw5U2+8a1NNuT2+w6YJ8qV4FkSEICL3CLp9iM12zUqpnplaWzrjnmQff3Ll1zwuP7Xn24dfZ7boDtpe3bXzpiQ27tm14+Yl1L21f//KOjfj9Tbu3b3x5+6aX4ePG3ds3vbJj86s7Nr3y+LpdW/+6c+u6Fx/fsOtx9nH9rq0P7HoCf+qhO16w3VBr1DgxXwQj+7Q+TsFpw0ozs7D1BypexdXaPPhBzW4/v0nry7hiRuOqh/a3zbjjqeM/PrfpzRGRc3LSHHadH64ygz26FunbYfW44q3vEWOuRMNiFoXWb9b5J8UWDI3If2Hrm7+AfI4dPnmf5/FhPWfnprps+iaTmrNqvLEmfa8axauw9lE3PnZpQW7wm08PtcXh/8/aue3N67sbs5IcZi0YsfK8Ab7+BSdKqKy9HB5owbuICEP8J589o9GkdY2LXTJ3YnXHeWqoDu8/hsH0dkNaHUp2xVCorsVKn04sUhAg5Ima5D1GFim+zOSykcmzD39zItTckd70W7seuuN568CKaYnFVvQxDm+cRxXW0FoUoWi8yjdpGtaKA7H56Q351zSOjr719qoHjx38ecH/5fpN1fkBobT3RemuSaHS7qG6aNkZrVB/6ICPLSkAwgRkIVALWs3VpCB1AzpRcSLlYjYKJKQ+FRrW8u5ScTf52drLvjIXo344Im2ZLxVdJTn6oAslSkbR+IdnhChxBQwQMjToSpaLe0q3jw19eNkJ9iJV6M37QpXRcvFVwt1HAHXwDuUXKAQoMZ4/gCJbAgEhPYlI+TrjeUK9sHeSaqJldunvnhTqkIT8iSPfP9a0bWzUfJOqzqZjgBBYQVoChzVj1IaFG0GOW35KcXBBkRvFY42z0mqH9Mx/+K7nzp7uQP5pS4x1Y2OWMEBoAjToBkCYWk9DUDQVaeQUHObCUVA79kD56Y1mrevmGFtrMYSBFesH9rCw/58AYS4EDGIwvdbLZZxI0hJOwOlByIHA/DoXTS4x4DotqWxMwsIn173+PwEhq4/e/qLSesfNPfLy0n02bdDMc6W9ZHaC1Cham+L/b+R2CJA/wYcY1RQx4rdrgwZV3bSEFb5FD/zw/YUarrZKNTeH3t714biYWybFFs6+erVFEzBxbhA2uFFVYddEymM0pTkNqTXT0ypzrqmcritk24SUJcOj5w6Pnndz9JyhkbMH980f2nfusMi5wyPnjYiePyJu/siY+TdHzx0WPffmKPayW0bE3DoqbuHI2AXDouYMicgf0jd/cN+8Qb3tg3rnDY6Yc3PkvFExC8bEL5mSWGTWuDDbDRG+FqWYWjffJcFUU79o4oCQ+mwv+uIwGOazpzcNjZifpSl47/VPpdbW44HcOiQdOXB8cv+Fk+NXsJMDHDJFzwt/F9wN8Q6gBJOqFb2oSGlXedE70XV9F/N93ieO/PcR4rd2frhqenBUnwX2jCYjoEFOu1kRWpBNv1n8n1PjiyclL2ss2dRe3hsvbn9zQDcDAEINQ4MBhKmeMCZU8/k6RSwqEAIiWzgWP7uC7P1kbMzi2ROqOhpeOrzveMPKTUP7IkOo85tarALQyCgXQ4pwWprqFJOTeKOCvNmblVw2KnnuYXA/6lgH2Lr1yB0vWAdVTksqgXOl47lEyvIZ54215BMWDqknHY1Fj/JafXB2RmPedU0jo+ZfBoStVZ0fEMpnT0qPLQuVdJWqeoRqo6BJrcMWsyZBrk4AtpChPp4kESeJIDvZmSjXJsk1SCdCP6rEpkH/2sx9ZXC0yRktl3eVHl0oHbs81dr2dfQzeYNVKriCAULhSkKEbbzwGhWiRFAYJkiefjBBGrhOevMv7b3rl0Y1n5VfCkjFV8nl3dCrKZYPedYIU98aYdVbw/lAXGShi0jjgrFo5ysQPtjP0EMaI1dGyMVdpKcq5PMdoof+jzp35tzed/49Oto+I6WKAUKbzkOp5Vb2idpj0SF5pRIgQePhLp3CTdvEI/u8FpKW6YJWfWB4xPw7Kh8+8GUH8qxaygBh7BKzymNReQ0ACGGjySjBywk4xCEZT2HOzyBAaN/U2BoM4f5jwVUbBvW0IuXiN6SCOg69+3zoOIpsgxr9Y9B3FIc269GBxm0hklDrM2jdmcllo2MXPr3hzV8z1si6tHd2fzQxef7EhOUWNbBABD8o4x7xnktRz8L+qDm8R1TgJnGpReNlYJKB2NwUx5io/E/e/bIj5Cl/f/SHJ+576cauFrPKbdcHICkkjF48hAwhSYUgmYbYzrqZSY4ZSZVZyVWZSRVTEkomxRdNiiuaEl86NbF8amJFVmIVAwCZSexfK6cllE1NKJmaUDotif1T6VT4snxaAvukhL0+M7FyeqIju59jenIVfJLkyGL/bVJFZmL59P6VxjQXe3ys6X5UilLyu5fod0N4PA+bb+7WS4QhmTpycGjRBWb1rxvQzfjkplcvPPXkZ+vHU2dWTvePj1mYk1JthQlMRIAqJQwDKC8Tz6Nzh/Wu6LCP45oYwIBxgnMzmm7uOe+WMXWvP/uPn/1dDH+ua9g2MXFRZkJ5/tVrc9il0QWIEiTHXTMlnmt8yFrXj+y7cM7I2ucffqstDvzXFAOEN/QwZCVXW7R+avQ52BMTldxKRDHCQVaQqwQ1IBLOT29kOHlczNJ5E6o72ojd4X0gGb25rz1XVWfS+nEuTnE/4lmsHN/qfEZFD0kYWImd0PuyUsrG9pvfuSWjrB67+0X74KqpicV8EF2YQvEISpKJhi2FfPBug/IZ8ogiQJiX0WC/tmlkzPw7arYcP9wmZlGXWl0CgJD9Fd+9NuRKk0qukGqjQDJaH8egIDSatYrlPUacA3ERR9yFmEbDYcJqnlIIUlKhSAzVRHMRKetWHT2ltQOlvz3Q3gfaqQtlc9K378j3ZMsFXTAWEvWiDiEvpI9oGBuqhgsku5JCvv5yBYOOqdJOb3sfwKVR374rbc4HHq8qCll0mu2kiEglaTBWUkB7WC8qVmQgSoQLTWGyF3h4CAWFFxdeKdcmSa/d0d4H+V9Kkk4cOTFddevU+JVWLcOBXi5ZBGIKFVCEFvgkoUuYkSChFFa+obUa6x1hRqJxXNRS+0DHc5vfaO9jC9dSU93Y+GVmld+q9oOBZ5o7J5WcWlxh101iluB4vZxGQ4bQqKkbGm3b2CqS0f3HGgs3De5th4wyTcCgYtiAYosFNNUQVUhsjJc7vmrc4QEVWHh2Z/YrHRW34Ml1r/9Kn5ujB77f0vTctVfNmNG/BmefvIo2FYGTixSzdBIMnAomvxP2qyGw3qr12kHyFLCn+6bErbAOrPj8o2/bfQDm7Rc/WjTGM7rvojkZqxlYBZitAo8czm+L6UEckuT4lk9OqtwWWP4I2PQNVvZRG2B4Bj7RBdAiJWjVN6CPCAi9kLKDT9BCI4DAOGjVNuTpmthHizZo1zfY0xvZf2XXNVi1QXZl4cUqtjNusTM+zHNvqRR1txjS44HsBL95biF6pbIfnHPtbTd0syyc6P377k/a4hw2N4f2vvdNVvryqQlFZpICkq41DAiFYhncpIiy5l4aHNPibcxAXV560/SUiiF97BvWbv9Z8HPiyA/BwnWj+i4wq/02TRNiJ3/Yp1Ht47N5GIEwvV/NsF7z11RsPv1Du+mYXtj2xoBuBrYnVpCM+sh1SWn90X7Zza1EuD6Q778R11zYT+Vd3cSe6/Fxy26ZWtvRZgiP7D/eVLT55kh7rroOk3hoOczDUa4I2UO1sFcE7nmFwSZFDfntGcHstKrRKfPZm0znBoRb79mVN6RqWlKxoP58BrUYAFaHPWbwfiC7UTe+aQNtaNP5yHspP6PRfk1wVOzcO2sfvAwIW6UuCUAoHflMemyZVPBnubwHEIM4+4ftKUlACRNS6xlHsJAc8FGOGN9cTc743KqEDPRD1ThV6IwLuZMZzgw5IpsfX9HeB9r5K/TxM9La0VJhl2ZHTMgRjREgIi6Sxs/oGiEgDLkSJV+qXNlXKo8NPVHa3vt+adTuNVJ9mlTSrZmyImrFYgo3GiUn2Bhh5AvrKcLLl/TbsQgI47hPbG08rtGwVybINb3loj9LO0qko1+090H+1zp96nTlDP+4mAUGda0tnbViLpS6tSRV3AZa7CTPNOgCIbEA/+AJFZnWTYCQtcXTkkrHxix4wN+BBM9Lzc6xcUtMaT62ET3IAGGuWpi4KOlnwpfSQpYqMEPI+rm6IdGWCweEDD4d3nessQgBIaAynCFMY0jAZ1Q8JxVPUQQSRq5J48blBtKyqjyZSeWjYhc8tf6NXwkIpZD01d4Dg/vah/e5ZVaa06L342iQixp9TgGpXXgqWhgI8UwOuLgAn/R+BgjzGHZKdw3tYXty/asnvmvPhibULO1Y99KovvOyEh2zMxCbsbMKMIwnIqBNLpoDqbgKFzgNvQdcQFASySfBBNNFuWE4OUm+kcTpiRFESiJRs8YuAIZAMKDoJ5tN/ClKHfDRTB00f3xnkPLCJQZ6JTdlIaRNLbiORkOFPI/bEpJskgHCO8bFLL+ph+WJ9bvaCIAzTGgfXj4uenluqhOjL8BaxqQsRnC05hWMugfF1S7EPHwjd1CbLmi/2j+0t62h6K8/Gzzz1PrXZw+rmRiz0q7H6wXmHD7KuA/7diJhyLZJcYXTUlc8eNsz7bjuQC6j2f3wjZGrAX10mQxhfYGXqwQJMtHThBH2DO7mZTSaABAunTe5w7mMHt53PLiCAcI8o6beRCbG9NQLA9CUIK8AACAASURBVCGjQDgmMT3IjX/AgAoumZVBnXT/9JTyMclzjh062dEo0NatR+9+0T6kclpSkbKEgWIKjyIN5TbOPwnn4AusFhjQ9dm0fvYHxXZ1YPRlhrD16pIAhHLzuebda86X9pAK/oSDTKRJU4xGRZiEM15APiFyQ7tRiqCQKScNJaPQ0YJeFFvVukRww6/sI603SMc6bqvaOUp67yGpcYhU1BXGyRgmR/EhzhAiYgdDIMSEZBfkipdcyVJltFQaGXpkWXvve+cv6cdj8qNL5JJuUiUkf8psq6XnC3XXgiTkSzDEt3O4KES/QpuNbk8ACGH5pi5WdifLpVedr+jb/NY69ji394H+12JtyltP/j1Lu2hmaqU9w28mT1HQKFIaGCmFeP8qjEZdmNEsJum1HiWXCXFO3fjIpf6l6w9+1VFcVYEhZIAQG81cFUwM5qjcwsPTK4LFRPCDyivEhz7Wzxk0ziFR5o3BC2YIJdBoIUNoQ0FRwEgDhCCQc9HcjkGkz4eTCVCmaxIyQvqn7H6Vo+IW7HjgV80QyohFfzh5ese6V4fFzpmSWErzbPw/V7nIZNVInjoEPtWE8F1GbnlKfJo/jwFCPTsn/uzkMuN1RXt2vt/qg22/vvZ/8d3asi1DesxhwAxmI7UBk9ZvREQn1LDCCkXd0k+fH6BR4egQd5Hy2cgnpkj456NwOWOahzAh/od+HCfzm3H+jXgtk0g+RLznRwNGhDfsxSr4nEFTK/eo9AmIxT2EaM0FvlRxK5ewwxBcC69dvzo3rX7AlZbb0ZawjU7mmpIHM1WrpvcrZ7DfgrksRrwrzJSEiQQysWEGfk+C1SSBB974qj12bXDOdWvHRi+xDa548bG//cevYDdhcOW6SQnLs5MdNh2DSQwHBkSGAQ9pwC994LSk9ozqu6B27j0fvf1LnqVtXTu3vXlDd9OMfjUWJDMxQcRrIA8tvYjbIcNVymkUFlycM1T7bfpG9smE+OVzOl4O4ZH9xxsLHxwaYc9R10MIrUYIILV8DNIo1LA4LOoTn+NiCgBCyCFkN0xWStmYfnM7PSB85M4XbIPKGSAk+Tdm2BCFjs+1Nuwua6DFI3FvQG6n1m/RIEN4dZM13T8mZv5dNQ9dBoStUpcGIJTl0L9fbr43U4bZsygYCKyLUySjCiCkFAqFrECjC3S5qI4NAVPBPTC4DYZTjB3WJwLqcETKfp30Yn17H2gnL+nV2yTPNVJJd3CFdSA9SPihGmPuGFDnFzEGsER9guTuJ1fFhIr7hLYsau997/wV+vuD0uqhUkm3UHU08vCKKpuC6WPBsYnbjca1nPkUaS7x5D0jHi6yJI2X6nCwsOD/NT+0UNr/z/Y+yl8q1tMf239s1rWLp8athNFBPfs7V8/bVgJI3GvULcaHODJRTGV+GqrGuvPAtITiuTfXbbt/d3sfHK8lRifOEAIdxNpN5AY9SncrVvpFm85pCgKETUZ13eDWAITEEPpXbhjUy25CtID6TOoYkPqDnswt9gfVaNzO0W3iseCkI3Vn968YFbtwxwP/22VUqVCzdPzIqXnj6yYmLp2ZWm3W+YV9PA6FkpuOMlWodhPlC3SllnNWoKjUB236gFXvz89oHB+30HnLXz565/MLOScXUi889Gb+YMeYvktnZ6xmiM6qR3ShFh4YgvXlGevcLAeBropHFMJ3hOsMIDpgulz0ScsgBBPxYPQyQn3CCsVMZv3in8zacF9oBdMR5ZVIttN4HoowSXNoIDGwULG2NPbkPAzuhk3XMLz3wtkj6l7c+k4bncxP3/t6zujq8THLTWiIikJBHs1iUHNNNeEcA8IDA3cZ4cmBtKt2bcPca27LTqkcn7D4ft/j/0GIffPvw0WzmiZGr0C9bhBdfP2En2nDyBAfsi7B7JSaYT1nb1z9VBtNTv7KenHbnuu7mWb2r7XoUDKq4cmrIBzVg/ePhVuJ+HHg02vSCYsRHQ2S+W3pjezz8XFL50yo6miAENanCjYN6W3LRUCoAHtaiQBMq/eZ+Bs7XmJAwr5w6obOD6Nxev/U5JLRKXOOHzrVjstDF6G23v2idVD5VACEpBn2GcWwKI4Y+NB/GzNd4bmAd1ezTsGEfmBT9f68jAaL3jcqev6dlwFhK9WlAgil7w+EXgxKq7pIpT1kkHrylAIhNSTHC9CI/sSpkmwwkBuEScL/hIugcAvVJ0vuFNawSo4I6b7J8vf72/tYO3NJz9VLdSrwiamNbXZEN6P/pEi0i1GizHH8LF5igNDbX2Y4pKhn8+Zb2nvfO3ud+0F6dKFcGS2V9wqxK1JNjjLIB0IkfQwHhIDVY/hVq44LL8HU8DFdbhsbfgzRVKa0u1x0hfTuw9KZjv6+33yuecG48vExC2alVsMYoRrloDo3hpLBcrhwXuFhuxYOAgE+/XQgCv4u2vUNs1IdkxKXuRbf/+PJM+19cFBLDAAITWlethnS3Abq+NX8EMLR22rFJNCL3TDlEDqHRJtby2XUv2L9kN75CDb8wITguBEaOVBMvAsJGQ9HqmpBErI91IUBYVZK+cjYBb8JEFK9tO0dy6CyyYkFDPlYdIFw0JxGsY3lURzcTobTBah6gkkYxIS6ADstuWrHDH3hw3c93y4jXmfPnL+n/rGx0YumJ1flZ6xm6JoBQuT0yEuGkB4diI8CCWlelOxkjQjM+Iv5IBzpSN0mlSIf5W77FpKMKuQhN5YUME/zEwhK/8rnErV+yGPAuHmOBgHYU/ygt4UaEyG3EIvyTdg1sV2ypzdN7185KnbRPe7H2whUMPBWNeeO8QlLs1OqcFhOZG2TlphIIVC+oRxA7VWshltiV7MqMDt9tVnjGhW1sGrOnZ//8yd9xcamZwzXlmbGl9q0DA1SioPfzMWiPtDfavyguVX5LLqGibGrpiQve/7hN9oXY7y4fc8NPcw5afWsiRcB9ATyffhEeMwCR3FAKHy2UD4K+Nae3sCe7nFxy2ZPqOqAktHA8o1D+1gM6jp2rwozXtQ5q7lRqlCIeJWNs9+Af4AhZNu0fmVjUuYcO3iyk88Q3r3LNriSAUKyEhWXns8Y8zRCLhmlREceTggoGk8UAML0RgahR0bPu6PmwWOHLruMtkJdKoAQFnU/3dUcHCQXd5GrI6HFrIuXnXEKX6FMK7WMRxPuF/EhhcQI+1gihqyNDdUlSaQarekr+zTSy6vb+1A7c4UeL5Qc8XJFL7AYrYkK1UajCpFgobAIUrS+9fGSpx8oS4t7SpvnyVJnfodt95I+2Co33igVd5Eq+4Las1qIq7lGlISgMaHqaAEIuWpUGc1F0W+skAGjrhuNfOGfVv6/0G3DpX3vtfdR/qq6q3xdZuqS7OTy/PSgVYP8Bo9U8oSj0nmgOWcFlcHCFn02vAzC7jTuSbErZ9/seOHhDmEtsziXAcJlwBCqfMZUnv5HjTjfc5WbjDfNCmcIX4LLKMwQRpnXeXecPP7b0Nf/LQSE6wb3zgOnATCV8RIgZKfRoNj6k3BU6EXJhZI15dzygTVtae6sfhUj4xZtu+/Vk8d+G0ZtPheqmXvnlJTl2f0qbbqgRXE60YZFlUa0wTSCx4xL2JyQqw21Ptw2M//q4OT4goKZa9547oOLP+S19x/fVNrvGB2xCJSK6Y1cxskZG6LjiLtzc36PQLVIWgO/FrIOUlNmgN+k8jNUCd9U+c08SAA3NSwi0OsxzYLkxEBFWoSRKZrZ+EBZSuGHamgQLWq/kiFhgdwOL24+U9i6A58pzjoS5nQrsWYkRcNddTMQbtK5h/WaV7vgL21n3rvt/t3mQZUT4lbZMwKC/1TEt2KthBPpXjHoyE1lCGMbVV6rJmDXB6bEF5lurHzozudlJMZlvPGWzvCOj1+a07/Wpm0wpgmDfp7W4DXzDhuuhSXdP6z33Lr59376Xju7oDNAeGNPiyGtHiMxOI1pFkQ0Q4BGdJoxa5SAAa9YVCJLUtCcsxM1LnZZR2QIIZh+87A+VoO6HkIvERAaMbJF5NTzBAUAOTy/1ENUNh0gAkLvtOQSCKbf18lNZR6/5yXb4IqpiYVmxUuW3kCUFSIa/dUqg4Xcbg1dSWEFhJ2uvIwmBgtHRs27rWrzdwfaSgF+SdUlAwjZm+mJfaGXGwAQOnoDfsNNIuEoWNtj9BmHgmBzL6FGlLxGQ7VEa4gEQvK3xCRDiYK22f9WG8OAiuwfIP9w5DL2aKOSNs2TS/vIlb2lOqIEo+RqrvWVuDdsHASXV8c1O/CiuJLl6mi5uJu8eY4c6rizZ3/sgrGq76R7p8rlPeSKnooulFIHw1nz+OBwgSg+NS0cR3lsPVxK8ImNQShIgDBOroyQlv+/5j33sd/S3of6q+qDV/45b3jltPiifF0wTxu0qv2mNL8BmloRT69xK2wARfaZwoNYFOzupnBz9q/sPzH2r5kUu2R5prt9rUeoFs+qGxe7wqIOWFR+1oyCr0wqzM7xuAXuEEBSWJfobj2YQ9hgUNUNibQ84NrxKx1cfqEO7zsaWLHupt42/I2BXJTeoWrUkytMzIUiV0wScvli2Auetd3TkytHxi/edu+r3x/9zRj1+S1v5N9cNSl2hVnthiR3QEQBE4EiEOx5whOMCAhbolORW807+Ny0uknxBdVz7/ni4wMXeGZ+az182wvm6yonRxeCL6guQLCKJHwWztoBYEPmzY3g30fsEyoSvYjW6HhhmNOiYechiIDQBzcJDvyw14Cmkf0UehFZ0nwMKzJwaE71mVJ9ZvYdBoRS2eY2pXnM8K+4pcHcIOSzhak/N+4YaMasHKaGddf8S0hDaZH7xxlaJQbQa9P6xvZdOmdk7XNb3myjU3roq2Ol9rUjohZZMmDkiSc6ivFLhLthMpk+QYzNTWWMFLym8oAxb5prdNRixy13nTtznhYLvvnkSO7gVZMSCuB/VnnhvNEqjJpP4mEyB+baaQMzUqtvjpzzylPvnj3TztEmDBDe1NOSk1YLQ6pK5KCYv4W1G204bs7IYa3yHcgbyM9osmg9E2KXzp1Q1dEUlUf2H19T/PCw3rbcNAEIuTpauC4TICTbJI0SlIK2W3ikDCfb9J5pyUUjLwFA+MR9L9mHVExJWAVUsFjQMSlD1wQCRX4Mt6IFNOjHDW4bdrrs6UF7hn9E3/mryzYd2fdf4zov16+vSwgQQh34UK5Nkcu6yc4YuQ4j6TH8GtAg9q/UkipNqkI6hch7hmYOUfYGGtFaJTI7liYS5aoIuSpafnu9fOYyf9029YBZLuomVfQJOeOBa4LwD3IrEa4k1QpJyABhguxKAUBYdJW8wSqfv9Ae9HL9fDWflf7+oOxMlsuuClVHhfBpYk9EyEkqa/JqUjh2DguFbS/m1CuWpLWIAGtjBSAEHlgq7Xa+Pl0+/m17H+evrXOnz1bkNU6MXZKTUpuvC9ihJ8ZGWZmA+okuVPjpqXkQhVEEURgQNrAfz9MHMhNLZl296vk2a2F/fS2c4RwXvdyqDkD6H6pGjakuiCIkEkwALWGS4UF+TADCNOfQSOsD7lZgCI/sP9awav3AXnacy2KA0JMLAMxn1PqNXIZEUYRk24gpFCKPnuMEHO/JSq4clbBw+/2/mSGUcWS0oXj9pOSFWUnFdn0AaCs0liQHRUUsSjwhAVHuOoPJeIrbDfhDav2ZyaUz9MVrKx6+mHK4c2ea6xbcOz562czkWpuuEWSZaq+Y0PMhqAP2z0qCLkjVY0gsYNUELboghkkEzJqgUQOfWHTsDMBdAWiQATmV16LyWzUBZEGR5UPFKWA8BIQW/jLcwDOGmEN0H9UgjAQkyTo/9gQFLFrFqxMAqhXCJ7zIKAqlqDI3SDphFdnJcoYT/U45bZinDU5PqhgVs7B+6b1tRDSFQtLttQ+PSVw8ObHUrm80iJFIo1ASorEqF+UaOVCk6E7uMgqIDoYng3Z9cHzMqqXZga8+OUj/+ebg85PUS6dD2GkDmusiGkxzAchECsWCuQ5WHcCSkRGL7EOqPn63/e3uXtz+1o09rTNTa63aIB+c0/IZQiOFj+u4F46RACG9Wwp2yIriaovGMyl22byJHQ4QfnfgxNrih0ZE2AxpLgs8FJysRq8pnqwg3vAV/bCHOHBaErLq/bZ0b2Zy8ch+czs9IHz83l32oeVTkwrwJof3HKOyOKKsAmA2o1ntFbJwbk/FAWF6wJbRYL8mMDxiHgDCn3PivVy/tS4xQHjykPScEygmRyT0miAcJS9EyqaPB4iohNRDt0r/qgw18ZB6chkFvFEbExL/KtUlyXXJcnFXwISHP71MErZJ3Z8rF3WVqiKA1HVESY5IyREtOWIlB/KElBUJn7B/jYWL604GFpEBwnVG+cdj7b33nbHYfX5iHyQ9Fl8RqogIOXAIENBdrFQHmmoO/Ph1wWeHIXmcKmwhwBYGv7W0TBMXqotnm1QbLZd3l8ojmz98Wjr7R8Lzj6x50nhN4dTY4tm6hnyIU2sws03JqhbEESBAbp/A20FjeKHUbUDhKOuBZqc3mFX1E6IXGQesOPPjufbNrFs00zk+bgWDBBA7ofIaUt0ME3LyTStc9RGGEWVH/bqFcghVdTdH5a0PtE4OYVPRxkG9840YOwEMoUppwsh7wMt9L+mb4C+K+wY+lgRWfQxyT0sqH0k5hL9xhpDqo7e/LLU0jeo716J15TGMhKHbZr2fmyJwwxXEJ+R1ycW0fCHAzD3oMXdB5Robs3TepFql9b8I9dkH+5Zl+cdFrWDYnt2lJuDxYPyM3XVWjVCNqsDqg+0tuL3rCKoB/LPqgwACWX8PqYMNGCroh03Lvgzm6Rrs2sY8fVN+RpNd38C+aUEgZ2cgB5IkgGG2aWC5xKr22TTwMT89aMPsCnARxKgx9lNWVcCu8eelB2enB/P1DWwHbDqOlyw8TNLHnWNFQ0nyYJNiP4PKPbOY0c3Ts4fRMzpq4Sqjr+2IhVd3vLdgovvmiAV5GU2AhIVqlAdCqNw/5TCVOAqPEZ4mnCtTA+lqT2/ISqzMubriAf9TMq5B5A5cOS52Wa7KZdHB6KwBgzpgXUbltojsPjRu8RvUdTdcZX547YtHD7a/oG7Xk28NirDNSq2FhAy1v4XMNeyMis4rpAyk9w2FHPZY04PsTAIgjF8xf0p1u+d2/kdxQBhpA03sT9Yv3OIAufCVhuXYg0ZEKKoffZhK77dleLNSikf1m3f04MnmTg0In7j3pTySjFKuDEfLHrPyrihYYhFN6RUye68F3l397FaxpQet6f6b+8xdW7H56GXJaGvUJQYI2ZvIyUOyW8W6zFBNpMQ6TtKOApuBmJAhwOoYnpRNefQke6sDvSi3xed+M6ydTUA1KeRVIJIECjFUFSWv+LO8vUQ+1s6S/U5Y507Ld2fJRV1kR1+pNiHkiIYoQkcMbIgxAHU4CHvEhRx4mVzJck2kXHiFfN9M+dSh9j6AzlgnD8IiC4NtFT2aq6PIhAlNmyh6HkEgnxWM5Ysp3GMGAaFDkLpcXxpLPw6Y0BktVfWUi68KNQzsyFETP1tHDxyrveXOsVFLTCqGExqt2gbos/mat0fwhB6IquctkYia0LgsGhfNaGFwgseq9uZp/Tatf2a/yrHRc+93br9wveWF1MIc5/jElQwSMEAInagaogiNYUBIuQ4CE4r0cNbYsUbcpK6/GYLpn2kVQBgs3DCoTz6Y8TBop/Zyl1H1TwGhyP4y8gEVZVDTQ5EGmcnlo2IWbrvvld8hGZUxd259cOuEhPlTEwrmXN0E7bg+ANNQFL1Nv04Zs1QMSDkgpD0h3x345tTEsrGJy0qtt1/gyfn1dXf1o7MySqYmllu0DQDy4ZyAFtTK+i0dGjyQRksDulC71peTUpuTWpurcho0TrPOZUsHcxRrOrwexIq6gD2jMe/qxrxrGvKubrIy/MaaNi0AABimYpASBI0emCKDUUD2JbqJAA3us8Ovwy/Rgp87mqbBbJXt6oAlw2fPYB0z2A+y02hDBgyms8JiM0EVqml0k1TBgqTlDxc77S6I+EsPTkkozL22aHPDM210YtlDutbx4PVdrDNTnAwPUyqm8NHBdQFYv3Ar+6zkENCB4PAwgAd7RsPM/s5xMctX5TSwm+27/d+P6Td7WnI58mkezDWFu10Y2/IBQmt6wKL3TU4oGdjd+tXeAx2BT3txx1s39rJlp9Ta9AGLVlEA4p2gVSSCPsIDhAHIhJbOjxUko43sxePjls6fXNXRCLQjB46vLX1oeF+7kSSjGrEahaavRuGm25IhpCAiiAxhgFDnZZfMmuGfllI8OqXzx05s/+vuvGFVU3CGEAhtBIRmLqL2clMZRTWKgFkxoMLTBdpR9miwd4YRkfPXlG/+2azOy/Vb6xIDhDLK2/7xsFSfIpf1RFUhmNqHCBk6RVdKktEawTjVonqNwie4iaUAjTjmJFF2NmpKm52Jcmk3uTxO+vBJ+Xx7ujx3vpIYort9klx0pVQV0Vwd11wdHSIcqIhFHcAN0idwEeviQ/UM50fJhVfJd2VKhz9t7yPodHX6hPz+VtkRL5d2DTki4XI4YkLVMSHMcRGWvLHCUSY2VIPRILjJ3GyGE/I/cfetjQ45Y0OOCLn4CsmdEfpkZ3sf528u1q9sbtg+U7VqckwxqOa0QSvo63jrT3iPrx/zFhZkokrmhEklpIZqt5U1hcDABC1ad2biqknJ8z9+54tzZ9ttImjRzOoJccttmoA5DZRvrBNlgNBCyVqUqKYRYlGSawq/yvz0BpOmfmikbYO/FRjCI/uPNxVvGtQnLxdDq1sAQg8/w0rjxXMmKJu+hTkKQscsBgjjFj5x7+8EhDJkABxsKF43qLvNDA6KAdapmDRCsCoS8BjON6OTCuZPgI0+DxoRYQwU1M4ao+yUiimqJZsanz/X9kNf7FesmOGfEL98Vv9adoNZAfXxEAgg4rivDFFVkIw3q59jVOSiG7tbr+tiGNA19/puOQO6zRrQJeea7rMyumand8nWXzVdf2WW/oos/ZXTM67Kybhq1tVXzbrmqtxruuRe3XXm1V2zr+k6g21Xd5l5bZcctl3TdRb7fkaX7IwrM6++Iiv9isz0K7MyrpqOWzb7eE3Xmdf3NN7QK/fG3sZBEdbBfexD++SPirh1ctQqY1odZ3oVsxaVR6GmxWCS2xSeIQSEyR4omz6Yl944s79jYsKSImNDG0EL1tA/8pcXxsQtGBe1bHZGk0Ej9oEbaZKEFW4AINi5QaubjxqyO0HvJ5YJOGeNd0pCyYIJ7qMHTj751zfHJy02prG3BYaxyfqVZghdKJoll1EYS2PvJ2OiF80f5WJPSlsc4G+tXTveYk/rjFSAxwD4tS3REV+1ISNZE19PIbdJH8XQUUALu8TjY5bNnVjZ0UxlEBA+PCIqz6iqN+OUIC6KkW0Spq7D8+4nkC+obBwmhHQiOGowldF7pyUDIDx++FTnBoRP3P+yfWglMIR4oY2KHxLJSXDZiANCnYcchkg+w06UJR3XEbR+W3rQluEfiYDw8L4OcZP/0evSA4SSJP14VPrLeIguqIyAeae6BGEwE0e9rAhPo1A77jSD7SymooHZDPW78TRJiINPCTSIKJFL/qorm9eMlva+1N5H26lKOrJXXj1GLu4Squ7bXB3T7ECXUUwN4XF2RBLyobUYuKb17LrEysXdpKYR0r8vX45WreZz8t5dUtNQufBPUmUfnOekx4RmAkXIJ+D2GMoh5AO3/JLFhYcGnWTqG4OrKuxjdKguLlTeQyrvE9polc9e6LxZu9QXH35dnX/72MjFrOGzgIjIz5c/KWdCSfQWroMmPtVG+fU4TIj59exPo03rZ+14vj5oVjlH9Jq9Ktv/2T+/bi/R1KJZzvGxyxnKNako9toLbAz+UacJKAP2tZS7gM6fPhrby9OjqUyUZUNrSEbBxaFk86A+dnAT0fjx92KelQaGCQ1KBqASRYiskQGFuDjI56ILMT2lYiwDhPfs/t2A8Py55p1b98y8pmBUnwVzrm1ip8Igog6NwkgGp0O9irKRYH8LxoC0ZD67vtGq8U1OXJl7Q/GXHx9o62HCt3f+yzaofHJ8oQFsHmkCMID0HduTICU9wPgfhGQARBwbvax+wQOP3rPz2Udee27r689vfQ2315974rXnHn/t2a2vPv3YK08/+spTj+x++tHdzzz66tOPvPLsY68+txVe/Cx7weOvstfAKx97Db/JfgR+ir3mmcfY62F7+hH2kf3UK8+xV8I/vcJe88ITr7Nt5xNv7Nr+1s7H99xd+2h2SuHMVIeQWbp5wDdFfUC+n4eIYkM4/MPFmUONG4YS4Tx7p8avsg8t//Tdr9vo9H789y9r5/1lSI98M6VvhxM1SAbpFY8Mv1eN4dgSTvRxkxidb1ZqTd7A+kdWv7J84popSWU4k+w3CkAIP57mAkyId5EJFapZyeVjE299/ekPzpzuEPIKBgiHROTPSnNa9Q0mUlYrtA+Jk5GONolccoIBxBBy8jm9yazyTIxZNm9SB2UIR0bnGxggRF2oUQk7EZdViZk14LuBBd6s3GYBCG36gE3vm5ZUOLp/5weEj9+3K28IAEKaMmi5eNdijNCD+a786VZmCC2YkgpnjAHCdN+oyPlryzdfNpVplbr0ACGW9N4WOXidXNoNUF99IgpHEwgHQvP6k+DseJmMRikhLWyRjxOGoBdFk1L2487EEHiTxkr1yXJ5b6mwu/Twgj+KUf4foqSv35KDQ6WiLhA4UQOAsJkhB55+HhsSKkRMqxeAEIxGE+SSHpL3eumdje19BJ2qpK/2hNZb5IIrpLLuDPWh9W5siDuIxktcIIqWvNU8mF4W3rwhPqMbG2YFnbTsAo6+RA9KpV2l20dLe19o7wP9nXX+7PlH73wmV18wOa6A9aAWGM1SdJX4F04bZggVv0Fu64/MhiKHY625nQ9lBaYnlo2LujW4csNnH7aPy86imc5xscvJPsSoZTqhfQAAIABJREFU4hODRpECBzaJKiVOzSNWyoG7YF14bmrd0CjL+tZiCIs2DY6wM3QHsRPAEMLMlUIGtrDtoSgzSIJGApO6cBe5VmSllI+Jv/Xxu38/IGR14Ksj97q33tDdPAOj53Dtn19HAp8GxXBVLTA/N7zhQY5EHdh0DflwlpzDIvJdi+45+E3b2uq6FtybmVowI6WaO8SgLpT8SOzpAQpGA0AI8SeenDTnxKQVLz3+91MnToeaYTkCtpCkLEzQ51AhKSQ2/k3lE3wt/8GQ+E9gE6+hnxIvVb6U2VcS/y3vv7536QT/1MQiUtuGVZci6qNFoB/nCc30oGH+Jzsiu74hP71hVkpVVuqK28q2tNHp/eHkmSf+umtwz7xp/Sps+qCZdknNQawJlid8BnGfiJUCYaGhbYGLdD4Ajbq6JaNX56Q5Zvavs2iCsByT5lbuKFyaoaxzENTlquonxK2ccU3BmR/OdpBpu5ee/NuQvvkGTT0BQqTNfSKTw4vZDII9E/JRHliCWNGiBUDIXjYxdtnciR0UEN4cmZcLgDCAgFDkKIg7UySUevj6BYhFeZQCu2Q2eOK8DCON7j/vRKcHhPe+ZB9aOSWpwKzjDqJiCcDDbwA6V1qRGKTxci0xEMh+EwrU2TNlTfeNiJi/umzzkW8vA8JWqEsUEMpnT4UeXwFytcpeUn2cxDADOMTEC24wTmEwaPYJxKIcEMby8adazm+A3SXfABAii5gADXFRN8nZT3qhXjp58RwCOndJ/3xC8gyQS7rJzmgEhJFAJdEEWrVQ+SrXjn3O0GB9Alzcsp6SUyXt9LT3EXSekg59HNpaKBX3kYuvlKoj5VoUgnIoiEJQnkMYpxiKohmskIw6EbTzcdxYJYsCV1jYC6Llsm6SNwNSPUPt7JZ+IbX3vS+8i+8ZE7UgN7WWNXBcvih6ODIXtYiEepoIEglvoCA1izA9K84QMjSYp4MQi2lxBZkpK++sfOTLj/f/751o7Vo8yzk+bjnOOPnJTVRsBAgpMwO9NFXcQZG8NPL0jYbU+iGR1nW+py58DPLI/mONCAhzwS8EACH4iwrlqllpKQQwoFBjo5Z/0yBcPbL6lY+Om//YnS+duABAyBDLJ//4Yv642kE9ZhuRg0Kc7Bam824ChAaRgWFUMpfVItudY1e/Xd+Up22YGL98RHT+9nUvH/+uTQyr2Q6fPX3OdGPRpIQiduoYEAVrRC1K2tTExsCGTaofkUzd1KSyCttfvmiPW+4/6sBX3z3gfnJM38VIAGK8IQ+c4AEM5hYrLMK6EJGh1o2ziz67LpgPlpXuqQkrzQOLT59qK9T09ksf5V5bNrLvInsGO8N8UlQ4S3lp/aKFsJkPwQJG0vlRL+cT3LvXkFY/M8UxK8VB8R4wYKkSj1ua20D+pZxC8WenVE5NWelatK5Njup31a4dDBDONupcVn2Q7FXIJkSsiAFjZtb6wsOEGm6Qww+KvfvpYYZwQtyyOROrznc8yeiaki3D+toMKhfaqPp4sB6qRgHrivwMmo1EPIzpi5Stx+ANe9bSfVMSi8akzuv8DOE9AAinJheiO5R40ybjJW14C4f0iHBCAoRmUI16bPoGMJUhl9HLDGFr1KUKCGU5tPel0L3ZUnlvuSYShIX16IRBUfUiHk0S3EWIt7koe+Opd3GobeOJ9hJiQonbacSH6hKkqr5y4Z/ltcMkSKG4fLO2QkmvrJZqVXJpd9mJoKI6SqqJDDliQw7iBnmyucw/R3oQAGGiXNFbqkqUthW19xF0lvrus9BztSGnRl72J9nRBy5EbTQmtVB6pxLgSXYyiNXZdXHE8KvjjA1LRp2Cjeefx0r1cZAzWR4hPbZcPvLv9j7UCyr2R33PC+/fOto5pu+iWZDILMaHRJMqPnebMa/c+JOgbT7+BH0DBMF5wYJfG2C9rEXlGhexZIa24O6aR7/598GLzAAsyakbF78cFYYECLkjDvaybmUS0sAz63jiFmuM8vRBo6puWIwNYydaARA2FW0iyagFluR9wrDeY6D0KnLpUPH4QSTlhPOn0CAxeIYzhPMfvTBAyOrksR+f3/LW9d2NYPihD7CmnALcRaAI/70tAIAPdcIuE5eWESBkjW/Qrms0a13D+867ZXzd2y9/1BbC0bOnz7+7e+803crMlEozuPxB/CBmx/vAAAbkWAGI+WKYEPxdPDNSqsZGL3n1yfd/OHmm1Xfmt9a5s+fffeWTUZELsvtXUt49Ka5pJYVOspnyDJRFAXqakCo0o9N9ni6Ylx7ITikbHT/7gzc+b6OYvm/2Hl5T+NANXS1mndsKykB6/PmglFHbYohOZGOayEqREJHWT64kFsz8yFXV56TU0ndwJBUPWUUDyV6QjGpwDE/nnZJQaL6h9P1XP2+Lg/p9hYAwP0ddB2SpEjKOI4IIBb3s7dGCzA+wRjqR1EcRMjgzlpcOgHBc7NL88ZUXM5rl19SR/cdXFz4IgBBjJywaGh30YIYnBpPqfKSGbTE8iWJmTFpHAWTAlu6fmlQ0st/sowc6fewEA4QVU5MK0SvYR7oY7sFLp4gbjbpFZCtO2OI9Y9KhDY/ea09vsKT7hkcCIDz87eUZwlaoSxcQsgrtWRcK3iSX9QzVxjbXx0vkEAP2higERQuZEEw3xRCPgdwgTkA5E/kkYU0sx5AiSA1jtQX1Ud4LMOHtw6V/PfWHs0nsgBXatkqqTpRLe8oU+0GYsDpWsS1RQuoRGcIFBSaqPpmhC7kyUdpa0N5H0Cnq5EH52SrJrZZLrpQrewC6q6bECFKEkl43ni+p1AivUfYCBIQIFNG/t0aJcsHcF9BdY4R9XZxc1it0x5jQB9va+1BboX488eOzm3YP6W2dlFxq1/tsWq9N47FBzjIsD2Mj6wXrRT1Nz6OqTcv+8rmINqTkNG6iiCoj9ufQpgvO6OcY0feWTN3yteVb9n9x5GIeEQTTA0PoR+MK8E8X43AKvgVAaxEKWIvag1l2nryMBrOufniM9f66Jy48h/DwvqPBletv7GnBMcuAEb0xjTh2QlNJXB2qEplvIBl1GynWjGSEqMrL6lcxJuHWJ+77PTmE/1FHDhyfO7ZmVNTiGRqnNR26f6OYpTSBnSw3mTSLPAwz5YmrlGhEwQ5pvHnpwZy0mht7WO+ofWRfG1zfo4e+L8m9a1JyQW5aHR/T4lENyGxoPWCCrwvYcWPfn5ZQNKXforaWsP76+vKT/cYbK8fHLAcDWxC1UgQFbx+NWnIpdHPlnsbLwxVpIQZ1ekC56wPZ/auG9bb7l2488d2pthjKPXem+W+7PryhuzEzsTBPH8T5TLeF+yjipiirtfiwqzFRAyWUJjEBa8KjM6sBPHCFtpBqm8ILHIh+4XHzGdOck+KXL5paH2ruQCzTrh17BvaxZCVX2UGcjKAX1hoA62KAJ+FDD0eDQOZ7yYMXgAFGz+VnNLEfHBO1JG9M+fmzHQ4QNhZsHtTTlJPmJKbdTP6ikK7px9QWLga28H/yCpmAF3Ta7G6EiTj/tOTim5Ps3+070bkB4Y71r+QNq5yWUGDV+smzivI5zLSohyt3Zk7s8/QOfKLRcVQHnsbsoz0DZghHRM5tLNlw6OvLoWKtUJc0IASQ9urtcnlfubR7yBnFc+oxsF4WMdnQ1DoJEIanBymOAk0yYkViIbntx3H3UdbUsh6XfazqKRX+SVozVD5yOZnwQiu00SaVRcvlfSiqTqpV/CrjKZiepxfwYHr8yGCGK0mu6BMqiWheb2/vI/jj1/nT8vNOuT5FLr5SdvSW6qKAhq1J4IpQZfi2mgSihP0QE9LnyBkSCU+pnvC8wARvInLs7Acj5YJuzZUx0t82yM1n2/toW6c+//Cbwum+9D9n56ocNq3bruEIEDboCAPYMXDm0MLZQpqkdxOLSC6dFtTCQZ+EHjMz+9WM6HPLmLh5zrn3/fD96YvmLL84p25C4ipbesCiQ0Co9uaqPGFXADV3VDfRJKSGN+JWjXdOetCiqx8Rm/eAZ0erxE40Fm0a1MuKpygAiYgcEyoeLV4R+SXaL9gxH8348ddoPVn9GSC8IJdRpUIh6fjhk6P7zR8XtxIUv1qvoUUogpFnXRBucXNMKHz2lckiGOHTAx0095qmyQlFw6Lmbbzt6ebzrdn+MuTzzWcHh/ScPSW+iOI3uBErJmUbVHAabWqvXetHr1H/rP61k+KX+RZuOH6kTfSrv6MYoL2vdvuoyPlGldOmhxwzDrEQOJkgpR2fI27eA980K7l/OEaIc5JBs84zOmrx8Mi5335+qI1cmr74eJ9xQMnQHjY7LOUEwg5SYu7RjHiVNHL4DiCwKw0cCtcNHs6m4lYlZlqFEbJkSrBg/8rg1vSk8hnqwjtK22o28vfVi9v33NjTnJlUAUHkKgS9yH/SWpJReS6UeHrggsgZCJ4R9lxADqHWOy56iX1s6fn2s1n+2Tq871hwxcZBPYy5qXVgxURTkXB0flirUnmFKECMTVLynpYIYYhVyEsP5KX7M5OLRibnd/pg+u1/3W0dUj41sdCGqfRmGqAQqlr2tgnvnMQHKoukGpFNAksGMOpsY4AwIzAiYk5TyYbDl2cIW6MubUDI/jSe+Db0gie08v8vl3eR67FnrYtrrksIORPRJyaee+UD/ANFKLW8ZImBPW4MEiCUVxHPPTOEd6JUlxiqS5IckXJZd7npRvnkgcuY8EIqdG+mVNJbrojgQJ0izvkcWgJQgjWI5JWIc2B9E0KuJIiwL4kI3Wto7yP4g9f509ILdVJtklyKUZBApMdKYkFE4rnzLWLoaxTnGMqcYA9OAspK47iytDqOA0JaSWFPU9mfpZV/Du1qkE7sa++jbbVif9o/+/DrkZG2KQnLrHqPVe+16Xx2kFx60X6dlpN5MjU3m4Eu0CWEZCKaguzLyVYeUCWDZO6pCQXDI+YumOA6dvDUxcGEiw3OCUkMEDZatEFkCL08lZ57JwpLPfDQA1qMorctas/sjAarzj06dvYG/1OtYCpz4Pjqks2Delups0RnUQEIteGEekrCMGBLwUOi1cowD5zVzOSK0fG3bL//tQtnCGW0S6mwrR0Tf2t2SqUNlGMQfIee6V6THgInaBLGpHGRyBa7YZT/IW9p0bitwmOdnUN7hn9ExK2LJntfe+r9C983pU4e/3Hnw29f+yfDzJRqMJLR+jl4xhOIHpVucpRBHtibnVwxNWXxgS+Odhyvf/ZM7f/yyNi4WzKTSix6BqH9LW480Ohi2jsfUTMLnTaFH5JvKsQb6mGb3q8i409Ze1745+lTbbICxc72M5vevLFnTm5aTV56A4k/hSDcI8IJlGBSilnzCqbda1Km0Yj3VgmgKLINSAqL/5XPCjOogfHRSxdPq//qXx3LvGDXk28NjLBmJlXl6cG+yMQnBuFa4DAh5+0BEOq8ilKUHSkCQqAT7RmN7JyMjVlqH19x/lxHuRWpGCBsWLFxYC/DrFSnRRckD1V+47Frp/JyoyBK1NDxFUAOCHVo5KsHhjCzX9HIfvlH93d+QGgfXD41odDKbgadT9iKes3KuK8AhPClziMcZTzEJJPyFlQM6YGb+85tKttweYawVepSB4Ry6Lz09VvN6wyg7azri5pPsgylGIkEBd3xhAlhfaF8yUekSFkqRKc4eYjDh864ZvbREQGTbw03yPvf7zS8x8Uv6Y6JUmkvqTKCa3QFICQrSw48avnoGtKDeDXrAZOHCrqdXzuxvY/gj1w/HJFeXSPXYcxmJZq70shfNXcHlasFN1sTF0aJnCFEnxgKaCGe0IHfJyqetuoYubybXPj/a15vBG/eP7KXzP+tMz+cefOZd7PSFkzvV8z6HhtrtYF+QV8WaO+otxMKMZwnNDDMQJ+jhaCBzxxiy66laSgvEiP1WUnFIyJvsQ+rfGbDmyePtXlExxJj/aSkAhhlBN+L8J4bxZ4baYmXbGaI88TjgpEPrWtMwpyNwdZwGT1wfE3pg4N62zHrHCSjBjUuxqtpOTmc6MAjv7UeZY2Zu3poyJ2/cnTcrb87mP7/1refHzIPKRnRa+6s/pWswzPj6AtNMJJNAsESGAAjg3XMJ1SafqvWJ1YEWMcTnNG/emzCAn/R/adOtFqq7d4Pvl4y0T+850JDqgvcYrnzLblf4o6luux6pAf1YIWSlVhsG1je3MGmttgttHCMe3LyCoO63qYPWHUQcy+yRtyov/UpKEsBhGYVQG4r8fM61oX7jVrXgCuNhdlNn3/UJra9oZB08OvvxibNmRizEiS4+qBCD9KMGSagYDi7htMgeJcqSxhus0go4fiWcyncjxFsitJgXteQxm6eoCHVOT5uUfWC2zuaqHLXjj039jIzQMiQD6FB4uoBHHJYi+nkCJkEI+oT/ltAqeVd3cROwrjY5XMmVrZjEOvPFgDClZsG9zbmquqsyF+JCBCvshnFJ8I6lUekEkNoTQ/YMgKZ/YpHJs/p9IDwyXWv5A0tn5pYQH9EUEjip9CgFpkTcBtYiBLUKpuHrFnZaczLaLKn+4dHzW0q33h5hrBV6pIHhKzOngx99PS5eo1U0VVmbStreQENcoOZZgqW4PNRsSHe8gIrFeIOimEHGolwIOcJ0TwDMGE8/CdVfeVVV8h3jpb+uU0+ffne/T0Vun0spEcCNwUDnJIjSq6OkmuEsyUBdYo7rwYtYsgZDRexHgx+Qiuvam4cdZmh/X0lHdkrPVMpu3RySVe5sg/O1iZIxOxVhzW6NL3J3Zic3EGUPx3VYqTQyW1Fw0n0IMmOlqv6yIV/khlQ3PuifO4PGTz4CyWFpDOnztxTvSU3fdWMfmUWTJJgrb9Vg84QaoU4EoAQ0KDbqCTpKeQbt8d0ccCg89n1yOGkVI6PXpI7oLjEsvr1Z/5x6oItW36hVpn9UxIKrGqfBffKjNb51HbzveVxGm5kaaDdIW1bHkpGR8Xlr/e1DkN4W9mWwRF2xFc0Q4guo9yrg/fKHA0CShRRH1qR58FnCCtHxd36xL0XFDvRsiRJfuTO53MHrJwYu8Sqc1t0+Bs5XRAOJUOnGXeLmHIvKYQtRBqQ9Qh4zPgnxK6aeW3BuobWGallt+LfXvpwZNS87KRaTKL3h8Fz+DaDNQubLpCX3pCTVp2tKbyz4rFW+e2tWBD/+NDb0/XLZ/Yvt+l9YEmi43QZPDuIbBUcSGJRMq6won8Jupiwxydg1fvHRS8bHTf/nVc+aiOO/fSpM9Wz7xwdOy83rZZUo1xcreJPNE+e4P4ZboqtF7pitzBAIm4w/CU3YBReo5BjmdE0Jb5gzvDqJzfsbosDuZDateOtm/pYM5Or8mCVgZM8ZCrDN8BFfqEJpAQCNw9vAIjlz7+mif3g+NhlcyZVdjS4i4Bw46Dehpy0OtDEko2qmA0mJTCPT0AjrlwuYsclM2AIwWXUluGfBpLR2ccOnuzcgHDHA7sZIJyWVABzB2QNzUlyPmVtDgdR0uigF6bu0SoMw1FBVpN3dYNV7xsROaexbP1lQNgqdRkQYv147Pzr9zZXRkql3dEFMYFmCOWaGECDdfFhRagw0McmOEam4DUFE5JPhhP1oqzHZYCwLi4EGtQ49B2NlEuugmi1N/4iHfuqvY/5D1dSaM1wqayX7IgCvO2Ihg2MRjE9EiWIfIyQYg9qYyC23hkDrpWOSGnlVVLDSPl8GzbKnbNCzfJXb8pbF0t1aVLRVc2VERA0Xwv3M4z8ibjOkACEHPhRAD1S5UjkohtTtQgerCFnpgQkDJHddUTAo8Fe8/rd8pnv2/uY26q+/niff+m9OemF05NKueZT/M3DVU8SMXJfSiN9ZMhQDNYbVS7c3DzCHhU1dn3QrguyZiKnf+3E2FWjom69dUJdY/H6l7e/0yoayP+oc2fOl5rXTEssNrNeNg12yQzDex6jEgenUQIAKVPRzf0S1d58fYNJ4xwea1/nfbJVcghvL3tocIQVpvU02FWA9FGQli3c/HEZnsbJ6KMLRjR53JlnekrlyLhbtt79cmsBQlYHvz5aNee2MbHzs/oV510TQEDoVux2uKO6msJFPNx45qenThktY80lazHHxCyeO87xwRufX/i+Hdl3YkPD0zd2tVs1jTZtQPG3MPIAAA5ZQVGpDVi1vsykYtvg8n/97csL/9WtWwx4nzjyg3FQ4dTkAnZ6LaQu43S02yRG7EzhOxNH1DggRGsKndemh0lCg7puQNfcR+7aefzwqbbYVYZd33j6g4mqWyfHF4KHis6PLpo4AUh+vGoX9wsVgXVm+icVbdxHFJ8jt8LlckCIP2KAMxCwpQfHRi9xLbr3IhtN/ZpigJA9rVn9HHZdQAQtipwJ8l/BL/mCDk0ShiPdwWU0/+rVNp1/Qtzy2RMqOprLKAOEjas2D+xlzE1zWtE1h5bGLILdUp5ujJ8BxYcRiUEzB8A+a3qQwZupiYUjk/OOHzp50WbC26W2P/CybWjZlMRVVlAFK8O0PwGEXCOtxukJndus44kdMGSBt03e1eyMeUdEzm66DAhbqS4DQlFnTjY/sjjkiJHLewJP6ORzTYA9nDg0WBsOIRSixGgle02uVXhC4XdSG9PMMAkCQgm2+FB9olwZIRddKTUNCj1fJ337bnsf8x+qms9JDYPlUgCEaFISIzkoeSKeU4L4CcfntXQJkKetjwcisbC7HBwunzrU3ofxh6pzP0h7X5S25MMJLOnWXNWnGV18IG/TmSCyWAiQC4ZQWTSpiQWHXmHFxIPpyYAX6cFQjbDnhSHbbrIzUX66Ujp/Wu4gOcptUx+88WmlfW1mysqspAqyFjBzUwGPAgjRdlIJJ3QbdG6D1i1MR1yAElUuCu01wShUwIaNIFKO3qyksjGRi8YnLFw0yXW/e+vzD73x+T/3nfnxnHwBJxXozR/PHf7m+BvPvr/tnpdvGeHNTq6yULgWyB3J+TC84G3CRpZjDBH/YOKAsI4BwvWtAgiBIXxoUB8FEILXjlHjN4o+0iQoFI5OBU7AHSNACBK16f0qRsbOf/TOXSe+a00w8OLWt+aNqx4ddatF77Kmgy5RBOLReBinf1sAQreCFU0C2GBLBMNF05LLJ/Zf6l7ywNnTF6qU+/vujxdP8o2MWDw7Y60VAaERVIuA6ol6UlA0u7VyUp1TklYV5TSea5tUhguvIlPj1JRVs9JqLHpFauvhDLBoKA0tEupJcmlBl0IxSRiYfW3jwB62ldOD77+xty12UpKkU8dP24aXj4pckJvqzL+6ET2lfLAwoVXWetwmlVckmPMZQiMBQu4cg55Dak7nYtonAUK8i7SQr5idUpWZVrh5zTMdEE7s2rGHAcLsfjUoGeVJg2LCE59fovd15DNJgliPQIwQ0ZmfsZpdrAnxK/InVDT/f+y9B3QUR9Y9fv7/b3fttclBCGmiAkEZ8Dqss00wOSflAAJsTBRCWZqoLCEkkg3G4GwyzjmubZyz1xkcABNMDpKmq3713qvqkff7dte7FkZAv9NHZzRJ3dU1o7p977u3jfUQgsuoAIRdJSDEy1LykhNJfLF/WEnZ6RpfFOohxRdCDKhkERBWj7Itvik07QIAhK+kXisAYTZ00ePnVOXxVsiEej16BP5LAhpMVLIOSukQcDo1rjoltvLGwGn1hfcZgLBVygCEqpjGD36r3RcPbWmFXaDrySO7pHDti14yuv6tBQgks0S5tHXLDkNCIz5oIIRcNc1r5l6z5sawBEcAz+/A3KHahlv5rjd5k8FZ/YoSIOH0EVZ1Oc/rAnQf6EWJIQz296qpGxqmn2sASECvC2kiAuHndeXV1/B9n53tIzl36uge9sl2dtd4YGULOjJHDx+0AiKWE4DQpW8WpaO2yJZazIFEe14z8z9kUSkUpBTF5xCRXtCZu2xs61x2/OD5jQap/vbYe1kTa4bZ540PLYyPLEsBxqDGn7+kXLb9ZFF0eUK0hA0YW19KXVIUck2LWrGSQMZDrJlqUqIqxocWDAmaPTgoM2FAbu2C+x6/79VXHnvv/b998f1XPx0/fLK5sdnXrP0LT0WxFhEA4PCB4999vlcskV976sMnHnxtbfn2228pnxJRMNZWMCXMmxxRnRJZkxRRDZuKg0dLQLz+3ZdsVPTGJ1jzpcfWJUSU3mzOuLeyFYLpD0IS9ENXB6QiyqrGfkWyd9edPCvksjJCX1zKjGOKgydACDmEppkbVzzfuoCw8WTTPbWPjQifO9KWnd6vNp4o30hShMqTm6DoAkqblIYKZKIQKVAuPCQgQWo0LKCHmrLGRM57+bH3fws30tzoe2T9S4OCbx0fWpwe1wD5jVEkqa1KIPN3mc0AOEpMqjGh+fED8u+teqIVR6Z1a9ualxIvLxT7mRyrRIZEr0WUy8YtlW2NGmZybZE2HslINYjb0y9bOsKWfWNQxrZ1z5856Lus4OERvW4fE5KX3q8OPrAxVX42WJEk6pIBXG2JR1dhCqWIlxapEFkhfZIkLU/JJcAkJ/QuHRQ4d9HEhjef+/QMHcJvKTKVmdzbmxqzJInoQT2VHj+MYLcTXYnmolUyRjJKAgD8qCJDGFMz1LIwfVhxW+to3b/7cO3CB67qEj+lj0d8rMgvJ0EJwqVmgVLpkQX9xenGXsoUCKavHmVffFOYAIS/k0PY2apH7n459Zr80cAQVsso0Si6goNXo8SAyBwmJAajEVHDv0LJpiZhl2lKHMTTXy8AYdH9B/YYpjKtUAYg/EWxna/61k8GnrCoO+TOl1qB3CvFkDQIoDczqRE1KwRoRXcZq0SDLkpIp4A1C7ZaWZEhFIAQ/UgFLBTv6ezBsy9lCztoKwbzb142MOG/LwHXD+3iFf15fifoIXSZODKEXCIQZfaDwlGNDEucKPeFzQwtagLVVAxgnz99to/kXChfMz/4Nf9bA6vuzxZcyhd34k5Qioq5Dcpn/CBokCoBaR9oH2rFzAmr3kZIFqPcQyStVYYTupWsWrougTMpBJzDAAAgAElEQVQTL+7GigLZAxls/+fwp88vL5l/Vq88/tbc0d5h1jljwgpTcGGK4VQVqCDCNatsJaKI6gq/4ggWf2CpLwPrUfyWAnb2VWmx1XA7BuzLp/VbkhpbPrVPwQjzvBu7ZlzbOe3GHpmp1xYvybn/mQ1vvPfqZx/t+PLvH3771afff/PZDzs/373ryz3ffbV31xd7dv5995cf7fz03a/eevHjbXe9UDHn7uk3uYeHzbumW/qVnVNu7DZrtKVgSqgnoXdZQp9y8I6PqMJYc1BsJkDKgup06kt60Qp0EZR2KQgIy242T7+n/PHfnkN4YM+h+pwHru2RBkgYwqyot0Q3ctAz3HDFSZfq0b+BeIkE1Yg1LrRokPm2TStfaF1AKOqj178uSF5+XcD05NgysZDFNpjKZFrsEi6NJv4KXTElJShdeWilSMyhGN7U6JrJvVyDe9465S/5e3Ye8P23/UW7vz3QkP/QdV0z0cpyCXIyuDwlzV6EDGkQI4ldduXDzAuyJtXuamN+lS3r0L5jc8dVDLMtBFEZGRVGV+knV6dbpV8O0oNk6YRoECaM+Oykx9amDai6qmtS9eL13391plQku/6+d+ZQxzDL/GQwGQZQlKSyBClmUKdHSGKdIL1nKbYELigk9VV0k/QXRW8k6JaszIium2AvubH7rfcvfeq3X205E/XCY29KQAiKShKLoiwCD0H66GCiQBKZcLZoJENkWJnRfykAQnNWxlBH2zG8pdr/46HaBQ/8tevUKb29yWi4hb3TytYIbGOr4klGEVElzhcGjeBJJHgjAGFMTWps1ZgQAQjTz/seQgKEo+yLlLFQRYK/l16/NgoXzkhzm0AiW7pYEF2dKDbxxRgnxrnyhp7TG4oeMABhq5QBCP9XHfyabZ7NCwNZYaBWFuYTaLA8hDqm/JwhIj2OqjmAfJSGp6fSeyRnSCaKTHUbUgOV9NVw9OA57XnWn3llLNv1Om88fiFwI/99aT62awcvj+aFXbgriGxFmTNIcwQxBzSnMSlWtGgu2dWmYg8ECLeBS1B+N+7py99ee7aPpG2XmIS+RkCDq27mi9vx3Et5cQB3BqOJK6Y+uin4Uco+BQLUFPUHVKEEhL/kA73kIwq2vdxjZ54QVhoKH40yO7QjFgX67onXvn7pbB/5710fv/bF4nG113e9dWqoVyzs0qKrIbY+tio1phLD66tSILsPVqvJ0TIjLkGmk5WhwEayB2Q/kxTptyhMBvGYWPXWTIurxyz48rH2xTd0z7yiU2K/DhP7dRh/Rdcp1wenXR2UNCg0c0Tf2ZMHZKddWzjthpLUq4vjB+QNtqRfE5hwWcfxsZeOjms37i8dp4jXjrbmTgpzx/cuj++rVIURgE7j+7RsgatMVB6eMhUN/ovLBIUUsZ6LqxMY42ZT5vK8h4/+ZjdUAQiXLrr/moAMOOTImvg+JFtFlw6J93S9aCWCVYIHwL0kEeWCcGhceNFA86xtq1uzh1CvF7a+Obb3/OHmhbMG1GfE1abFwEoRnUXLSSlHPi7S+IRSOih0LlKXS1UqH4WqyWGOIabb7y1/QqCg/25/Hl33yuS4vEE956fFLEmUxIs+bQS8h9TslMjq5OialOiqKb1KxoRkL1n0QOuOSauXI3PF2NBFSX1L06JrUiMhOFGsrRMowF1Zd2BgA5rNoHZXEjjYM5mCwejT+tUP6Tl/bMSizWteOEP7yTSWk1w93HJ7ct+yzJhlegJbSx/URNkTWJmkm44oKomI3PhIiQYhmDQC4j1T8CKIQErDey4e3XvB89vePEP7/xvr+UfeuKJT/KReHgCElMqA5E8CmWbBhYlyAk5JemaDvI6DH96YyjTIrakeZlqYPriorZnKHNx7ZFnuhr92mRLfxwtXnXBqJURITxQ8ihrsjcSW3QjZKSdNR/EnXYUZE5ojAOHBPed5MP3W1c8n/7VgpDWbTjQIOhQglCJb2Vvbog88gqSkVSiHwWD62CXiPyZIRgvu2/+DIRlthTIA4f8qgT1+eIfdM5XndGBFPZq8IdD+R76jAPOIJITcec1lI4GoBISEQIAzROZE+WpgbqGZl1p4y4wKr1gom2G1vegSVmTVnnGxY233KuzZL18je/9B7g5jRV1RJiqliZpAFA4TtBESSStNTYAqJLYQ3GUw8Vwr6MaLrfzpwrN9JG27Th9lnz0KvkoLL4J4CUcwd+sJ8pjzIa99ED60ak6izclc1EoxLVyeCOwqhMsiNnTuRVjotWuldlYWwkvtoOPN7uRrGOz75PELhBhsWb5m7fO3v104pOLyS1LG2YumRVdPi65JA6KvMi0GkusFLEzHewS6SxC4q3c5uiaixai0nahUroNlCCqUZz1hRVpzRNekx9VN71efOaBher8laQJb9vVM6FU0JiR3hGXRUPOcQT1n3xww64aAGTd0h+3mHjNH27LG9S6Y2KdkaqQ7OaYiLbY2I7YuPWYJJGT01SVqJF6tjO+N+6aisSXJqbftkV98JMa+RVVPi60TOPZm8/RWAYQH9x5elvvgtQHToCVMAELVtRiPjotAB0VV6mtrMqggHRrtoXgChaGNDSu+OXjmtlY1ldFLILdNK567plP61N6utAjMqkY6LqEvLugjlVZQj8iTcZT+rA4FCCvTY6BNdGjwokE9Z37y1tf/xXqx6XTzHa6NAwNvnRDqSIuuw4zBqmQ6ZdGon0SMmiKps4ox1rzpV3u3r3651YeldevZDTtuHVg2PiQvI64mOUIcUW0KXh8BjjrCD6vkpAXagVLsqyQFh/NhWlzDhFDnVV0ylhY/cObAxvqKRyZHZ4+x5E7v1wCigL4VlNKpjF5VHn2kHsumAGGEVD7HS/sfiSQpaVOcu9SYJdd2mVY+e93XH5+R8IzfXs9v33FFRwEIXcmR1XRRBhnCSr3XDr2XqvD6TmWyyhhIilJ2u9FV6cAQVo+wLswYWtLWgukP7Dlcn/PQlV0mx/fxpOKXtvQXjcBQDUwMUmy8dLeSGUIKEIrPXVps9ZiwnJtCM857QLjlzudTri4YZVuE3zxVqCgpT1DXRNTlD8qMVSZqKDMBKBhTlRJbhRbBtalxAhBOr8+/74DRQ9gaZQDC/6uaT7EvnmX3xLPcTlqxwIShzaUAC7mXrBGtjJa2iDSID0QEQt2DVgxFIJNSM9wPq2RChmZGy2II47Yxrx34xpIePL8jL7KytePZN68aKYX/dzWdZM95YDwdASrjDjChBr4+wShctCoDWIs8HXCnTeBDoHNLbVphD54byB/OONtH0oZrz4d863zuCucL/8QLOkIahAByqBHF8bSAiw+gQauK3wRKEOSjymIXPhEoEJUYUnxYnBbp2esFWCjmPEBBdxAXqH5xh+aav/revJedOm9tRf91NZ5q+vK9XSVJK24xzxltzUqPKZverzYttiotrgqvfdaCCyICGEnKwYIJEaBcJ5HUEC+mSs8M5csnBZPUjFGdHFsNDSox1SkY4U1p4yTLSYHOQ0hjI3eNNEzrhr8OwW5VFE2eqC/a9IUpLqzj0f8GbigPD8xL8AMw8tkDU0dsOMyIrRcwY2Bw5p0lm44e+q36TLECW5b70LUBGSDFjKqOlw6N9HeraG0tm8dwrRmvGgiJF9LTwMZLhrDVYidalljVffrWNzOud90UMFMAwhTUiybIhEYY/2RU/SVDJH1LW1QyIwVMSKAaFv1AF9cmRdXc0G1m7pSGL97/j20/P93xTe6k+lt6LkiKrAGhL0wDXG1H4zwB2W2FHhSeEFU2wpJVM/++PTsPtvqwtG6J1bMjc+XQ4LmpURWpUTUCb6RQ45Z+OUC394iUAZ7K1ATCAACcRJWnQlp6zXU9Zi1KrP3s7Z1naFe/+3xvXmLtoJ63woeub3VyX/2KQKXfgCSiLLEPqkMjVCSJmhvUYkp+G8kx8BOdOaGFeHJv99Wd0p/b9Oap4210CQGS0YCkyb1LkyJr8ROqQgUiKknXgNkwFNSuxKLRldQsDS12MZBDKPDAcNvC6cNL2iJDmPfwVZ0mTe0NOYR0aPIoIilfBBWk8FmrkOpx0tKTZhIBYUpM5Ziw3JvDp/289zzPIQRA+Ne80fZF1BCYRFejoqTqW3KqyoJbuo8ifwjjBv/FxP818Y9ySWr/6hsEICy47+BuAxC2QhmA8J/U6SPs709q6yez3PZaSQ9GSRIeKwXW08KXe5F6InwovWSwY0oK6shTUbEr6DsqZaVufCtYbVuBJ3T1AMuTvO68/gb2Sh07+OXZPvg2V6zxBNs8i5cEsuLuaO5KCASD6YGblVaWXHKDCAsdFgCEZDPjsWtFPfnibvyuUWf7UNpiseP72dvr+B3DeZEJ0jILkYaVEx7tdl2oy8XcCOAAnWbdxccfRu/038AJb6HOW0SDVikcFfDSFcQLO2rZnXzVV2o71rGjFzQx3tTY/PWH399b+WhC/6wRlnlJkZ6Zl9VlxILdPySkkf4zSrIB0FBBGXoRao3oVxuWJ5HakMxLpGcpXmKXa8cq6dsWVSlzkKNxjRVbI+AfZlfUYPScv70qiTLBMMRPYq0IbGiU7B8Awnh57RYb8+SbV1LzDOoPZeyyeE+xUp8WuxQAoXnGasemVughRFMZAISwnEKGMIJ64RQgRNSqu4zS3lJ6G/o9SGUaSEZNs7asevnIGQCEoo4fPvn8pjevC8gYY8+Dsxld5UfLlDWi7GQUUKlUpw/TKSLlUWBmvcDqdRPCSoba5my+84XD+/8z4ejmO55N6F8w1laYGl2HgW/V/gYnMlkB6gxX6pECYLsn9M65r+bxtubv/7/L16ytdG0cGZo1pZczI2ZJst+jQoIoAuFkykJiZhLrJhFVCCt1+OykxSwdZcuf3D93fe32M7Sr4vPekH/PENOssSGFaZFLknUXjUj5CU1GMbZyndWpwgqyYUyOUgaVkWBNiZdCxAcNhOUDA+YkXFb0yZvf/BY/4TNaLz725tUBKZN6lSbF1MhWSUrdVJmEev8kfI1Qq22UNOMF/jymalr/+tTomhG2hTNGFLc5l9G9h1cWbry665SpfUpTomskktFdmvyuywhy1FexTA/CqzCpsdWpsVXjwvMGhmWc9z2EW1e/kHot9BDC2Y/GEQA/IfzGo9wR8NbCf2p4GTRJtlVDjEcKXN+sEv/U0vrVpcZV3xiYWV94/0Gjh7A1ygCE/7TYyUPap49qq0ewnPawRPaYGDGEiANppauhowxBPrKcUapF2WqFAtEWzvvwHGnVSKttRoShI5gXBIBItTKWbZzJPtzIG8+3bO7fVI3H+F0jIBGkJAAMYF3BmsvkAzdRBB6QOaG62oA/RI8Tpxnb29BmRgDC4iCe3Yk3XHu2j6SNldbMP9jAN89jVX/h2R15TmdA3XghQ6I7ilFRElAkY3GGu9UlDxCOWnwu9VDL/Ak3EoNuuphigk2A+aKuLK99c9VftB138wsbDeq17/uDj61/Ye7I0tEhCyaGF6XF1kyPW5IOQXDSCFH27AGhUa6i1aRQM1n+syxvYT6BrWgKVJCMk1LakFKQHX0pYL5fnqKWIwqWQJ5bi5hyf5dLUoTOUpaTIT4JVnGRLR8lA3G5KWMPASzFMk6AmYyYupTIiptNM+8o3tgKDCECwusDpqFJXbUOCKWPqEyYqJA0Jtl4kmQrSgLCRES8Y8MLbzbN2rzypVY3laFiDHbVlbl6oPm2Sb1LMAGvWnrb+NG1HM9k1Tcl88ej9OQMFHPGVKfFLEmLrR1uyZo9rPLVJz7QfrUV4ekTjfX594+0L5zc25McWQv+ohFVckwIF0USQCK+ompsSP7CUXWvPnpuZCP97YkPbh9WOdKyOC12SQpaNCVHqQg7md9QTlZMytAVZyaa9NLhJwIgrBNjPtw+33nb8jPHsz11/99SrykcGDh7Wly9QA7U9Zqo/GNISJkojXlbpID4VaPl6toBESZ47Say7PJ2SWu9j+3/8dAZ2u3fXhA70T11Su/ylJhapKD1yx/YNEth9Cp4IOkXynP8ooupyui3NCW6eoQta8bIkrZ2nUJ8xlcIQNh9anxfYAgTpV6U5KCkVaYGwir9qBOVuIPgEEgz4qoREE47vO/4r/9on4u1dc2LKdcVjARAWJEgMzklDoyHRl+0GI2WVsz4fYhzvgUgFLMFgunjqm4KzGwovP+AwRC2RhmA8F8VYMKPt/mWXgdpB0XITXkwV9BDC2WrZA7dihshelAulyVnCA2Ezpbh9fQQQEEMRbDLzivxPkXdARMWBLCVN/PXlrPv3uLNp872GLSNOn2U1w7ArrYenGSibjQRJUAIIITyIU3qLCAOpNtuq+YF/xK+uAOviD3bR9Jmqvk0JM6/VM/rruE5Xfii9rygO7izAq1nl4DQ3aI502FBkhCbM50UJ2jCax8ACDWn4mPdCjpSP60XCUZgxU3c2ZMJSF8UoNVfq+1YzU/+fLaHoA1V0+nmlx95qyi1YULUouHWRYmRZRkxtRnA3UGvF62KyDo/XkZUq2g1iDKTlALFUdD9fkBIXYWol8PL0ggIoculEsOd9GWx4qliKpUjvEoqlzfUPkTB8jq+TzlRLrrFvx4v8QtYCG+OSYnEEEaU32TKXFm0sRVMZfYeXp6/4fru03FpVa3oQYB8CALLWo5SAvFCkmChNAKxpKgRS7TxvYoGBs/auLyVcwhbVlNj89/f3jkudsEI+8LE6LK0uFo8p5Uybo781iMqdaowUXILSM/qwVxgHCIAYW1G3NKEiNKhpvne2+7+/P3vfuU+fPTaVzlT6kfZcrAzpxqc8WVPo+7LirwZ5j6L0bsleN6q4s27v21z+eb/Z/3809GarHsHB80VS0lw7gGFLfXjUT8t4m1YaJYnSxGm3j2IaATnv4Bn0wcsHROeM2u4663nPj5Du/rd53vL5qy+rls6sPQxS+DThLuXRJahaj4Qs5TwD2a5UiZQ2QIQQsLB+NCiKzomfPb2zrYmpGxZLz765rUBaVP7lCejqUwCpaqoWEWSl/uzyBUXik2G+PUVU02S0WHWhZkj25zLqPg6Aslot8lT+3qTI6tbWAFhOyt8BUkNRaLOE/ptVJEhjKlJi60aG5Y7MCzj8P7zHBBuWf1C8jUACIkpTaA8WzUNkB4U+LA8Xl7dU4FMqLCgNsKk6CrxRZocW3FTj+kNBkPYSmUAwn9TrPF483sPQSR6blee3wWkdF70GpV6UQo2sEp/UXTkh0QEt0mq6TzoKPML30WrbCz02iDQAroT7RCejsCSF/fkhd15cXdeamcPpvGPNrMDXxmwkJ88xN2hPL8DL4b8A4AikA+J6eekYySY7dLzJ2xiQ2UvNrkJ1C1OR04H7ugFCRYXeDUeZ3s/4e89wO5LAEpwUTue342jHSvMZEmr0iUPm063IhSU7J/M+ZCBH+pOl42SOZlLtXR6YKOLJmBVWtCVF3TRllyhvX0vb26jjS5nt/7+7rfif1viNbmDTXPGhxeDlUhcXVpMjZSWIeoDn8++5dJOBgGhvl5M0JcgCgomS1FWuTTfp6vvkVKwpFpcwKgQm6koFEteoad2uwR5wb5C78Uik0Ps2ZN8i9K2VYGjeoQS40kJYnVKFKDBtGgAhIl9S68PSlmW99CRn38r+oIcwtyHrg+Yjql9YOmOgLBaakQjEBZGlOkkA151JhNUsH2nLjKxqhDjPMh024ZlrR878Q/VkPvA6D7zxvcqTI2rBmKHmB+irfBMJSqPEL/ZRoTsnCHcDkRr9JK06Lpp/eonhBZNjMxdU7rtV3FZjN/l2Rbfr3BCmCOFTP8jqqnhU2ZORKiI8Cixb7UTwkpG2OY+cd+rbY2H+WfFNHbf0sdHhS+c0Ks4s/9SaDGK9FNMiSoILiGGvHmlZFSyc+T2gdrmGX9pSIz2jI/KKpt7578I6vwtJZDMwyufHGKZOTqkIDV2qeT/FZmZpNLq9NYpRE3llECYLK8XIGTCyYwxbuXDLPMzbijZv6ft0oOcGMKA1KnicKKqlbS7UjJm5PoDImrp/qp/ECiWE/uBq9L61UlAOKKkrQHCg3sOL8/bcGXXyVP6lCL9Xkk5qDJML1I3Ta1M1C+WoWRDtk1GVafHLkmPqxkHPYQCEB47vwHh5jtfSL4aJKNJqBeVvspRCg3qqYP6iCkJfRKhwRiAhSkxNSmxlTcFTl9W9MDPey9QJ4LWLQMQ/rp6ez2vv57ldYVFrcvEMVpQRRFa5JIXNzTYsMgUCr2TymVR/YSq7cpthTiEUrSWwRvcG8KpF7HUzitCuSeYF3aG1z6Ry795iR/7ifuazvYonKUS/5iP74f2tvz2vDiQO8xIBkIqveY0qQG36sH0ksJyWTWUNcIJ8oYAW5XbhReGQurjBZvw0XSCH9rFPn2MPTyNL/4zmMfkd4FBg1QV9ICRljBmOZ5um34hQ1OKUDmBndi0icNLqJt7WqJBEyUNwkfDa4VwzoIuLL+zr/ovzc9Vne1RaNMl1vdvPPNB6k0Fg3rNGmbNguvN0Wi7F1GVTE1QkSp/DBWeeoy4wD9T0ehFdaCVJ0fDjRT/sqNC9WNUJkvUV0FkYIqMQCSrA0rDq5RraEzGa9GmSAkTFf6mrMgK3DEFLUh2SNEFUTVgJwP0YHVaVE1GbN3k3o5reyasLHj4WCvEThxemv3A9T2mKVOZCgqml8ssWEmXwQbA1Z8KTbmI0roAF6MTwx0DTbeeUYaQoMXxw6fmjy0fbps3qXdJcrSK2/Z7SJZLF5woybXGR7ZYO0o5LgLCqNqM2Pr02NphloXzJ1R/8Lcv/y10EX86N75uhHlhfO/S1OhaCJaIqta5XIXhiSQEVeow08LbBpa//XxbzDf/Z/Xqo+/PHlo5xDRvelxdCmbckZ0s2XgA4dAX9ZYynBAuB8RTDGDfStiQqpreryHzsqWjwxemDFp0JkyGqF578oMZg9zXdp9B5q5EIundpHRpIFFSZ2SDVK4U4/QoMvY4h8WRTg53DrbNen7Te23WTobq+Ud2XNktZUrfClJOJtP1iEiZqZNI7b4yj56SV6r8IAoAcHU6Qn0wlRlR3NTGuFDxddSQ8/Bfu02OjywjQKj4rkrpXYRfPnL7JRWWhKxXetyS9H6148Lybg6ddt73EG5Z/ULKNfkjbVlJSi2sutAlLSxHRnxIIVdJXeXEZngBCMEmDVKaapNjKm/okdkgAOFPBiBshTIA4a8t9slGvmIQz+nE8zqTKJS57RBb76WECakdxTz6FkI7F2Vw68wV0ibKjBQNSO3MY9bcJvIgBZamPIxVR2hVfXhVOC/uxnMuFsBGe7qI7fsU4gq1tvU9+HsUpNJ/x3O78fx2WkkgyBpBGhrEnUGIDC0+p0zAI+GohIVOxOeQEWKCuEjxKnHiimyALdkFN4bM1wSy26+f5/cnsJwOPOsiXtCZO4KAAxQj4wwGXOexa247uCXJABUlhEYEqLl04SimqjgkPai3zlI/IaBBwIHYwOm1anCxI4QXdGXZf/YtuaLprbvP9kicG3Xq+OlnHnhzWOSsq7tlDDcvmNzLgaYXgKygPwoBoZSGRsulYWILSgSb7ytSoqHjIskvHyXju/IU/aHoKnI+SI7Uuw2hKTElWknXlMEp2ttQoIUyFFVu6dJZFLs+wLZUgA2w/q9JiQSXGnqVWNFODfNOtjvH2HLHRsx7fsNb4gB/4xChz/uD1/eYjkdRg5EYaJUZhVltEfpG7oW04ZqMlh3oCC+eMCGsZFDwbRsazjhDKGrLqhcSLs+9xTw/Hk5cDZyyvnqXJi73Ab3gwPapxPTqqmQZMUIpI5UCzqVH1aRHLZkW2yAOZJgtK2vKkmOH/k0Q+RtPfjrtBsdoW3ZKRGVK3+rUSEDpJBUmfz9cnUskL87jYPPsjSueP3hOXXT/ee+xteWPXN99ljiK9Njq1OiqFIl4cf2Npp14mNiYFKW75paDWLcvGRGJ2btkZv/lk/oUjO43+4WNb7f6TgrkLtD70YMnH2h4qt+lUyf2dqXFLMV52+IT2vKCi2rllXLuCLKYqsRrHyAyFD9HWfNGR88TAOkMUZqtVc8/uuPyrknxYKcJmBAYHhIm6JdpCBvEVCXKsHLUUZNPFUbXTOtfJ77WhlkXZI50tDXuev/uQ0uy7r+q+6SpkENYIxsICffS/iP4T5ZeVlUqgUZaOiUJuBu3JKN/7fjehYPCpx3YfZ7HTmy647mkv+YBIIyif1LSU1R6komRicFNGsxIupia4ZNjqpPFv8KYqrT+S5NiK8S/gGUlDxmAsFXKAIS/unxN7Lu3tIfSNVC+deMVdq0ihJXZxcapqxB9FBk575NhjGzEMgNuRIioyfY2AoSIFd0YSOgl2tCmuVXwvdfOxEpabMXdIb8+61LuMLEHEtmeD872QPzuJWDw508Dv1Tcw0etmwLjARSxKkoKUQre0FDciCAH+SsXQkTqYSvowp02tus1aJ+7wEr74mm26hYI3pjfDnopSwJ4SSBw0V7gUQEw40TlaIQrAzyQd9WIAAQm1qQmLU5RFyFtEyZ/KIG028Y8dgyrsIPEFElCXtTVt7h984rBvg82Gqkqv76aG3379/z8YN0TadfmD+yZOdqanRFdNfeyFbf1XzUtpj49ojYlojYtpi49thYtSWtRlok+NH3BFAS8PaMhzzAJIw2SI/yaNPE/Fe1qlNNM34rkPuKnzLvD5UtZMgVaRMjWpmTI764mqxgyZoR7xP3itRFVSX3FG1Zn9KuFvseYuoyY+mmx9Zn9lmX2q5sU5hwaOO/aTilXd0qeGLW4IXvjd5/vbWqNDLH9uw8vXfTQNV1nAEaKrksWAwK2jTWkBkyOgNTvZBlCgD/F7ajaRLydHFGTGlGbGlmXFLFkQphrcNCcpx/YcfzIGVfmnzrRWDJj1Y0Bt42zOwSoS+5bndynUpwvsTPJfWpT+op7apL6VCX1RkDYG44Ch7c6sU9NYt9q0Hn2wdQkjCIAACAASURBVF97VST2qowPr5oQ4prUt8SRtu5f/FExkbIn1U8IK54SWir+YpqYNpFLU6PqUyJrIY0wsjZJ/PVIMX/q0mPqM2KWTwx1Jvdzf/T6N+eWaE3s7dZ1L13bfWZiRNXMy1ekRtXC0EkNM0hk8TpFFU6JqsQ+FTjCFbD1FeNcCcPeFz47GbG1UyM8w0IWCKR9hnaVaey57W9e2T1tmDkrhUL5AKyCGS+A2Aj8bIqffQSmrU4RN/picIvY+lSlRtakRy8RW1psTXr/2ikR3jFhOYXJK87QrrZivfT4u9f3yJwcXpIaWZmKfcVwvOA4BaZTyt8YDh+UBaQviF6SEi2+32oTo2pTYmozB9SnRlcM6nl76pA2lye874efq2ffNzh4RkLfytToOjGXxDcqfNWgVkLMOvwWEt/JNcl41GmQMSserUmOrk2Fj2F1enTVtH414/rkXx829byPndh214upVxePsmSnRFak4rRPwUZKuEyAcUfYgFBJHYMpMWBSDcMopkpszbR+tekxYgCrZ/xledqA2usCMpcVPXx43xm/nHchlAEI/5NqPsV++kx72qE5gnhuZ1+pzVduYaUW6AAstWJvIW123PwkIdnPKFbQDPyJhyR2QLzAYlqX2zlp8W1B5hCTD8WrHALMdOfZ7XluV1bZz3dfItv1Om/+N1eFz586vl97sZIt7qAhkSWBn8vkk9n0ZgkCMZ4eITfSVjSkTnQf9Vig4bO4Gy8KYK+vYKcvjItJTOOHvxfHy+8cyMt68/wOAlSzkp7yMgQ4voCeGaAdWh9p0qYVrkegJY/Vhz+lxahUk9qABnRbpIOrhzI2wWhXQxU09taii48H/UWz22uL2vvuT9O+eI6dMtq+/7PSNO3wgaNfffTdppXPzBnmvSkgfVD3GZPCCqZFVM+KW5YZu3RabF1GbF0aWraI/6niP2uqhBAE4arwdiXEnSkbyUR53boankBX5YEhqSRACJdpyeddT7agtAmAf1WEAyEhDQEkYq1aAWzSoupm9l9+619WzOq/bHpcnVi0TQ4rHhYw/6ZuM4cG3Z55tXuNa9uOZz/+5rMfBYr77Zf2GRRckq9f/NCNAbMz+zfcNuDOmbErM2OWTYtpyIhdlhHTkNmvYXq/ZdP6LZveb3lm7PLMuBVwI2759Dhxp3ioYXpcw/RY8fxlCX3Lx4YuenTd3367ivXX7Pmn73zjzLhrtCU/PapmhtiZOHESl04TOxO3fBrs/7K0qPq0aAHM8GcsHE567PKM2OXT4lbMGLBS/Mzst2JabEO6eDR6RVpUw9Q+pbMGLfno9a//z64qAZN2fvJTxrVusRidIV4b2yAGYUbcqsyYVZlxK2/tf+esAXfO6Ae3xdtm9l81LXbF4B4LyjLu++HL/Wd6NFq9Xnns/fjLiodb8mdeLk708gyxxTZMixPDuDQjtl4MWkZcvZgAMAdiGmDDe/Ch5dNhEzNn6XTpXLJ43IDsIwdOnCFU/PUnP7hmrLmx68zMuPrMfvUwDeLk6YY9FD9jlmXGLMcp2oBXWBoyopeJTcyQGQPEtKnHFzaMCy2afFn2Oy/+/UzsZOvWi4++fVXntJHB2ekxdTP6r5g5QMw3/CTCh3EZzkwxDmoE+i+fPmDF9AErp/dfOaP/HdP7r8roV5/Zf2lyVPmgoDkpgwAQth1GVOzI7m/3FyesHBiYKWaUODo4qP4NM/ovFx+r6QNWZcDHdrmYZuJnpviS7A+PThMnN3bFtBjxeVwpjn1GXN2MfnXjw/NvCks+cuA4O6cux/yntWH5s0lXFI0LyRfndMaAhhmX1Qt0J+ZD5gBx9sWHFD4RGXF10wcsnda/fvqAevGlndF/WQaMqnhmfeZl4s4lt16xctrldTcGzVzh3HBkv2HL3wplAML/rJiviR34ir28RCvtzXLbM2cgLzXzUsnyyRgJyODWzRV1C35cZ8Oq2sykuBRX226ZaI9aU4u/L9Et+UagDUHLZ+MOMy/qwQu7MEcQq7+RP5TBP9zIjuw+/zviDn7L7xrNstuheY+du6DVDTEzwEJNwhUbdQ/ikNokMQuAEFE3ji0v6QE+pQ+k8uPnhnXef19NJ9k3r7Cnivjq4bwskue1w/bLLhB5gunwGrYL4oy1Iemq92GijFlnCEn57JaP+mlDcnCVp8CsyalrVmZLNjgFRT20rA7agku1x4vYd29DcIhR/1WJhf7BvYc/fP3zLWueLUlZNsJ228Dut44Izp4UXpIcUTYtplb875wOq8kl6TECm0GGIWE8QIOI9+j6KwrS0OgFMicEUCxXtCFJ6SinvjpJd8AHiQ61+lSkwEX96tTIGgE4xZYBDjH456JrBdqcFO6YEu4YY80dHrRgSODtQ01zEvoVOVPWbL3zhZe3v/PBq1/s3XXw9MlWa4FGQMj2/fhz2e1rL+uQOMZWMNHmHG8pnmAtEts4a8FYc+EEu1htFI2zlUwQm714gr1knL1oQohzot01IdQ1Kcw1WWyhnokhrhHm7EFBmRuWP/c7SEZFNZ5q2rLq+fi43ME9Zk8NdyVGeqeEu6f28iT2KU3o7RG3J4S4xoudtLnG2Z14wwn3hDjH2UvGhzrH2uBR/NU1we6dEOIZZckfYplz61jHj9/85Gv+R7B96mRj9YK7htrmiFGaHO6eEuaeGu6dHO6J71U6tVfZlDDPpFC32MTIjLOWjLU6RlnyBvx5wqN3/U0sSX+H0Wjd2rPzwGrP9is7po+0LhZnXJzrSSGuSaHOSXiuJ4d4J4fAPTAZrEVjxVSxFY8LcYy3OyaGiie4J4U443t7kiPKxbkYbsm5wZS5oeG5E0fPCG984tiplx55+y/tJ4y1FUzt7RbblF6uqb28U8QW5pkS6poYIvbfMcHmmGh3in2eHCbOnXcKHIVTzJap4TBhJoQ6BvaYM2OI48TRc0Dz8vyjO/q1n3Rdx2kTQ4qmwOGIUyNG3jnBjpsNP78hxePtxWKqi0ObIB4S4yBOH07+ieFFU/o6x9hzr+6Smjwo52wfzT/W7m/3ZY+vvbzDuLG2/IkwqYomhpVMFAcozmNIyXhb8aTQEvj+ETMtXGxuOSFDPeLkJvQqFZ/HpL5lyRGe4aZ5N4WknDhyqu3A3TNRm1Y9O3lA1sAesybYCyeGFE/u5ZgCH1L4tE4Oc0yGoSsWk0HMkEnhzkm9XBPD4Ut7UphTjOrk3sWTehWPDyuY1KdkfFj+FZ0SlzkfPPbzBUOQnMkyAOF/XkzjR3azN+7w1V0FjqBF3bg7mJVaZD8huGjYSFzH3CqQUHpvmNUKW/rNMJLnuWV+vYbNVyrdXno8akqJxzwhEFPh6slKAnheR1bQlTdcxzfO5C/Xsa9fAb+Q87X2fMwdVr64HZBOHhshEGL/JIQGGlB6YGoSHOoOKFYdYDNHT57bgZfF8CM/nu1DOlPFju1l7z3IHs/ja0aKseI5F/M8AQW7MUcgGX7SNQtN1zN7bJpHDpEe20g6W03JcaWvjAyaN2kuf28hbSDfBYdSeHOfeEOnmRV0Z4vbN+cHaU952P6vLlw/pNYrsT44dujEJzu+2rrm2Ts8mxaMqRnbN3tw0G1Det4+0pYzpY8zJaZ6er96pJvq0mPr0kG6uQTaDmNAmyS2lGjZKoatO2BnkqwaMzCWsFKm1VNsIDwfcg7gJ24CN2ZECUBYmdi7dGq4wA95Av7d0nP2wICZN/eYMdw6L6F/Qf7UZcsLHn5w2VNPPvj6Jzu+PX741JkzA/zph4Ols9dc1nnKQNOsIea5g4NmDwqcNShw5pDgWYOCZg3Gn4OCbh0M26yBPWeK20PNC4aaFgwzzx9unT8Mbw81z7ux58zreqSur3r80P7fSTiw87MfVxQ+OKbP3FEhCyb0yRkbljMhPGdc6KIxtoXDLXNvMd0+OPj2IUG3DwmeM6jnbHFcQ4JnD+552+Dg2cPsc4eFzB9mnz88ZMEw+4KhlgVDxPIx8Na/dk69Kjj+jtItP+/7RxL+2JET8VfMvzFo+hDL7GG2ueLAh1sXDLcvGCF+WhaMtM4fITbbvOHmuUOD5gwNmjvUfPvovjM/fv0rAVx/n9FoxWpq9L3x7EeDrbeKoRML6+GmBSPgGBeMsi4cZVs0wrJwmGne0OA5Q4JuG9gTpseQ4Ntwmy2OGoY96LaRtgXjwhaPC88ZaplzZdepmQMd+3afkXQc8XHe+fmPSVfnDDTNFKdVfHyGWebBT3EiTLcPM80ZaZ0rJoPYxDkaaZ0nboywzhthmTs0+HZxsoYFzxUHdUvw7DF95tcuuvdM7GGr1ytPvnNNUMo1HVNH2GDmj8ZtlH3hCDHtrfPFeblFHJpljjgXQy0wIMMtYjTEsMwVYzLEdPtw29yRIVm3WOZeF5g+c6yzucnXpiTNu3fuz0tYelW38UNts8UHaphljjhfI23zR9nmjzDPGW6eA4ccmjVKbSPtWeLAxcfwluC5Y+zZY+w5o0MWjwnNGhicOaTX+e8yuuWO58T30nXdEwYHZQ4JvnWY+Xac4eK7SJx6MXRzR1rm4fyfPxzmAHxdi8+vuD3cOneEHX4Os4gpMe/GHtOv7DL1jtJWcCkzihuA8L+vxhO+j7eyB9OZKwQxYU8U4AFVSOpQne7TJCAEVR42Zan1N8FCsnB0UcA92JNigxYtwW3MCYAQdHqACa2a14pGHeLOIK2oO8/vzPM7MXcIu3MEf6qIv3EX3/vx+dYg13yKf/4cn3sxz++iYUubMr2k4EELRdJjLgLmH8jwdMSEEmmbZT6hM5jntIf49X1fnFfePFozO/IjE7PxKS/bcBurHgDeoYsvZfkdeUk37gqUCNCrLlK4lQ0MpQgqglqhO7MKdaShRm4Qs1I0Fe/hT9T0SDslCOcsA+JRcwSxvM6wA0uv8r1cz08fAc97o1q1jh859c6Lnz64/OllJQ86Z67MuME5KmzeYNNssQgW/zVH23LGhRRNCndO7e1O6ONNiigDKxEB86hxJaY2PWbJtDjgEtNja9PjIOgcI7BqUmOrob8/oiyxT9nUPt74Pt4pvd2TejkmhpeMDyscZc0dYZo/VACVoNuGmW4bF74g7aqixZNqqhauXeF8eH3NI4/f++rHb3x96Kdjv48jvIA6L257a7nrwTUVW1aXb72zdPMq94Y7PBvXVmy5C7fVZZtXl21aU7ZptXfjHZ4Nd7jFQ4+I7e6K7WK7q3z7XWXi57Y7y8QLN77x1Mcnjv1O35xMY7s+371lzXP31DxyT9VjYru36tH15dvXlm5b7dm82rtJbZvF4YiNfl1TumVdzfb1tY/cXb19XfUjd1eJnd96p2fzStfGhsKHlpbc/8Cypw7t/0ce/vSpxnXVW9eUb1lbtfXuqm1rK7aJQ14rDr90K7xhxfZ1ldvXlm9dW7Z1Xdm2u8u2ra/c/si6Fw7tO3qOrkd/+uHg/XVP3uV99O6y7XeXixO9DY5RnHQxvOXbVnu3iBG+U4xn6WYxMe6CDQZ8TRncKebP6tIta+FV8ORlzvvv9G48fBCGlEjp1t3VY4dPvrj1ndXl4q9vuats65qyreKMi50RE/UO10ZxUu4q2yIewrOzZU2pnBWrXBvXlG4Wz18L2+aNK5/+ZMc3rbtjZ6h2fbVnbdW2O1yb11c/Qts91Y+KbZ3Yqh5ZW7ZNHNTdFVvX4iZOnNjEneJEiPvFebm78pF1VY/dXfmo+LBvv+8l8SXTpqboscMnntu04w7vQ2srt62r2r4etkfEdo/4qIrjKt96T5U42MfuqXlsffWjd8OHTnwSxSmGj/Dd8KX06Noy+GoSX1l3VW0+eezU+S0Z/fiNLx9a9ugq1/2rSzeIb2w67+sqt90tvqYqxXDBdxHMcDFK4pvKu2WNd9tdXrgNk6QSPqHwnIrtK10Pr3A9+PZLH5+LF7DaYBmA8DcV++EdbVsWq4hkhZ3BqMMVzD3BzB2s6TI8iqqXq3DEJzK/26ypVbUChIht5GLdTDEVMuHNbaXweljQl9q1UpvYfOBeY+KOQPBKyW0PYsiKSL51LntrLfv6JX74B3Ze0DLs553akyX81v9hJUEKEKroc6dJ+mG69DutnDAhEIY27M+UvjL4BBPP68SzLuZfPs8az/3rSQLTHtnNv3mFv30vf9LBGq7Tsi5lCy5iAgrmdQbFpsvsg6Y+DMP0qB5XSVDjBCO855bCZqacRblODCo2m7slwNYpbj1tBSlxs+Y1wZsXB3Hxp112tn4yf2fd+S9mPqslVgyNp5q//+KnJ+97bWnuvYXT6xYnVM4Z4027rmhi9OJRYQuG2+YPM88bZckabc0eY88ba88fF1owIaxoYljhpPCC8bb8CaGFE8KKx4cWjwspHBtWMDa8YIw9d7Qte7hp4XDrwpHWrFEhWaPDFo3rs3hqXP70a91zRnmzplQUZtSVzblztWvT43f/7ZPXvxUIsOn0Wbhaj4ffdOpEY9PpZjEOYjt9qkncbm7y4aaJn+JX2k6fbBIb3NPoa25s1h/Ce8SjjaeON/7OhyD2Xyxq5Z6fgN0Tx0I3Wm7iGOmneFpzo4+eL1+FLzl5/PSJI6cEmj2075g46v/9hxpP4rA0+uhg9deexveUt/E5MJInm87plajYeXEU4myK4/JPDHGANLCnaFQbYTzhUThq8ZA+mOI2/DwpRwaUe2d4NH45+OqcHjsNN06Kkyt2qZHmJ23iHpy3Gs3wthbH9y9K82lwmHIeig8gbo3ykwjzHE6Hj84a/aRTduqEHCI6ajo1Z/to/rEYEwsuH00e+S3U2KwOrVl91prw0Hwt56Q4OjEV8QlNNA7iTc720ZzxEl9Hp46fFht8rdE3dqPPp27gQKkPrNhwVOFTcKJRjVJzo/piFx+KtmY5e+6WAQh/a7FDP2jPuLSq/iy/Ky/qClShOwjkeV4wMvEvoD0yv1tfhcvcPLdJep9QaJ6MoFCkjfMXhAxI8ryABlkZrO/RzAZNHQWALArgxUAYakUB2qrB7PlK9vkzfO8n/NTP53IUO2NfveCrjOVz/qQ57dAfCCYoqAt1IfXnMJHKUSNiEMPTOY2z06oR8pEbqnPFKC26mD1Vwg59f7YP7b8qAbF8p/mhXfyHd/kXz7GXavgdt0CsfNbFLPtSlt+JFQdAJofX7vOIzerzWHw4qUB+TDGDHtm2KslVt5n5wZ4Fh5cCCaWLDKMOWOQYOQlNPRQ8qGY1oEGctAXdIemxPFp7dLG2+8Lzwj3bJf6PHv35xFcf/vDMQzvudG1yz1yVPbVm7ljv7BHu6YOKUq8rSL42P+Hq3CmXZ0/qv2Bc7Nwx0XPHR8+fEJM1KS576mWLp16ek3Blbso1BZmDnJlDXLeN8M4bW7546pKSjJXls9euKtr0xLrXPn/n+/0/HDl5TCzitHMU7J/fnTlGGWXUOV3GF9SvKmOQzkwZgLA1SqyP3ntIa7iRFQTwoo6ICclmw6a5bWolbQGPfujg0vGJVS3ECQSaIKJQpqvTkt3MFCxEeR5mAAAgDPWVhqCjowV8QUrFZmWlNl4hFuhBvKgLX9yOL7qEFfdga0bwd+9l+77gh7/nJw6CmvTc+rppPMbeXAuUV04nzR0izU6cij51g+hROWEiGnTqxidIcxGAcVspKw8sW10mCGQv7cN2vnEuDYWA9E0n2fED/OedfOfrTCCumgEQq5h1EcvCLkFHd7hYUBHSXBaqldrFNPPRDERMSBcmUHhspTu52yqFoG41x8iIlTAe+fGAGY8VN2V35KI2QmWV5CKxqFlzBrKcjjy3q686TttxJz91+GyPl1FYjDc3+QR+O/Dj4R++3P/tx7s/ffPb1x//8OkHdjx5345H73rt8btff3L9jucefueNJz5974UvPnjlqy/e/U48+ejBEyePAsfS9q3P/9P105nQ/hll1O9cF+YcNj68Rhl1RssAhK1WbP+X2hMF0D2VcxF3dQf6Dpz3cfEtAwkB4yEmtKjGNkKGGPLmCuYOE7JbIHfkMoLCgrEKKHrUmUaP3ecN8YFXJMBL0gQKTKhVWLVKG6+08zI7gNL89nzeH/ms/0+b/0efJ4xtX8i/e5OfW1LJ73aw9fH8tj/wkp6oDjVrDthkzCDwhDbmBuaQu1U6ggNHDJ14ONGqbvL1ka4/0Hi58GL+0RYBsc724f3qOn1U+/uTzRumad4wtuASNvtiOLOLO3BHT5AQCxBYFsK8hJMtPgiFh0PW3IiWqcGPHI/celsg9V6ScwwCPA/pmaldUMxDE+XOS88Y6hik6xQe3SpJvERM2m58wcVi8909jv3w7tkeKaOM+m/KWGgaZZRRRhl1IZcBCFuvtGZ2fD/78jnN20tbeCnP6cgdwRyNMSGnuyxMLNw5mv4zL/iF+qWh1EOopxE6KSNOyiOlP43LIqP2ZOMWQk1dxedCGxWvDZf+drB89EJ4ACsK4DkdgC3Macfzu3NXCKv5C3toGvvgYX5839ker39Xvib2xmqtyMTm/Zk5g2Vfpd5A6Ac2VtnPRlSqUzZkIkpsoRclggvSOyx88aW+dZOZgMdttpjGG4/zA19qb61l6ydAd2hBT57VkS1qB1ccHN00R0+KfScvImVaawWHTzdeQXAQPpQDgl47JmpkZZJfRUmty+pXL+P9EOzhUZ6iHqS4cUZhF6Kdey0ahqwI/MlcgZBtmH2xr7AHe2sdsJdG7rxRRhlllFFGGWXUuVYGIGzdYrzpBNu1o3nDLM0dwnM78cIAACGl4YDQIKIwhHlD6Lamk4cecCIFMKNwC9NTAQjpeWQmOCOjFIy10DykjbSRoyZXmkAkeSzQBubF9kKnCYnHnrw4kBd0Y7kdmdil0ghedwNfM4E97dE+f5od2yvQ7Nkeun8s9sUz2uqxLKs99MgRVkHPGIoW5DqGkfyVbotCAwVdhQS28ZlWKXGEIbLzom5aSTB7Y03bCscTp+DoHvb3J7UnirS1E/mym/iSvzJPH57flee0YwWdWHF3LnAgXAUww/nFw5HB8WgWqrkQvznNsitVNqBapAWrSpUA2tklUzG5U59mBAWtMD5wCSOErGg0nEhixsJDpThXvWbI3izqyhddouUH+O6eAKknJw9yZjR2G2WUUUYZZZRRRp17ZQDCM1La7g/ZW2v52tEAxsSCvqQnwjNaW4cATyjZP9y8GFHotMjYNwkLrSoN3CbtPajvy2WTgIcMP1wECah9zqZIHgSH+IdwcR8KKFTcEG9YEgQYNa8LX9we8KonnNXfwO6ayh+azZ/28I+3Q7ehrw0EV+z5iG28jRUH81wgWmVgulO5X4KVqFIw0kA5WwyUE6GOjNSTgBAdfWTwuoDHLK+d1nCd9v6GsxmRxxjIVvd9xt+7jz9ZxDfMYuumwunwhLHCrjz3UnCOzevCCrszR0/NGazMQm0a9Jqiothl0ZQvKHrt0JjIDkBGIluKkSAjGQzk0JySecbpZKYLDWhjC2a2yGkDN8i9QFPDr6V26FAtNbMKOwihHQHipLDsdqz2Ku2Zcm3nG0aLt1FGGWWUUUYZZdS5WwYgPFPFTh/lXz7DnyphKwZpAhMWBwBNR2JOr003dUQPjxYx32T07yI8Y5NeKa4WXv+SOQSSBxsR0e+ReDM3dSdaSadKBqe0uMfNjrAwBOMNzdwhkGF3XtAZWtGyLuXZnXhJCKu/iT90K3+0iD9bwf62kn37Kju6G61ofl9viR/fZdsXcW8fntOeFffgelCeTJy3ygw9p1LSStqQ3GX8zKE05nESXaaPMKLEkm4sr722eqT26WMQdfi7la+RnTjAvn+Lv3Mvf6aMbcvlD6TzuitBXVzQFVIxcjvzgu68JJA5AjQUyqKTp1UGyoNlKJnESKaUYgBVcyDpjVWiIAJC5pIxjP58DpgzNIZkKqMuN3isUt6MRkfUVchIvQx+tuKvB7PCLjz7Uq3Ezu5JYu8+yA7v/v2GziijjDLKKKOMMsqoM1AGIDzDdXyf9uFm7d5kVhHDcjsCVegM0lwmDVf5HHq0KETBQp1vBPmQxUJbFLeitmBpTsaPuLL3WFrGGCpAiNYgeh4AhS5QzyElGRImBH7Szj0hsIEDp4mVBLCCrtriTtCituASvvASntOFu0LZ+insKSd/bZVAL+zDzfyr59hPn7Dj+8CZRvO1vkungJ0CRX/9Mts4i7tD2OJ2WkF3ovigKc5lkuwfbdgjp7n8efQ6ROR+8KOjQRMEVOATNGnwE8wLO8FR3zmMvXs/3/d5K4NeMThaM/QBHt3D9nzIv3mRf7yFv/cAf+0O9mwZuz+VVcSy7I5s3sU8ux24wgooWBTAYHqYIcfPFcIJwwMlSE5CVoXwzaQ31ogdxTs1ZAI16B40a8oMRo6Mf5Io7IcXEWD0HNRhKE1EgVj2UjqFmktuG+0AiFRLeoqdZLld2PIh2pMO8I/RDI2oUUYZZZRRRhll1DlfBiD8PYod/kF7vlqrv0kr6gGNfEUC5wQR7eNDkKP5CUCzogHN0u4fGwXRIkVvAyO6jNgwv8EmASH02FT+peS24kXqTKbb26FJzI1EkICFLpuvPLS51N7stUHCIST7BQJzmN+Z53TiC//MFl7MF10CSMBlYw3XsC2z2avL2Psb2efPsp2v890fsp+/Zcf38+aT/z08YD4AToe+47t2sPceZKsGiyHiue21ou4QrY677QNAKI9LiiElMjSTGabm8jfOyZQOQj7qOVzeQGYVASFz9eQFnXj2paCb3b6If/kCwMJTh0FE+h9gXQH8fKz5FD99hB3dyw58DfDvux38q5f4Z0/y9x5mL9awjTP5qptBn1nYlWf9mS+4iC/4M89qx3M688Ie3BGIB4ViTjzRAPY8Nh28SdZX9ojacIaYNeoeBHbUDudUzQpqp9SkUtRMgJCwIrVQol4UWUcgVAlAIt6WFjU6G2lTPLMZrESLe/C8rrwsynd3PCR2nFtetUYZZZRRRhlllFFG/fMyAOHvVExrEwC6CQAAIABJREFUZoe/b1o3kbnDWW4nltdRQC+AfB4d4NFPxedIb0xq9LJS8hu2DhK1qJ6JskBUVIK0T/Na9Rw5rtLt8U9YZQAGvRus9QEQQmaDN0SALg1ea4HI+/IQXhnOy3sBX1TSkxUFsMJuwF9lX8Kz/sQX/oHP+x8+/yItt6vPFeJbdoNv6xztjTvY1y/yvZ+Az6TAdYd/4Ed286N7+YkD7NQR3nQCRKdaEzBmAjSKcfA1Qu+cgF7H9/EjP/J9X/C/P6k9lqvVxPK8jjznYvGTlQQKlCIwj0/sISBYqW/kxKNibgcgGYdZU+woymt1iGhFwxWZr4CjJB41ceVNqrmCKZ4BTDsXXcpz2mu53dh9iYBId3+AsY0HwHJG7LnAh0CHanADgR88JI5OHKY4WIEA937Kd77BPtjMXqplm27zrbxZ84aCuevCP8FYwXD9CUjX+X9mee3BGEYAUbH/ZaG8rDcv66WhBBT5wFBxLlipHXv2Qpg3FEw+PdQRSpGVGBmP/rQaYUinsslxoTAYZ4gPbWOIIJVWOnQ1AclAH4DAYIjicEsdMs09nFdgHwrJltRACDSyhRd1Z+JYCoP48sHs3QdhQIwyyiijjDLKKKOMOo/KAIS/d7HPn2q+4xbf4kt51kU8tz139pBdYegdyhyS4JKKRynnszPKEAc4RAySVeazgxISE+2x0Qu9aqw6WyjJIsxgAPinTGsQEIYwl02gLA0yMCDSEKMFUDEo0Aj8KsBJCC8PZxW9WFk4Lw3lXhsk1Dl68KIuPL8jNB8u/LMAh3zexXzRReD+UhQIoQ6lffiSy/nqYXzTTPZqA/94K9/5KlinHNoJQOvnnQJBsS+eZs+4tHumsMo4aJnL/jPP/hPPh4x1X3EwUqbIawGAsUoZpNPqc0h5Lcf+N3hCibhHNltq5MoD8YM25SiD0eqIEsl7U94PnFhP5gwUsBAIw5IgsG/JEaD3YrbgjwARl1zOxM6/eQfb9Ro/+DU/+iMgwP1fsi+eYa8u9W2+VbtzkK8sQuyqL68LW9SOzbuYzUGoPOd/+AKEf1mX8MUdWUGAVhTIigPh7FT28pWF+sp7sfIwVmaHzSsBHox2KSBzAX2BtpWtnuKk2zQJ2/AGXinQ0DYWDgdwPh2phZoquUcARUszkn56uyCOFVHHwXS8oFh2YXciJVV4ZIOiSjGxcZwAwNMu/CPP+gOr6Mue9/6unZZGGWWUUUYZZZRRRv1eZQDC372aTrIju7X3H9RWDwe94qJLeUEnVtJTt04hYlBqRN0UV2jWg+YogIERr0gGkgo9ahQf51WGNLJbTAJCVI3aVGghqg2hVw2DClw2n5s2ECsSQtCgydAq+8owPlHc0EpVKp3X5vPYfeDyYtKKAsAKJbcTaCCzO/BF7fii9oCvCroARCwO5iVm7hAv783L+nJPGHfYeJFJW9xVyxJP7sDzOgP2KOzOwUZF7K3J5zL7BBR0IuwBUtROgJCALuEiGUzvkKJHxHgkobRiP6EkDDXK5ECS0Fdioj5DDq8K8jkDfeDeaZJ6XcppELuxuCNsed14gdh5KyuxM2cYc/biJWGsyKzlBvBFncGDJ6s9X3Qxy72E53UABlUcRV5XXgB9gFqJCUMgTJDh7iVTH4hzaIYTh9avpRhHSYkOMOA2hILK+8dDnp909q1ctggqHo+SFdFgxkdQ32mDjkoKtHRaJAmMnZOaHEO5Sbsdj8zwICqVEXWM/qVwlsX4FHeHQ1v4B62sF3uhHMD8qcOt3zJqlFFGGWWUUUYZZVQbKAMQnp1iJw/xPR/yHWvYihu1PPT5LOwGLXzl4bwsXGAGTUaEC/QF4AEwA/6kJkPNbVEZhlY9oh3ZJAAh3N3ClVTxjVIt6Y8rbOFNqttvUrodwkWNHCY9CqN6kGPU39ZDjjgoYQXaMJiVBEGmRXEgLxLorjNsRV14YRdgDnMEPmzHF18K7ilAjYKTCsvpAC47AkcJPCle5QjirmDoFfRS8yRmLSIQ0rCPjoS1KpseTGII5ukuMnpEoaa6ColT5dJmU90GuGiSDj1OiuOTLwEezykOJBBMPosDeFF3cVLA/DO/M+xnbicmbhR1BfhahI/C1g1UoCU9wHPFGcyBfDPh2/rtW+QwusgXh04B5SKq6BHpImvW40b0rHlE8nJvURtM6YJE7kFnIF4jEIDQL47F0wqDw8mOCM6pWaqFPVZpMuSxSLSPLjUQNy8O3BEEFyYKu7LsS32eXtpLS9g3r/Cju9tgRqVRRhlllFFGGWWUUa1VBiA8e8U0fuIg/+o57dUG37KbWHEgK+jCiiB8HNb6AP/siFLAAAZUnd4QzYu+o0QuebDXy4OdddI50ypz2D1kSSqAhEniIo/uSGmVEQUCOThM0IPnD3Yn3xrCUTbFSZolDCNPGhnvLsWrehOaDMaQ6FQgn2AisoC3hL8iwAbgDUBNxUEMNySvQO+qMIxZ2sZ4TDptheQY4iuXMs+kXkp4Cb4cXoKUoLJjpYA+PafRTyq6CSKakFc0+X04XYisEK1xArfAlWGABxnzgDmnWQ0LPs1FfZuE35C/delONngUKsuBu/wAVUFTs8rGMKsd8zeRqhB51RSKVqISuss+UjOIiumGS2+JtGqELQlzSnEsKUVJlerPIKF0QQSEqDSGXTWx4h4srzNA9IKubEl//lKd9tE2dnSPAQWNMsooo4wyyiijzvsyAOHZLsb46WPaJ4/w58v56hEAV/I6sOJugKBI4ekhBKh3lCE4xFU+ek4S/LNynbtzmHVhIQBCacSCvWFum2pNJJ8VgmEtUhD9v1pVKKKCFoT3JB4zSeJLwTZUqJr9/KG8BxMRgEUE9xopiQSFqh0YSBA9kq+mjfnzA1X/JFGghJSIJ9TxnuoDBGik59RLEazMr9d7Bf20IR2UH3xa9EGAIAfCeLCRztNGolyp3sRdJeWnjLxXMe4yu68FT8sl9iNxr4KILtIAW/1j67Koo1Ov9ShbUbLAkYmUFq7McpRDjCRFCRVzl04wSjBPLZdkPyszJ3QyEC4uoO0QbCawDy0RULArz+7A8gO0+uvY4wXs3XuYIRA1yiijjDLKKKOMumDKAIRtpppP88+f4I/n8bvH8Zp+PL87BpQHac4g2YdGkk5o7YN2Pk4mMXpUPeIBn1JRSszgpvgBE4El7C6zyLZDJ0kKwYxEaizphU7/xiUgxG491KnqXKI/FAGAolnPuvBH3jlwI85K7QyRYLgPVk1mQujJGXqShB4fb1FoUzFs/idYFRzyxzBqmNzIEBBqsskQGUjKaZAgDdMakPoj3xqFyojnVPpSRdZpMvhR2rT4kz/k7tloD/X91JSxp8JvyL8hLKcXoubT4neCoTv1jJAWJKHfQtb1i4ANRVoqDC+VpX5zWjUB5GUCH0BcOEfy2oGHJL49oVGwAAW9hUGs/iZt4+3aew9Dr6BRRhlllFFGGWWUURdSGYCwjZWvke/9hL28RFs1nJfFsfzukFFR3EPDOHtWamdlobzUziVtaJWxAa5/gAQk7JTxDMyte5ZKTEhYhWMHnc44KbElShB1+OHSk/1QweimTHNri/B3gp3BTMpKVVMc5J4rOahspbMo+gtlk37nT4RSfu4O4JxPJ9zk/uPmkHJNfJpJSiiRslOB7CQZtfqc0niGJJ2aDozlO2PmnqsFQJViVNw3xIGEx8DmlOSpdAj+2EM/olOdiqpL03+njpzNIM5EpxzmVjkZBPbgp01hWoLuZkktOuVGj2r+U0ydh+Q4qlhBPXrErTCkYnQBi4JSFNs+sdsTwg9zOvKsdiyvB196rfZwpvb50+z00bM99Y0yyiijjDLKKKOMOgtlAMK2WYydOqT9/QntzhHcHQFsYU47XtAZlvtlvTgkFtgAHEJYBRmE4IbwALggZUAisRCAEOq4IyRjVfJIi08JRBHP2JhUbxL/Jl4lfrVDlDm5dyIhiTEPOvixMj+8sXAFSsnrUiMS0qk63Mjg1GHWHJLTk7jUpRAdRkToEfMKMVqI9dIISVLPIeZPaBSt7m6xP050WEElLbrd4N/VeUWHWcYttOi1UwpVk1SNkqWnztG5laxUR4PIzvk8ZGEqkSTkGbqBjdRQxao54FyIN/HhCGsKiuNDfiNQ9aetPo/FpwcqOtTpQDkojJ7TpPcftvTRkXhbPxEYvKEhYcv1KwUCBJbiJCmzgUa0OEBAQbaoI88P1soGaA/NYPu+gHxFo4wyyiijjDLKKKMu1DIAYVsvduRH3/b5zBsK5pwLL+KLO7CSQGgprAhnZSGaW/FFysjEn8YufUdItElqUoqhs5KjDMosicHzZxLozXW+lrgIlJM2QpUatSOilaVGPWxuHRBaFcFo8ak4eKIT8T0BWDaTNtUp2wKVmpQCFRA+uXU2TFKLGECPm2TYzKo5kICuGQIqXGY/7kIspCEoolxHpSwlRs7qc5kksCSxpXgHN/rN0AspqkEyltL3BXP8cEzoD7nB5rQFIDQr+o4ISYJ/JsWXgk2Oz2FR8lfZ4KcLepuVvw53KqcZDzqgOimAXvr6EBmo4iUtLU+QHGfVdkj71lxq95WF8fIQXm7lhR35ooshNzK/O7tzOPtgE288frantlFGGWWUUUYZZZRRZ78MQNjmS/Pxkwf5ga/Z+xvYuoks71Ke9Qe+4GKe1wXkf9LphHSGdpkVofIMpd7STd165l+IJN0CRyGmIhjptvgk1JFZFEopamnJQUl0JF9CnY3oHyMtaoAB82H6n8KBVu2XjikSwUrbT8sv9KLKGUWXcaomQwuFEDI9cUEiTBOqXm2UGyEQIz5Zd1UFtSTHbkbulHpR1RVp0vx/BZMzANmSHhWwmQ+w3y/sTykRHpGq1YeHCbpWt25XQ/l+VhX6R7gUFbZuM+JPCwBCF/0hAm9WIm99qLP1yYG1cZdyLnWYcZeUZY7E+eS8atX+sXWQ0kSQE6Z4Q/DFsfCSQJ51CZ/9Bzbr/29299aecvBdO9jRvbzxBJjcGmWUUUYZZZRRRhl1wZcBCM+REsv3k4f53k/5Z4+x58tYeV+e245lX8JzO7CCzhBWgYpQLkMIkUpyU+IcBNZrHgE5ZFS9rhdFFxbqN7NqylAUg90x7YDi7FRShXStdJKUUTcUJXWiTUJHhwwAJGDJpQemWYdM6NFi83kAU4Hs85c2KqSlVK4zLSSaqDvV0SnXAaEDAKHPafXpLKJLD3sgbSdCTQeFW5gUBWqSVKfUypI+06wIOgSELmAd5V8kz08FjBEQKgSr+/S0OEZFKkpCj8Aqd1v8KlmnCk7Ec6GpSAwac673FurcrDpfMpGC/gTKQTWZSClDQVRraE/uCITsxAWX8Nsv5tndtPtT2Lsb2Ldv8MM/gHeRUUYZZZRRRhlllFFGqTIA4TlVjIHrzOHv+aeP8LfXaY/law038IIekGuf3R7yAwQSAJRl4jJ53MJLrdwLyeOI+tBjExMUxI1mwGYW2aon4wQFTpOqS5WqZ/FzUBCArkAa9tdJHtIjA/e4Hw4pV0/SbeqqUeK1pOzTrCCZTNVDaGSVYJLcUCHqXdJ0mlORh9jQiO9g8jlMPqeuLzXr/p9Mhg3qJqvkQGORDB75rCpgqfLclWONS2+5RJcaAdIcMr5CWemYJTHotKqQCYnZ/LJb+ZAKiKfmQP876MMlx5PEoiokA91QHdInRvaIulWUPPrTQFSG2EqtrMzKStG0xhHEC7vxvM58cQctr7PPE66tHsefKuPvPMR+fI83nRCz52xPX6OMMsooo4wyyiij2lwZgPCcLaaxQ7vYx9vYM2X8wZl8ydU8pxvP6QSwsLA79Bk6ggSgYtRN57WR/wqk/+Hmc9ua3Xafx+Y3VlGiRDIUlZahLpUDIXWbqvdPxjCoxHO3ikNwSq0mebpIvs6pehrdFhWnblZxFAoQ6hGIZIxJT1DZGIwsOmW/ou6Gaqa0iRaA0H8Uqh9Pok3JGSrwhphQYTmn37bUL8J06eSkwFotEhr19D9Py7Y9hQmVHasaHxVA77BKnvOXo82kohXIVYSdKk3RFQLONF6EghglLwGhl0hgEySRlMLGveJAevAiceo7sOxLWVFPfudo9mie9toq9tWL/MSBsz1NjTLKKKOMMsooo4xq02UAwnO/mk+zA1+zd+7nm+bx9Sms9hrmsLHcbiynC8/rxgoCtJIgAQV9XrvYNK/VhwpSkG5iH6BSYFpUbLq0A9UI7+nYD80zpdJSgBaJXmx+Uk65yDAZPqGzjpIBU9l6JuWAalLB64p2c5Kc0tQSlcE9FLYuYw+tmgqxkHkbDouvRdthi1wNq/K58QM8nQOUxKMUZ6J0UyUBaorJVBEOZrJv1ZS9J1fDJd9cZxr9kYm6U47s4SQQiz6u/2DAQ7DTxnQ3VD/BaAV212MCNOiRGfcSHDoCkeM1seIevKALy+8M71B/A7s3VXskm3/5HD/x89melEYZdcEVYwYJb5RRRhll1DlZBiA8j0osR04d0d5/2LdpjrZiJCu/gpWEagIZLurACrsDcAKGUPwENxRNIAoBCz2Kp1IQS6PIOyeRb7+wHvU5EBeBatQqJZE6XJShFFau2hcxyCGY5JrUnuePeXCTGNXUwkLGrHAjAEIyTZW4ER/CVAYz2W9KAEaolYxqZOaERSVkWDDHQobytfRQhXwIl2qkJH8dQqFuE3X6yR3zc5h+qCnBrQKTuoEq5Tf6oynQ1pVLu1Q0HSVLHqD+bHraBO2GRupcp13X2SqTWPEOwQj/MEaCTFDFPTCSPXl+e17UA6TCjhBedQVbNVLbMl/77EnDKsYoo4wyyiijjDLKqP+0DEB4fhZrOqHtfN33WFFT/aAmd19fXk++sANf1IHndtGKewigAraikCERghJHGWRPAkhK2ONOxX05zUxPOJANh1YCSJLX0lWjigBUfXrBSK+ZuASEKlkBcZc/p0EBMJmQIUlI3fYT/DalpJNyAslT1KksZEif6SAWUWE8IhLdLWSi4EAj4wF1rk/XkVJABUejGplU4cRgCYdkKTWn3wFVxmkAQ0hNhlbq9KNDwH0O5gpMShpQSWdV66C0IcWYDascfJfS3MIIB3OxOUz0V7gzmBcH8vwuPEecwQ7cGcQcYVr1VeyJYvb929BWapRR52AxURprbvI1nm4+daLx9InGU8cbxY2TxxtPHjstfm063exr1s5d5k3sudh/sYljpE3c1uCAztUjMsooo4wy6rwsAxCe76X5+Imf2fsP87VjARGB8+Qf+fyL+KJ2PKczEE3iztIQCCoA18oWqk5nsIaaUkykQFkmmYjqnXWqY1AqOd12TekhIbLPEawhBgMvUOWfyXQqTw/uc8s8CcCoAFMFqDP5SUt6Q4+e5WCWQfOOFp14iE6B9pTBhmZsgDRrepoFWbZgkx4m2puVUtTMdYZQjxwUx46p95A84aSdhBQN6YuDyFCCNwTAGrYFEr2p6S6jmNOoyECTjKAQ8LIED80BgltEsEBLwpuD2Q/iW9hsmieEldq5pycv7iEAPF90CZ/3Bz7nf/i8i7SCQO2uUfz9B/jxfXBmjTLqnC2BiwQOPLz/2K7P9n74yld/e/SjFze99+xDb7+45b2nH3jrifVvvLjp3Y9f/2bProPHD5/SfOce9e1r0o4dPvXT9z//+PX+7z7/6dtP9ojth6/2H9p3rPFU07l4REaduWLsQr9McIEfvlFGnfUyAOEFUEyDFPJjP/GD3/KvX2LPeLWVg1lRIM9qx+f9ESCigBx5HTC7wiy9MSXSg6RBEJe6raiotOruKczt78eTnXsEq4g5RL2oDKjQyT2HWWYqkB5Svg+10pn81KIbZZYCjlJHop4/4TZhmx9pLKX5je+XLYgE6qSCVPmmcgJ1TuVeQ3yjo0WWg4SXVgXzME3RQYJYRLNuq1KEKmMbclgl8ElvqzhSyo6n1kfuUeGKgDAJr8qUCAiQ9GKGJAJCn9MOe+gIBoie35XntOPzITRCm3+pT+zMmpHsteVs1w5oFhXnUZxNZqDBtlu0smEa828M8M8vn8S1Zq25sZXPI3FQQEP5kJhqVKyUjxFP1XS6udX/6H+we42+3d/s37D02UXja+OvzB8Xt2BU1JzhfW4fGnrrYPusIfZZt9hnDw2ZNyJ84cheC4b3mjO09+zhfW8bHnHr+P7zEq/Ld05f/dj613d+tvfU8TbHiosRPnLwxIevfrU8f9PcUVUp15VMuSJ34oDsCf0XjYmZNzZy/ujo+WOiF4yLy5owYNGEAVnjL1uQcE32jFscJWnLt699edfnextPNbfazmg4B5rhpDc1NouTLjbx/k2nmhtPNokbYjt9sukUMrG0nTh6Smxw5wmxNR4/ckps4gn45CbxQqb9P/beO7ypK2v7/ut7v+eZmoTuJnery5AyCQFCYpqb3Ju65IIBg7vcu2z14gKkhxTSA6RnJr23SQVSgBQgAUJCL8bYOudda+8jk3dmnsQG4/DMnHXtS9exkY9OFft31lr3PUnz9ZHhkVFaprcPHFu6QC9s/A3s3BBmj8e+WrgJh8/6h+BQDOHA+4Kmbcl6uCzu0MhZMuCXeO/g7eMfTe0C4dOjceb00BlyGM+eGaHHFhaGyJ1F7y9YA91U8rf4ofQj6JtHyNrgPeSbgezXCOzQhD0ggBXCCT3648mTR06fOHz6+KFTJw6fOnUMzu+ZU3iicZwZPEvS8mfHdQwnKujBod9RdDD/lDbH8zU8MmlXHR988MED4X9SwBfu8CB7bB+7fyuz6xXm40eZFx2s50q2cSpb/Ts0u4dBvA3Z5qls20ymPYgrYqS+C93hTMAhnVNV4XzzCKFxfg8BsZYuUilqGTXlI511lkD1KddcFxIwtwi07aFnIOf6wNV2Uoa0COgfsrTYslPACbR0cPaGPwPCgOchdVDkBE5/Rnc/Sz+Oap8G+gMDGDwqi0r7/Tg9G8qZ4QHHv3PSNYG60DBawko3GNOt3VRih7JrhL87wm+NAg6k/pCMJZhBz8Agpm0GasMCn5f//+ya/48p/y9/U9DI+hTm9XXM9meZb95iDmzHlCCWhvL/O17SAVOcb7ft6V45UJlpqcrors6ymXMc5mx7TbajIr3HnOsw59iqM7sr07pwZFi7V60/fujkP7LieQXMn44fPmWtvKUi21aT66vO9qxWdpeldq1K7ShL7ViV3F6m7ITlFcltyxNbylLbbGtuGTw9SaaUMAF965mtzjV3lyV36+e3ZInrlJHVyYLqtMiGnNj2vLjOPGFngbi7QGRRi6xqkQ2GRmzTSew6mV0t7S4QW3JiW9Oj6lKjq7PjzYYbmsvTbe6a+z56dQcQy2+bV4Az/s1n+x7se86c51mxzGKc11Yga1KGm5WCuoyIhoyIxvTwxnR4FTRkRjZlR7dkRbVkx7TlxLZlx7Zmxjbnidtypa2aa9tNN8LZ6Wk29N/vfWbvjoMjF5A/BAj526Y3V2ZYyjIcq9JdxUmWkqTO4qVdxUstxUu6SpZ2lyT1lCT2FC3pKlzaUby0o2gxjsJFbYUJLYWLWkyLWk2L24qXdJaQ9xcvbi9a3Gpa1FKU1FGa3FWW6ehcfstG9zPvv/D5T/uOTSDG0AA2uNO5eUVaR1Fi8/KUjpXpPWXKnqpMR2WGA076GmXPqlTLipTO5Ynty5Na6rSu77858KuZJcC/j9/+oiy7qyi5fUWaZXlS5/KkrhUplpU4ulelWFem2lYm20qTLStSLavgroFPSbGWwe+VtlVK20pYwPdYVig7V6R2wqevSulamdS1MrWbbAyuZHW6bXWmfVWafXWafZWyZ2Va98q0njIYSvgna1madU2aFc7viqSu0sSuFck9K1LxPRVpllWpbcXL6suzul7a8g5s54VmyRgWSO+xDc8VJtcbFjcaFjUbEhr1NzXqbqozLW6HU798WXdpYjfseGlKT0lKF+zvXx96+8SR0xf0oeOPvta7V6a1w5GEY7gipXs5OfIrlJbqHFdtnqcy016eYSvPtJVnWK1r7hj+LZCVDz7+A4MHwv/UIGlD5uhe5otn2Q/uZ95Yzz7Txt6jYlzxTN2fsKa05r9Z8x/Yuj+z9Zcz9VOYxqlM60ymLQizWLQPED3xwtlRnVJOPHO0LjQ00FPHcSABwhDOTILTdAmhrYZUeSXAgcQDMOAKyBkDkuJMP3Vl+Dn1ddC0m8APoyPgh0HkW7D2krjVjzpYUIOHnxWvnpON4ZobKQd2BvKKneeWA8qodGNGVWQEXPXpqKmGJeBMyKVJaSIxhHYkMs1TYLBNl7H1fyTH9g/4WvnfiIINU9ieOPauHPbZTvbN25iPHmG+ehOTgSNnf+sLhY9xxMjZka2vfJEXX710ZlGGYHV2ZHVudG1BbF1eXENmlDkr0pwbZc6OMmdG1qSHVyWHlOn+UnvspxMT8hQcZpInDp8qTuhYJijPiG3KimlKE9Skh9UqQ2tgQRlanRpalRJSmRxStWhG6V/+mKGULD9x9OSFf+4vx8mjpx+//WXryttXLrbmioCOzMrwptzoLq3ErpE6dVKXSeYpkvuK4r1Fc3oLFb5iRW/x7N7C+N6i+N4SRV+xoq9IAf/qM0rdBqlTLeoBmkqLakiLNufKGstTHZblt97teOqrbd8BBV3sffnn+Oz9bzbYH29WDyyf15Md2ZAhaMyNbFMJLXkxneo4q1Zk1wLZErjVCq06sV0rtmnIglHmNko9egm8unVip1rcA2AMeJwRazZc11KV7Wwt7l3X9tBXW787e2bcaUP4k3t7n14YVKKMbUiJbEgNb1KGNaaENuAIaUgNqU8Nq08OrV8aVLt4Zs2yoJpls2qWzsKFpbOqlwZVL5tVvSyoWhnWkC5oSgtrVIbWp4U1wEJ6ZFNGVFNSWF2WuL5wXmdVmqfVsN5Zcc+d1se//+rgRKWd4Ty2mW6+cVbJ4pCVqdG1KZH1qYLGzEj49Ib0yEZlBOxOXYqgJilao++pAAAgAElEQVSsZtGssisvT/n8o52/ylBDg8OvP/PhDcH6+TMLFwvWLAupSQwxJ4fCqEsJq08JrU8JM6cKGuDHxDBzUpg5GUZobQq+1iUL4J/gE+vhl0mh1clhNfBPQPup8HuC/fA2+FeloD49vCFN0ACvyvB6ZUQdjLQIWK6DDVaG1eE7Q80pobXJITVJobD95pSIWmVERXZ01ZKg4oQZ+g32LScOn77wwtFP395Zo3bNnapZHLQ6YebqhBllS4MrFgWtXhpcrYTNi2jMiG5Kj25IgsMYXnvTrFJLyR3b3/36Qj5xvOEf8Rcvbb5xZtGykHI8PnAwI+Bo4PakRTZmRDXDlQYLKYLaRbNWqf7SgJcW/yCUDz4ufvBAyAeBw+HT7NHv2N1vMx/cxzxvZZ9uYzfXsLelMHYJ0xbKNE1nGi7DzGHT5SwgTet0tn0GS1zjOW96zHrBiCCUGCjXRLMEhEB0zwv4qtPiTH9PBGOJYAKZNxQ77QbeC2YC2UL2Z4NKv/gD1vBMoI40UMNJEVHgpw1+AT1PfLWEcRWntPWxg1oCUgWdgNpNV8ARvmvU8zDgVGERnMv4nctkks3r5upFSelsMLJuN7EN7AmYB3YFsZ0z8Sh1zGDbpqFlfPPlbO3vWfMfmbrLmNYQ1n01uyGX3VzFPtmGEPiig333Dvab19nj+3kI/N8b/mH/V3/fnSGrTA2r1Io6dOJuvbjHILEapHadBGCgRye0asVWvcymFnWlhFbkza44fujURAHhqaODhQtasiKbdFKnXuoE9tDEWVU4bAAnGiEdjqyotoTpxUuiTBcPCGGPjh8+9dx9b65teahoXpdSUJ0SXJsT1a4TOwxSb6G8t2h2vym+3yTvNUk9JonbJHObFB6T3AOAZJTjwGWJWy924pC6YLlQ4QViNCq8OrlLLbHnxnSkRcBUvjpH1tBWdPN93qc+fv3LM6cn496BGe2h/ceeue9ta+nd2itbU8MA+1t1SHouo9RrlHvg4BskbjKceonTIHMbcMdh2QE0CAsUCA2w7zBk3iI5wrBO4siP7cgINy+esXLhdFOasGJt28N7vjow3s0bGfbf2/vEjTNLdDKXSuTQS30GiU8r9mhFbq3IBRupETlUQrtKaMuPsalgxMGyQw0jzlEAy7E4tCI48m6dyKUXuwwSOC9ek8wHu1YgtOXGdeXEtcPEHafygtp8Wauz/J77e/8KXDF44kJLeeHYNmr7lwWV58R2aKSOApFDI3LBxqglTq3UrZW4NSKnRuzQyFy5sd1XX571+cdf/SpAASG/98K2bClmpPPE3QVCewHZ0wKy46o4pzrOroZjInLmwzGJs+EbRFYVDCG82lQi+NGWT5bVIvgTOxxANR14GO1wTOBgquPgSFrVcT0qGMJuNf65rSAOX1Wx9DbEUSDsKYjrycffW+FLwCC15ce2JgevvqNry+EDx1n2n2rLxxn39D6Re5UZOBZ2LT+mJy/Ggida2A0fqhU7dBInXBVwYFWwLHUCdOXG122+88UL+cTxBlyfhoUNiSEV+XEWPJXw1SSxqaR2tdiWB8cnzp4Pp0boyI62LJ65RilbyQMhH3xMTvBAyMe/CkDE04fZnS8wb/Qxz7YwWyrZh4uZu3PYtfP91ljUicFM1+XY7dYyDfkQ4KeDmiIEIwF2U8e8cAJI4WihDoxkDYeBAiqW8BFrtL8nErDQjz8KRtAAQ4BpOgsRI7WEnqvG7OTsKJAGOZYjFhdcuyMpy6REh2qf4ZxVIC0WtYzCXkBapitgZA+AGgBCzjajmzOQwMpY9GkMxU3qDj0nvko5kLrD92ACkMqlohxoVxAWf+KYyRFgK5Dzn9kmGJcxbTP8lhimfy5zRzZ7fxHzaAXzXAfz/gZmzzvY2Ml30v8bBYDQwa8PZcyuSIusM8pdBpkLZvk6QgWjQyd1mBRujbgnMXR1ZvxqTAtMUMnoqWODmrnVeVGtRbI+owwAw6WTurRSnEnrgUlkXoMchk8tdiojGhPjSk4cPXXhn/vPMXhyaOene+7vfUZ3deuSkDXp4U35sRYtkInEZZACI3mBlPRSj07qNcg8BkJ9OhgSxCQ9bjOBKCBDKdALEJSTTGRx/qoVIwzATumRprx6uVcjcaRFNC+atTolqrxB1ffcA2/s3TlughpXnDox+MlbOzbYniie78iNbc2NbiuI69aI7QB7AK46qYvSOCwbYH/FQIZIswbcI4dB4jDCLyX4Bi3ZNZ0Id0eH0AXo5YT36wAthN35wg5lZK3hhvaP3vxyvFsIV8I9/ZsWTDeYJH16MZ50OFB6OFx40Nw6HB64Kgx4GGELXZiolHuNMgRUQoxupEE4/hKPQQxnBzePnDsvvJOcIFwJspnYCfueG92ZGlaTJWqwFN+5+faXtv991wW2pdVpPEnBVapYm07i0Yg9ADCw5bALOpmH7AjwttcY36eTuRNCV+zYumcsJaMfvfZl4dyOgtgegxyuK68W1+zGIXEDKuskvVrYayl+FrlfXFoZvNq1MrsWQFTigssMIAo+EW8ovHrdlE7hn8gbHFop3uYqxFc7UKJGYsdf4uXqwjfj22DN9PJw6ySUzN1wrrV4bJ3pEfV3dT95+IfjF3LcWNKj2766f0l4GWyJUdavl3jwU2DXJHh/4fWJ3z8u2E3YDJOiNz+u68YZJf2t958+OUnV4yzpti1MaFZG1OvwWQmcC7I9cORlbjVmy10FQNoSd77QviSofEmcfnjof7HOMB98/C8KHgj5GEPAjPXMCebQ18ynm0aebhp5sJC9M5MdWMR65zHOKxlLLIOmCFNRtrTxCrb5CrZtKtsZRFRVaMloCOJTdzA2zqFKTcRId9QI4FYPLlMhU1JsyRk5MOfqTkc1QikQCmgqj/oKssRX0E/EZthAsShX4clJ4IQw53RcRjONWICKyUwUwgnlqjopSRLqw+ZD7P1Dz0MkW3wNo5lA/NEage/vDGaoAEzLDLZ5OksLQZuuwIPQMpO1RLOu2Wz/PHZdAntrEnNvwfDjdcyHG/0/fsmeOcZbBf4bB9woP+4+knVlZUZUvUHh0ssRD3BGC7SAwOBAVJA5TQqYBtmSBJVZc8pRQnOigPD4YP7cqtyYlmJ5L0zfNRKcY+EsVu7WK9x6uZvOulQipzK8MTH2ogDh0UMn3n1+m23VXTDRTAypUUl6YM6nR/bzAo0ATiCWAHuQX+LcVOLiwBXnrG4yvcbJK6Ijvh8X6BvgFWfYEqdahFNtgBMAG6OitzC+zyD3ZEQ13zSjNFNaua714R2f7B4evigVpHCE33thW0N+/6KZK/JjO5FyxbCdgCiwkQ6y5eREk8k3nGtgWhiAXgZMCToIEyIiAmLBPJiWjMLG6/EKQQw2Sb3F8n6T3Fd65UBWeGvpQscnb+4c70YiEA5snj/dUCjtRSQgGSENOc54eEepFXkVBsAqFq8C+MG+6EUurdCpF+N+USBEakUmdBK08MDvOSyXkDXISC4X83WdiSEVieErm3R9H7+140JUf+rUnqSQarUQDqNHi8wGG0+pzKkOLOtlHpXItjCoFIDwV1cIQPjhq18Yrm4tiLbA2TEQTCL5UmRCQrY+suBCrpPBDesmQOjQyPBKA3Qn1b8OevnhBoiBWGC4gPc04gDbS90avIwdlC1hCwmEe41Snx6PsE8ngwvejfcCLOOR9AD0qnENLmW4+U7rE0cOnjjvg0bj28+/X5XdtTSswiTrhQ+Cc61H4nWp8YGLm3y6G69M/FqAc+cpUvSlhZvbjTd/9v43F/jRYw/4kixa3ApACAfcKO8lHA6HCxlbB98JgIjw/SDvhV+mhJsTxcUAkJO2bXzw8Z8cPBDycb5x9jRzeDez6+XhV1wj92nY9UtY3zWsQ8p2RbJN09m6y9n6y5imKWzdH5GUKDK1TWN7IjA3iBwYgZ2BFpqRI06G3QTbSBsewbaAmgtXOEoNJwKio52j4qIhoynEQIEopyB6TvzTEsoNKmeKdEprTQO1oFweMoQKn9LSVpLhDMfNgzW0z0KhnZapaAUBCw2XMw1T0ROiaSbbJmA7olirGHafWX8Te7+KedXN7HqJOfItM3iMr//8jwqY6/y050jGnDVpkXV6BZl44SN5J0lw2QkQOjBDiFWF9iRBeebsilPHz0zI82+aIVTNq8mLay3CTKBHS3FL6iZIQOEQZ9IwAc2IbEmOWz7hQAgrfPre14sWdt5wxfKsqDajAjjQp4P5N8ml6JEDPWSTCPJhvoWbTBsxgYnZQh2ZrWJRJQKhV49pQ49J7jbilJHkbWROjRShEefluB6ckcOqSq4aMMZ7lOF1CSGlxQs7dm3bMzQ4wbfe0JmzwLqVSnfCtNICkdUgQ1glwIAZP3qQNWI77hpyLJI/vMcodxkV2CppkMOywyRzIBAK3cBdBkzZ+TCXCyRG8k5Gqcck9hrFvhWzB5bNqraY7v56277xbifJEG5eAEAo6yWwR/JCYpKYksMxpFiIRxKLciVefAMSIMlSkkSlXuQgmVs3wQkn+Sf6I+Y89WIu34VD4lIJe7Qim1Hhg53NjW5eMmuV6tqG91/67Ly7Os0F7sRZFQWxVh2BGawqxMSRQ00SbvhKLpKCuJ6bQkp3bvt1IBweGvng5c9UikZVXI8G0A74VuImgOTRSD2IZCKkMjWQIQFmvHEULoPCBXCoQRokQIhMRfKHBN25K5AuCB0aIa4EDinc3VoRLiPziyhLkzQdfBYCuZv8BgdWogptBfBmiU0ZUX2X9fELzxDe2v1whqIqM6a55Mp+ks+EOw7POLky4ULFDdBi1ppgodRdrOjLiWrJEplv6dp0gR899oDrs2hRa1pEHV6BWCmNHI7JWCnBb4LZRjlcTp7ksJol4kI+PcgHH5MTPBDyMXHB+Nkzx9kftrEf3cduKWPWL2Ecs9n2SLY5hG2YDvjENFzur7+cAVZERJzqb5vh7wimBZl+zsuBCLdQT4tzPYehnBc8elcEzC2ooAtRPUXAQ6kYQUDg9GciopzUDSkQRYWbMOKfER4QkqHqNSGB8tEQ/FBLOGuJwBxjC8Ha2j8B06LQDsBt4zSmfhrbEsz2CP1989kHjMxrXvarV9jD37JDJ3gJUD5ohjA9fk16VKMx3m2Qu0mGEGY5dhgIhHKcnSMQymzJgvLsKysnMEM4eGJIPa82L66tcHYfFgriE3cXwSeHhuaFcCrsUosc6ZHNSaIJBsLBU2fWtz+cGlexJKhSI3IUy/uN0l6txKuTki2RkAJFLAr1cMkoGbIHHIriK31F8R6TwoNpNDm8DeaFVrXICofOqHCb4n2Fcq8J2ckFx9OgwD9ETqDzSJKuIWkZB7yhMN6jFXUvmrliUZDxvZe2TmBLIZzZ91/abs71JUwvNUq9JXP6DFj4hx/NpbCktHrQSTdGLya5QbkTRuFsT9Fsb1G8q1DhMMrt8PtCWV+RvNeEhZoAhF5EX2R1F/4o8QHFmSTeJdNW3e/828G9R8a9qQxz78DmGwAIJT5tLGyYh+T0EAL1tDaPVjBiMbODHFUHgVUO10kO01eo8BXG9xUqejFPi7/HjBZmFGUe7s9hVXAxy2kGz6HC6kd7MZyseFdqRNXSqKLPP9h9frWjDRpvSkiNKs6O6UFM4iEHYhmhFE86DgKE+XE9CWMDQtiMD177PFtao4nrNtDEpjRQ9klraDFnCBeqTwcHId4D15hO4TTMcaqkNjUmfu0aFARyUrQm0ELOMnnWA0cVt1Dk0AEE4uMeLhFHHmSQZxnYIuuFgUW5eP27A8k6D/wJXDZqSU9mTN0G21OHDxwnHhvnWUIC512f1LQobI1aYjPIafkrKVknJdkka+0kZ59k1/H2wVJh4PlFs8pbim+eQNeTX93OwiVtKZFmrcwBd70uUKOr4dKzmBbGGmaFJzm8dpmkhHee4IOPyQkeCPmY0GAYxMKRIfbsKfbMCXbwGHNsH/vjDubLv/lf9fg3rWHuzPJ3ixlgLfNlbMV/szW/Z4G1WqaxHUGcPg325oWyVHeU6osi3YUz1OKi42dW8tRI8NwQUHNCaifIlYB2jhJm2KjxINcW2El0TbuCuMwhzVK2T2Mb/4TeG7X/zdb+l7/2jyPt4cMDC0aebWa2P8Hs34rSO6d+YgePMoPH0Q9weJD1D+Mu808x+SCCEIf2HM2YsyY9stFICIcDQjkyIYqL4HwRKMitE3enhJXnXl09gRlCAMKcv1TkxLQUxfcZ5T4y5SU1bHTyikVZmDCEGW1mZEuyZMUEAqF/hOkqvWVp+IqkkBqt0FGIQiYAOV7MUQCaAlGQGTAOnI67SPYMpn0etbBbGVa3eNrKG6cUL7jMeN2f1df9WTvvcsON00uWBVemCRpzYlv1cruJEKMx3ssVl5JWLo5MaMEeLTSVOFfE+4rlriUzVqRElby8+Z3zUOn8l3Fo/zGP+b6lwavVcTYjsq5HL8J9CQAhRVO6GYgQwEWFcoc6rjNDYE4KKl86c+XiGcvhddnM1SmhNVkxrflxFiDkQkWfSd5LmsqcepHbBCQm6wUaNEocS6eX/e2+d48fGvc5givh7r5H503VFEl7DUJyzEm1sG60apTjGYdaZM+LtuRHdxbEdubHdObGdGZHt+fEtOZEdeTFtMOp0Yh6dBI7zM5LZvcXyrCHkHQVYsqXttWpuX13kDwe4KW9JB4Y3pEaWZ0qKTu478h5POyoV3sSgyuBMPWYVXOTpBwmBtUSp1rsVotdtIlUJbYtClu5a/veX13h2aGRd1/cli6syovt0gHjCS0FsZZ8YXce9mr2EJUXS4EY5V40crs+3mlQOPVyl1ZuV4m782M71WILfJaGACFqNYlsgWMYyBBKEAjVsVZ1bE9+XDdsOUlp2ugB1EjtKqE1X2zlHhyQJliNFN5g1cgsKolVI+/OiKq9x/HUsZ8uSOTpxNHTusUtmTHNWJFO2A+ThAiEtAuUtrbS9CYtwHYZ5W6DzJUcZi5LdX7y+riLk887iha1pUSYge0Nch85m/hwQYN5Qhc+v8BSUnxEkhxWnSgt4UtG+eBjcoIHQj4uciAfnkWLi5M/sse+Zw59w+z/DD3Wtz858lybf30C+jHU/YGt+R3bgPorpKSTOkMI/LRLkLYC0v7AAA2ynMFD2IhF8DMgDNgJ0ppPy2hNKSkr7aBGggGz+66Ayij5OLYtGFVAq/8bc5iea9mnm9gv/sru/ZA98Bnz4072xAHmzHHcEZ79+PifA6a/P+09mhlfDkCoJ7ksLMaTouYETAeJPIYTfgMgpJFYkwQVAISnJ7Bk9PhgznWVuXFtRZgh9NFuMVLd56RiEoQPsS4uI7olVVw2gUDYs/qu5NjVGVGNCEUiNw4Jti/qabUqmYBiAa0UKw9hDpovtqRF1d84o3RR8Arj9R3OsvseHXjp+Yfee3XLB69u+eiNpz7ddMvLztV3r050pAtrEmaWJQVX5US16aRAhl6SyMKJNQpOiiiAEVUPUpFbrPAWiftNcq8yolb1l/pnH3x9QhwpNjieyItH6wVC1FjShv1OUpLfIDSo4YYD0AJ4LzF0zeJZy1MEa/R/ae3Q33pry6bbOx6/pWWzt/yBCqU7TVJ106ySBVeYbpxemhLaoBFbC+M9hUC8Mg9wVyHq7jgTppW889zWM6fGneSEK+Eu32Nzr9AWAbiKfKQ7y0mHhia46I9AWTJ7elRdtrA2V1abKa5MjVmdHLUqUbAyOXpNcvSqJSGlgOUJM1YkheLBh1NZqPCaUNwFWz01WMNJaRAFVNQSuxqvcDfQSHG8z6RwLwkpN6v79u3+cbzb36D2pmAPoV2PiiNustkECEVOFQzcfkxU5gl7Foet2DWGDOHQ4Nk3nvtwcYQxAbB8+qrrLzddd5lx7mXGeVcY508xzrvMcN1lmrlXaK67XDdvWuGCGUXzpxZeP6Vo3tTi+VOXL5i6PDGkOjumXSOxE4gi51o++pyFZKphk4QOgMzMiLYlYeULZ6xYMA3+lowpRfOn4QrnwWqnFy2YXnQD+XHuFNN1U003zoA3FN40ffmC6aZbLI9eYMno8w+9rZ3XmSu2YLk4URMlmkxU3tY52uCK947kZ42gMneBuDtP0WKvvOtCPn1cUbyoLTW8DggfgRAgEFPNTg0WhLuIWg9WU8NdliKoTZKV8JU3fPAxOcEDIR+/RfiHUaXm8DfM7neYrZuZ53uYmxOxjrTuD0zDn1lARJLrI2b0wQHfCCof+jOFmK5R/c8w4nHPmc4HLONDR0VKA26BAUdBukxBEd7TOos1/wl9F+su89+e6X/zFuarN9hDX7NnT/NVoHyMK0gP4dGM+DVpkY20B4lLGUnto0CoJ5WQwADLQicYCE8eG8y7vipP2FoU30tL+6iqIWle4nT8AGNUYldGbGuqbPXJYxNgSH38yMnbLJsyxBXZcc1q7KDzoJAJmSjTbB7FDx2pF4VXlciWFtm0LKw6S1xvX33Psw+8+dEbX3z7xf5D+4+dOHL61PEzp48PDZ48C5Pjbz7/ftu7u95+/tO/PvTO2vpHM6XmJcGr0iLqCkTdVPtRzZEYFsRS+oXZLTYuSn3ALQaFOyW8esUy6/OPvnuB+7jj4z21OZ7UCDPK8wCliF0mnHO7SVOWk1SuYvIHACkntis13JwcXrVysfXWtsde2vT+h699vuvTvd9//eP+b37a9/VPu784sP39r95+8dNXn/r7MxtfH2h6WHdd201BJYtmrsyIbFCJekwyT0l8r1bUkxxWtu2d81HshCthAwHCQlm/SdynlXk0pB5PI8X2S0Q48iOmB8VdzQW3Pn7Hq++9tPWdFz95628fv/W3j978KxnPffjy4+89/8jbj93yUk/pBmVszQ0zVgIP46xdimqQNC1Gs174KrYTAVi4tj2F8d7iOb0qsW1J+KpXnvhgXJcZbHy9xpccWqMWOZAWJB41fBzdcuy7o/4TLr3ckxvXvShsxRh7CL/46BtL6a112QMt6pud5Rt9tQ/21j3YV/fAQMODAw0PrW16aF0zvg40wusj/Q0Pwxu81fff2vHE7Z1PFM3vyYhqKBB262UeFDSSOOmRpOlBtZiq+LoKRF35itb7vH/d6PvrXdYn7uh+4i7rU3f0PHmbZcsd1idu73nitu4tt/c8ficsd2+5ue2xvsaHes0PwgdZTHe0aG/+28Pvnjh6Qfdjda4rT9amljn0WJhKZI3waRStGCcPpCQoF0Rke2ntq4Or4pa5MmOby5S2SXOoL17SnhpZT4DQi+CqcAMQ6uS0MRW+G11UfTQprHqZlAdCPviYpOCBkI/fOkaGmCN7mM+fY55tZXvnMvV/Yhv+jFYNHSFUUcZPpF/8HT+3jA/YRVBdGQTCMGaUAy3ce0h6kJOZGbWpQGMM/CeSHmwPZpqmsrW/Q4P4gQXsC3b/zlfZU4d/6yPCx//WoECYpqhIjWjQy7ErDEtGpQ6Y7mhlduBDouXgMGLnFQBhec5VlYMnhiYKCIEtC+ZVoaiMwmeEmZaU6NkEOq+0nOI8AKFTGd2QJF5+/IJ9CAFBX33iw8UxKzKi64lCo1eDNOghPX5ckxXJTLqJ6KIrX9idHFa7LHi1pWTDo+tf2vnJ3l/NgMF+DQ2eBY568t5XO4pvzp/dqAyvUwl7ApWKTjowM0n7JNHGEGjNAVSsEnenRlbX5HjffXH7hezmze0PF8xpyonrMCj6SFYQsJN0YQWMPQgUufLiupcGV5QudN7cuum1xz/8ftfBs2f+x+QknPMzp8/u2XHgxc3vbvA8XpfvzZab06PqdaTcNC+2VRXf+NX2787v0tjQ+9jcKVqTzGcQe3UKD1YsEz0emteiF0aB2Jod22wpueuLD7/9p43Dw+4f9p8dGj526NTnH3z76G0vdq/YkBRZmRRamxtrUROZTSr3ohJxTXScI4gcW2eNclfJlX1Lgtc0aga+/GT32LecAGFvSlgNNoXKUCdTI3NruCPspCBKgTBP2L1IUDqWklF0xTxy6vO/f/Phy198+taur7bu2/3FD3u+xLF3xw/f7Tj43c6D3+/6EV7hx707Du7ZcRCut28/27//60MwGlXrUyNqc6LbAbToMwgth9a0f5VSjTMzuqHgmsbvdh38af+xg3uP/LD78ME9R37Yc+TA7sM/7MEBC3T5wLeH9n31I3z6t58fgPH5e99ue/vrA3sOn3cqe2TYD6vNVFTnxnXo5bRTkVi5iO1UxYqm0LWkmRC3H/PqJH8oIf4icl9OXJf6utYXHn3v/DZgvFG4qC01sg6uIqJ9RTobEQgxQ0gcTbhS0sSwmiRZ6eRsEh988MEDIR+XRviHsaD0w/vZzWsYSyTTcDnTOoskCQnpkZpPP033dRCL+U4O9ugvqR4pyyEiESklQEjeNkqGYQCZ6CMPayDmgWzzNOxgbA9hN2qYrY8yg0f5lCAfFxIIhLuPps+uTI1s0OGjegRCmpPRSm16NB6AqZgd80tSe1JYRdbsNaeOnZmQGmSYSZ85OaSdX50b22pS9BoIEGq5alUqM+ighaMqsT0lwpwqXXHy2AWVjA6dGd767q6qTOfcKSVqsY1o2ROhDrFbIyTu4RIHzdoBCpoUHo3YmiKozRbXDjQ+AJPg0yfGt+NwbL/44NuNvmfrcwZU4tasyEajjKiDiIlNQsDjUYfCntjhpkenNW9WVHNqdEX3ytuP/HCe9Hto/7GViRZlRC3mP6WYHsRsJJf75ewlSL7FnhPXvnKx9ck73oR5/7gye0DFH732xQbn49YVG+rSb84VNSYEFS+/sXvvrvP0VLx34PH504xGqdcgInYjRFNUS6tbOZ1MvAyU4bUNBQOfvv3rzWPDQyNff7p/ffuj2fHmxNCqvLguqoKDlvEcEDrpEweiQIMXefHs3qzolmWC1S9v+Tt6i485GnR9qQCEIiwZ1XB+9FzVKMkTooOCXu7NE3YtDh9Tyei5GP+N5h9hHEDqdxYAACAASURBVBX3psfWZka0AL2oA/K2NCGsGwVCiT0lrCojvuoieXv+cpw8dvqB3ueSo8pzYzsDfi3Ie8ireNE61KIeuPu4QmsiekTPEVE/xvrnAlFPelxdo65/MjaXYU03tSaH4Q1lUHBAqAs8s6AeM0YFdgsnC8yp8lV8iwYffExO8EDIxyUVDHvqp5Gn6ke6YpnGqcSknqvzZLpCuG7ADjI6Q/yctAxnTTGqR+rvgBEWUBylOqJhlCRp06AfLexD2fYZ6IQBf/6Qkd2/9bfecT7+HYICYebVlcrIekA+oi/qIOkUu1qET+sNWLhlN6LIhz1ZUJkpX3PyyMSojEKcHRzWza/JiW5Blz+iGKkhXmqkqJIUuZF8XYHImhJemzm74uTxC6oQ271jf1/D/fMu1+fH9ug4GzdKHU5tIGuH+hDYe+YyyG05cc2qOY23tj5ydmj4vJOiZ88M//3F7a3qgeTgVRphV6HCa0SPCiRtg5TTUaQ+e+i9LoOZujMJAOYq89Mb3jy/T3zlsQ81f2nMxPZIB02tUGM6zmECPh2dJOzqOEuBovXFB98fPF+P78FTQ3t3/PDcfW9VZjiuviJrxaLuvTvPEwjvW/vEwumF6GAh8pGUi+P/HQTXxa7E4MrqDN/Hb+4Y42oBXG/ufiRvTn1aeL1e4iiS+4gtIak/JEI1aG+I3nfUeMOjkdgWTiu91/Pcj/uOjn3jG/X9AITqOJuOeEJQ6SDuoYaUliJ79DIfQOmS8JXjA8LxB9zRN7c9miU1Z4Q3G2U+3Ay8nQOGhBSo4F4T2VJCqpNiV564sIcs57OFDHNg709whaeE1+TFdOlFVPwGHUQ4E0WpLS+2tUBo0ZBuTw1BRJLbtNMHBEa4X0S2tPC67PjKE0dOXWybB/i6M93YlhxSoxHZjHIP5tixmh2/JKn0EX1+ZJA5lRF16fLVE/X1yAcffPxy8EDIx6UXg0dHNq1m2kOZpqkMGgZS28DQgANhCE0Pkq5C2klImRBFaKiRfcCmgjpVoIk85gwJSSIiWohmafNUpj2IuS/fv+vl33qH+fg3CQqEGVdVp0c26PGZN3bvqIjeBszD9DLiQyiBaZBTL7elCKoy5eUkQzgxM56hwbO6+bUUCImHG+fUhzM/GW18culkngKRLTmsNjN+zYUAIUDdk/e+sji4JDW0ziTr1RIgJPKJuMtEwYLzW4M5n1Fhz45tVM9pvqN9YuzOPn17x4qEzsTpy2Gyi5YJiGQOvZgTziHuGkTcVeo0xfcWiHoSZq5SX9dw8PvzEb10rrkvI64mN6bdIHNriZZmAAgdxNINyAd9MvJi2w3Xtw2fHbnAs3nm9NkPX/1ct6B++ULLnh37z28l9w08vmCa0Sj26oU+YoQAR8MBPEAG2X48TQCEVZVKz0dvfDn2NZ8+caav7uGMWHN2TEtJPPE5JPofo0Kj2CKLmVtsVCuK9ybMWN2ovvmTt3aN/SMadL1KAMLYHi3RFEX6ErsCHg+0+BkowpsXa1kSvmIsJaMXGLd2PJYpqU0XNAEQask1gDtLzf3Icwej1K0XOVKCahKjSyc/Qwh34vb3v1L8Ljdf2BHwk3QaSHMgcZt0FEg6Cq/p0sgsBSIrLRmgD6o0hAZ1+JTKaZK682I6E6NWv/bkBxMiwvQLAfegcWFbEgCh0GbEXkHa4OpQS+3EyJEUFMR7DXJXWkSdUraK9yHkg4/JCR4I+bgUgzn0NfNgEdt0OdM2DfiN7Q4/ZzBoQX+Ic2oxNIXItRcKWOpOgT2HwQQd6b+GjL6fCsmwbbNw5RuyGJ4G+Zi4ACA8tPdY1tXVadEN+ngnp96B6vyYUNIrHKS80GFSwKTHnhpWnTHxQFiXG9OGQEj80LQB2zRqSqYlBuXqOHtaZH3GnMoLAcI9Xx5w194zf2ohpiKFbp3IqRURe0AKhIiCqKeql7iKrvRpJJ154qaBhocnygQC4uvte7OFlckhFXAkibmcPaCgSAy4ieOiVkqzDd7s2NYbQozu8o2Dp8advlu1tAfQPT+uyyAnipcIJ8SYDkt/idkgWpN358e11Wb4JmTXhgaHv/xg70DNQ/u+/vH8XOnuGXj8+mkmg6TXIPYRYPuZQQK3jBWYyaE1a5JdH7z6+bhW/trmT8sSnctCK0wKT5G8D0Vf6emmBowkNwWvgHPL5wykhTfkxzf99aG3x77+Bo0vNQzTRzrxOXMR2qWpQYUkrEnWS725sZ2LBJMBhLd3bcqS1qaFN5kUvVzZLX28wm0VemnCZQCEsyzqN8gQHvzu8J09j19zmdYQTyAQn8sgUxmxhNuZHdumv6r91qYtFUm9RCuVeP3BXogc1AADq6wlyISquB5lZO3ypW2nLqxw4FcDvu0MN7UlhtZoJHZDvFcbkJ5S09J62AW52xjvg9tNGV6XLCvjfQj54GNyggdCPi7FYPwj7EcPM/03sA1/YruCEfZ6wgP2EoHSUBiY7hMwHWFYDkrc7f0WakWIQMhyGcVQTlCUayYkOcaGK9iuSPb1fuxd5IOPCQpiTH8086qqtKgGvcKtlbnoY3haY6bHIkaY+tiNAIRye6qgKjO+YkKBcFg7vy4nrl2Pkgwe1OuTBhiJTF6JJIarIM6aEmFOn31BGcKNfU+nRJZnhrfC1FwjRBs9jjRIyShXL0rADHY5Jay6p/TOb7bvm5DdpHHm9NCnb+5MDFuRHdWsE9mMElKOy30u191HGqXcMI9XS20JM1clhJUcOnhsvPNLw/WtaZG1GnEPdZUkO+XkRDWJjr8Bzm9ctyG+a23dIxO1dyPD/uOHTw6dHjq/2fA9a7dcP11vkvr0Qi+xnXBoAxbqJG+MxK4ROZODzTVZfZ+8NdaSURpwxa5tf2hxyEpAssJ4BEJqdK6hTz2k1P7OoxU6ixU+jciaEFT6wLpnxpibhbfRHkJNnJ0+YtDSqlGsKvSQik1CiXJPNgBh6PJd2y9uySjEre2PZkiq0wRNRnmfRkbVel1Ur5WKrBqkgMRA15VJ0csnHwg/fW9nirA8RVAHm2GSexHI5S6DAr5qHGpJz5KZFRsdz369dV9nyR3KqEbMwuFl4OBMFKUu4h2CN4tB6iiI61gSXvgjukeez2OIMQZmCG8iGUK4dwAIZc6fAaFLr0BPwgAQmpWKsou3JXzwwcfPgwdCPi7VOH2Y/VsXW/8npnFKwGCQUxZlO9BUkO0KYS0IhGznaNNgGBWPYbpChrsC+NcV4qf2Evj+MH9XONs2AziTeaaFOfxP8np88HEBgRnCPccyr6lSRtcTGQ+XhjMksKOCgtxFSkYxs6SXWlPCKjMU5aeODU6YMf2pIc31dbmxHeiSJ3FTAUxDQFpGSzNmMrdabE2NrEmTrzpvIDzw7aHuVbffNL1MLXQhEIrdeupNR9sUidoKSRm51EJbZkSd4ZqWLbe9NIHpQbK/7Ikjp7wV92TEVOfDLsuwepOqJlKrj9FtoM7sWdHNC2aWPLbulWOHxqEuA5PXvKtq06Lq1GKbjmvK4oCQ6Og4SGbSrhEiEPZWPzCROwgEdb7XxT0DW66fZjDJ+o2SXi1V6ZQ6AklCh5ZU9sIVkhJiNucMfDIGUZn/Z8MY5tFbX8iR12dGNhfPGQikBDlfOwMiExWtcZpkgCjuuVcYb3dsGuPZh71G24mQKnVcDzVPpw8aNPTIc8qu2EOYH9O1NGIygPCW1kcyxDXpES0mRZ+Gczoh+XaqcItdsr1w7aWEVqVEr5zkktGh02dffvy9667QGGfTxKln9PqHrxqVuOuGaSu2vfPVqeNnvLUPZMU1qcTdALSjQAhniu4RscOxaSWWpaErN3qeO/rjiYu3zXD9GG5sTQqpVktshngPlY3lKgswqwm87TTGe41ylzLCrJSv5jOEfPAxOcEDIR+XbDDMl39jb17K1vyeaZuF6i+BFB9Lh4UUkQas6okphYD+E5pVoAG94Jw1RcC9cKQ7km28HLVJP7yfGRm36TMffPxCBEpGq1Ij6zRERV3DuZY5ClBUxknbCGGWrJNYU0Ir0+XlJ49OjKgM2k6cOKOdV5cX12FS+HQyj1buPqfyQhKVZCLrVonsqVF1mReQIXx245uGuR1KQaNR3kf8HjwkKUTm66RSlGbqDDJPTnRHYlDZ+qaH9u784cL38R9iZNi/8+M92r80ZQgatEK7AbBEhm5mVHOf5glJM6GbWHXbk8Nqi2/q2vvVOJRaRs76s+ZUp0c3oOIFTrW5Ulii3erQo4+IQy+2a+N6NOKOFs3NE76P5xcECI0mRb9B2osqndSGjjwa4MgQKQ6AsLY2u/+Tt8YHhBDvv/R5Q/66VEFd0ex+HdEspWq6RGXHRdOzJO/kLr6y97opxr62+48fHtvFxmDJKAChRmg1kI5QrlhUwqUKiQ+hxyDrzYvtXhq54qvPLnrJ6C1tj2aKa9MjWk3x/bRmWEPdLyS0KddtkgMQwsGsSYqabCDc9ele+8q7bppWVDSnXy100H5RFDoiXzV5ce2JYWXff3PQP+LffOsryxfasmNadSTJSa1HtDIudQxkaJDhn6RHmo3zWnfvPM/m1bEEEZVpTQytpiqjRPiKbolDR8pc4WsTgBC2JzW8NlVWxit/88HH5AQPhHxcwnFsH/OCg636Hds8DTOBFqI1Sl4DCcNQf5cA04OBDCGlQSYgM0PUZQg6Wrh0ot8Swdb+zn+vitn799969/j4dwsOCK8CIKzXBoCQdhICEMKMhyKEUQZTW2sSAGF8xcQCoW5BfYG40xTfq5d7ab8T59QnsQfI0K0WOdKiGzKvLD8/IDxz+uxA0wOpEVUFcd2Fij6SNPNopdTqms7aHbRuE6gAGCw9pvKvD7w1fPaiFKGNnB1pM6zPiK7NjWo3EAcILZZxIhCiM56IeHBTw3q5J1/UtSh05bsvbIddGOP6/SNM9pXV6VENarGNa3ZCznHQmTQR1XSgpI3YrortWLXYdebU2UtBAgOAcP50U6GiXy/pxeJhOPtiWt9I/AOJ5A+ATXJwTXVG79hVRkfj288P9JofXhpcaVL0ko41N9ehKiVeFJyUER6f4jm9c6eaHDUbfth9ZCxrRh9CtQ/gSiuyGUlHHM0gkYwc9j2q0HzCo5f3Fgh7lkat3DU5QCgxAxAa4WqXkYZGMXpO4MVA4AqBUOxOCa5JjJlsIHz1yb8XxNdnhtfrpV4AQpqfR10fNHm3pkXWly7sPnQAJV4/e+/bNuOtSYIajdSul7uxq1liI9IyHBDqcUfcKnH3jdMLP3rji7NDF6uZAk5xYUJbUliNGnsIPSQxiCqjRKfHSStyjQqsfU0RmFMVqy+FG4oPPv4TggdCPi7h8I+w255imoOYZpLToxDIAWEINaJAIOwUMFyGMCxgPChgOCXSQFIRSTIEmwzbg9jq/8O8czt76tBvvXt8/LsFBcIMCoRYMuomUoQOFQCD2EFmXSjrZ5S7tWJrUlgVAOGpoxPmQzh4asiwsCFf1GGa3auTe0geIFAoyKUKHVjGKbIrI83ps8tOHj+fyeuOj/Y0qvpTQmtg3mkitalqkQtrvaSBji8CY8Tz0HnDjJKaLO9YnO7OO57b+JZpXkdGRAPiGSYqSSpMwjUTUnUZHYouejQy+6LgVXdYnty/exz3vmZufWZ0owYLRKm/AhKvTkYFMDAbY5Lj0IutRVfbN93y8rHDJ3/zKey9awEIjYDrCIQSYjtBtTGJCQoVStVI3EkhtRVK74evj0NllMa+rw+ta9mUELSGMx7kUnmOgOUm5gZJbaqjeHbfvGlFPWvu3PvlwbGsmRrTp4bW6oR2opPpPgeExHkC23Glbp3CpxL1LIksnQQgXNf8cIbEnBHRZpL3kS3BJKGac3VHBRejrFcvxgzhsphJVRkdPDn08Pq/3jSzRCexqVEkxkNEYlBaxiB3Fog6lTHVG53PnjyKz32OHz490PrI4rA1eaIug8KDQMhVkiMKkrwcGngaZ7sXTi282/nUD3sv1v+PcIqxhzC0hmQIyXMrWjIqc2oIDWrRh9AHX18p4QCEZbztBB98TE7wQMjHJR3Mnvf9tyYzrZcxrUGcxCj1lsCGQKwO9XN5QnShoFb1bAfnWU/qSKmczKhCaSjbPIVpncl+9RpM3n/rnePj3y0CQFiZElFHTf+oDqFK4lBhhSEOncxmUrhJBWNV1pwqmKhNVIZw8ORZ/Q1NubFt+Hxd4dHJKRACIDlop5AOzcQ9AISp4bUp8vNURHx07QuGa9szI1uABo0yj0HmVYucOnQ/J7k4YnehE6PyJ9rQBZU8esuLh384fuE7+D/Fof3H6vN7MyLr0IJCwQmoUM2PUZFVci6wgDYltKo0ofvTt8eREyu+qSM9ql4tthoIEBLpS0LXHPm4iBUhMKHLILFnxpo33/7i918dHJcV+4THvWsfXzDDaJT59BKvjtZzEllUzoSQ5jllnuQQc1nSuFVGIb7Zvt9T8+Ci4HJMelOfQy4dzVnbwZWmJlheqPAtmFZoXXPHdzvGCoQN+j4AQk2sVU8d6jgI54RSCcq69ApfgdB6U0jxJPQQ9jc8mCmuy4xsxx5CKZWToYoyTmJwAgDm04pdiSHVy2InVVRm5yd7bWV3LZq1yhTvRSCUePQyzNbCXWlUuLJjm9NEFXt3/DBqI/HkfW9o5ranRpoNs9068oBAK7XrSW6Q5nXhtWiOb2nw6sKFXZ+M5x4ZbxgT2pPCalVCm0HmoX2hSNoyhxYNWokxvdwHX18pESgqw9tO8MHH5AQPhHxc0sEc2zfyRh9aRLTMCqiMEh1RSxjbjWlAgoIh/s7Qkc4wfxeHiwyKxwjQhr4zGAaDr8ShvmMWW/8H/x3JzIFtv/We8fFvGOhDiD2EFSnhZg0K+hFXehG82lUiO6CgTmrXSayF8V6dzJEUXpl3Zd2RH06en7XAP340w548Oqif15IV1YraEsSTXSfhpn0BV3rEAJXQkSKoT5avPo/JK0zOHKs3pMfU5gu7C+N7Sc+SC3aQkidBDizX1IsdOpEjN7o9R9a8/f2vL3zvfjksy2/OjDZrJVZTvG+UHM4xoYTzYyyU+9JDGhdM07/8xLtjh/DarN6M6PqCOAvOm6VO7FSUOEjDFcAJlmKS/XUZABTj7KlB5hummG5r37z1rV2HDhy72JZu/1Pc079l3hSDQeLWizzEcYTmh4kjORGWJFeCMy2ssXSx7b2Xxv1luPXtrzpMdy4LqdbJnTqaaKLaRYQJ0ZBQZFfDBS9xmhS+eVN0rto7f9gzppJRiAa9LymkOj+qB7v1pG49Mc3jBpd8Bgbz5sfZFswq2nmRjenhOukzP5glrs+O7jQqejXkjg4AIb27gak8sLw0pGpZ3KQC4RN3vqqKb1KGmo1yr1bogksRFoxSt0nhNsQ70qPr06Rrhk6fq2He99VPa5seSphZYpjtMMEFILHBMJAKdj0xJNQhwPemhNbcMLP0pS1/Hxm+WM9Mi5Z0pgjMKiFhfg74Xfg0ActH8WmCQQHXrTNVYE6TreF7CPngY3KCB0I+Lu0YPsPsfJGt/S+2fRaRDA07N4jHoL+LmE8ADXbgMrElxDGCVaOjRaTBTBeSIds6A1bFPN/GHL3ohUZ8/AcGBcLsqytTw800QwjzRZXYRnq3YDpu08sQC02zPVqZPVlQUXBN3bFDpyYuQzhkmNeSG9tulPtQCp8kasgrZ/1MiyrzRbZlIeal4uXHx1/eNjw00qjuSw6rxtYpRS+1NyStetgeCZSrC7jSw8Q9Mai2Jm3t19u/v/C9++XYYN2indOaHd1ukHnUAc897ajlBmEVOBdF8r6CWMu1l+meuOdVOFZjXPnTd76lubItJ6rVQIga635J66Ceq7hzoKWbyAEMbCCdijmxrTdcYcqMq7i9fdOeL38YPDU0+TVvd/dvnjtVhxIvEi/AKskMu3Qcsds5NRSJUxnWUJLQ886LW8e7/jef/mRNimdZcI2eOD2S40yN70kuGmb2IrtGhEW2gOhzp+j72zYe/XFM4q5YMqr1JgVX5cdatRKPVuymJ5E0Pdopg6FekdSnEtnnzyjasXX3+A/POAKgaKDhoSxJfSYCYT9JgXLuHTRJSGwn3BqhbWlwBQLhZJWMDp8dub37sSUzV+TFdJjkPuIr6DTKfEapq1DhUYm7k8PLVy3t/PmfwLfTMw+8viikJCOysVjh1sntenw+hY8J9HI0q9CR5kOD3H7Nn3R3OZ78ad/Ri7HlcIqXL+tMC69Tx1n153K/9LGCA7W4cBs8WikWMiglvKgMH3xMUvBAyMclHgz73Yds9e/ZZgDCCEwPojCMwP8zwRiuY5DCYafA3yFgSVchayGGEx10BDGds9jWqQiE259gz1zEGjY+/mODloxmX1WdGllHDKCx5UkltqulMGwGmQ1mYFqxzQBzL5k9LdKsva7l9PEzE6KrToFQc31TVlSLSeE1Kry0EAs3Q0YqBml9o8ytFtlSQusSJavOAwh/2H24TOlQRjTAjA2tJmSUBGBPbVrygJ/6XMMkHlu8ZpY9OvDyRa0XpfHBS59XZ3iVYWY91SDhitDsRKOCpD5QzsdlFPcCJ8+/wnRH9+YDY24jPLTveElCl1JQZ5A5THKPLkCDMAy0N482K8JxIEe4UNGrFvekhFUtnrU8X1bnKdv47Wfj0DWdkLi7f8vcKTqDxGmUEtd4quzPkRW1IcGFjPCWkkW28wDCTbe9nC1tTA1rMGKNootYnNNENGmXpabn6HwAOGdfMMN4h+OxwZNjEvKBy7hR600MqsiP6dYBaIlderGTq9IkOi4a0gNpkPkKhPYbZl10IIR7c13Lw9nS+syoDoO8VwX3ryzQnsp5eABE+TQix5Kg8kXRJZOWIfxm+76OkluWBK9BYxWJG4BQJ3aYFD69xGNQeLJimvNmm1965P1/+Kv3X9xevLBr4dTlJQoPVitIOe1ZfGQgd+tRB8teMqdv4bSVhvkdrz754UXa+OJlncoItHIxYq0E7RukKqNIg3CE9QCEMieKykj5DCEffExS8EDIxyUf+7cBDbKNUxHqLKNJQgC/UKYjGAtBqdkgDgDCMGBC1kL960NI1Sia1OPfts9kW6awtb9ndr/Djow1P8AHH2MPakyffU1VcoRZQ6ZZainqOuLAdh2bTsIBoVZqTY8yGxa0AcXBX42WdZ13wwz84ZlTZzXX12fHtJjifUai1kDoBSasHooBOkQ4b77QnhxWlygtPY/J6yev7yxOsGRE4UfoqAU5ymyQ9GCgQhXQC3Mmcd0LphS++9ftp0+cOb89Gnsc2n+se8VtScEVek7dxE4VTUhelCYfMLFjkHqXzx6YP8VUne35aMxKKiPD/lbDWmV0db6wq1DhwzQgkTPVcTRopyRM3N6BVWxaoR0m5QAt2THtqeF1adFm9dVN5anOZze+c/C7IxevDO/ncffAlrlT9Xqxyyj16ogCihpFOzhlVFLW61aLXQCEZUnO91/5bFwrHzw1dHP3psVh5TkxHUaZBx0ISTslHu1AmyJeGxJHYXxvbkzHouDSB9c/O8a6aOwh1HmTQytVcVaUw0EgxKwmtf5DeU8RCufqpZ4CoW3+zIsOhEAja1seyZQ0ZEQCEPapYQfROcYVyBDiMMi8pGS0/KbIoknLEN7nfjpf0ZAuaChU9GKbKDnsJpnXIPFoRfbU0KrChKYjP/yjneBP+44+0PcclhMr7Aby7AYLiWUOg4JkCCXYDVs4uy8rsnVBUOnGdc/5RyaexuDrrnhpZ2p4Ldws8DVFrCaIMwrSIKAgijYZ5KRkNLxeKa/ggZAPPiYneCDk45KPHz7320RMzR/Z9mCuRZAbqDVKJUZHXSiI+UQ40Y8JI02DwczoACBsvoI1/5EBwmR+S8kHPv5dw08yhLl/qQUgJPr+LpXEDguYNpHYOVEZ1D4BaOlJj6otXNgFFDchMx6YSZ86fka/oDknDkVlDBwQkufuUq4LCzM2Mg/6EIbXLROvOA8gfGTgBfWc5tyY9kIChJwahISop4qJ4AcmizAPWRBnufZPui8/3j0JfXRDg8Pu2rsSg1fDVFgrcWuIxQIx3xstH8W0IUzcS+esWzxzpeqq+hc3vTv29b/17Ccrl1qVgnoDms759MRtT0+zrxKq2EngENvbkA+xVpNkUAFd8kU9WdEtaWH1+uvaK7PcXvPG917afrGPyd39m6+9QmsQuwxEVIaW5OkCfaQBo0h3ZnjTmhT3B6+NT1Rm27tft+hvSUbbAButSdZwjiZIblz5KPba2UqvHlCG1mdKap7e+NoYV45AqPUkhwAQ2vRAs1IiYSpGsMcbSuxQCe0atLj0akT2BZORIWTXtz6SJanPiGw3xfdryO0M15WaWCPigx6xHc41vC4LqVgcWTw5QAjXT0/ZbYkha/JiuowyLyF85GSTzF0k9+bHdKZGVDYbev8ZwuEP33nh04Tg4ozIJswQosYVfi8ZUM0Fvy7I8yMf3M7zpxd3r75z9xcTbx8KUbS4IyW8Vo2PxjxcgytcMHBlyjnbCYMCtseRGlGXrqjkgZAPPiYneCDk45KPn3b5185na/7AdIxWhwIHBhNLiRAiHiPg7CW6qBuhAB3qLeHYOohaMjSLGMISIGQapzA/7uQlRvm4GAFAePi74wiEArMKW55cpF7UoZZhhpDMwGwIhDj3suXGtWivbn/lsY/efHrbR6/u2Prmrk9e3/HJa19+8saOj2HhjZ2w8OlbO+nY9vYuuvDxG19+8uaOT9/Ef9361q7P3vvm8/e/+eL9b77e+t37z3+Wf3V9VkybKd4Lg/OZoIkykkAAIDRIPRqxXRlWu1R8PhlCx+q7s2Lr8mMwV4YloxI31ZWhGUIi+2E3oEigOze249rLdXu/OjAJGoGMn+lv2ZgSXgEUimqipHBU8zMgpHWkQBHL49enCWpTolY9cfdLY1//iSOnXeX3KCOqs6PbsCpPii7e6MAuDcj2F1cQhQAAIABJREFUwHRcaMc+Lur3KEbLBJipA9IY5F69wq0W2QELAaIyReaqLM/tPZtff+rjMbbVnUds6Nt03RUak8RjBCAkJoGBs0M8J5CWAWi96QCEye6/vzq+DOFdzidUc1pyotvQFkISeNwQkJbRYVWnXSO1AyOtvHbdTdNW1ub4Pnr9izGuPACEVQB+KIyEJopuko7jikXJAN72qkW2G2YVX2wg9I8wN7c+miWpy4yAU9+rwYc7uA1EKQppEHuDZW5YXhpctTR6+fGjF+uc/jw+eXPXqmRbUkg1lb3VkAJdIGST3ANAmBFeb1rQ9vS9r//Lv921be/qZPsNU5Zr5Xad3AFDLyeV1TLOJdUg8xTO9i0JLtfNbXvqnjcuxvYXL+5QRtTBwSR2qeg5oZWTJmesF3VpZC49ygXbU8PN6YqKi7EBfPDBxz8HD4R8XOrBHP7Wf18+W/N7dB1EzAv1o0gM1RcNpW4Tfk5dJoxLIXZQV/oQlrOdIEKjWDJ6xUhbMHv4IlcZ8fGfGigqs/toztU1yYI6FVEjRCCUOVVSpwonjsCEVp3Ehh1oMnuBqCtX2FyXub42c22z+pZW7S0t6vUt6nXN6nWNqrWNqnVNqrXN2nWNmoEm3VocsKAdqFf11an66lX9dQV9Lbpbukvutpbe07N8g2vNxhbtrWmxtTmxHUgjCmpK5qRAqKVVlIQJtSK7MrRmmfh8FBHNub3KiFpVXLdJQZp/iMWfjhYi0gpVrDpzmxSezOiW+TNN+/b8eDGO8z/HbT2PpUVXZ0e1UbtwDTIhdd5zBmRmXAaptyR+fXZUy5LQ4kdve25c63/j6Y8rlM6lQatVwm6AYXRsk3tGW9qoHQL1+qPLBBrdnAUi2rv5CmfD3NeeHdOSEl6TLa6vSvNusD319nOfHj98asIL8zb0brr2ci3QoFHq41RGuU21U2kWAoQeZVhjWaJrXCWjH73++RqlI1lQi7N5fLhA+r6oO5+Uq6IkZIjam4WzPdf+WXOX4/Ef941VYpQAoTc5pFotdBjkPgKEJBENTChEFCSO6nD7eAqE1klQGYU7en3LI1niuvRwAGAEQnzQQICQ0xpFOSXMuiMQxpZMToZwXevD2bKGrKg2uBQJgZPGXVQZ9egljpSwqkZt78G9h//l3x4+ePyRdc/P+V2eStKDGTkAQoUTmJD4TziNpMgcrtWMyObFIWXeuo2nT058yXdJAAgNBAiJCyLeO2oJ9hBqkE7dGok9RVCrVJRP+KfzwQcf/zJ4IOTjko/j+5mnzWzt71nsIQzHLsGOYJIkpNbzglEy9FOLQmwaDCWOhVhWSkwpiMRox0ym5fIRaxx79Lvfepf4+PcMmD4e/PpI9pXVKeEN6oADoUaGpWVYMip3UOcJrcSmFdtUcZa82LbcuDaYGy0Lqk4MqkoKrkoMqoSFpbPKF88oXzarYllQxZLgisXB+LokqGIpLpQnzFq9aFY5jKUh1crIxrSoppTw+mSBOTW8LiOyRSW0UktAIiZJEzioJRho7nJrRDZlWPUyUfGJcWYzYLK+MtGaGl4L20/wxkEmcy4qTUH6FVET0oDmhJ60iMZl0WUHvrtY9tb/EPd5n84Sm1ND68mUnXOK03JdXlyeEABmefza7Oi2hJCih255ZlztmsNDI0/e84p+bnNicDnwvAmYUIY5WA1Rd9QGfAhQf5JIqsDc2qBwY+Wb3GXEV7dB7iqc4zPN9ujl9vy4jrRwc1pUTVWid9MtL3/y5o5jh05OiLYQjbt8m/7yZ61BjEA4mrvTcFhoJxvs0ktccLhWLHGMEQhh87a9v6u+oD8zti43tlNLMrFqqviCvakubUD3hSw7Cmf35US1zJ+me/Hxd8a+a0Rl1JcSVqsRwvmCI+ympdfUUnIUCHUECOfPMk0CEK5tfDhL0pDO9RA6Aq2DXLG0FhsavQCES0IqlsQVT0KG8PSJM6vSepIE1RqRvVCOQEglfLQoKuPNi+1Iiaxwm+/+ny7vkWH/zq175s3QZsa0ArcHkoQuUuTsMpLqTbhi1RLroqDVlTnuT9/eOcE7wLCFCe3K8Hq1GL4SPVS2l7a24ncmKRnVy7EtMznczAMhH3xMWvBAyMclH6cPMW+tZev/zHYQK0KqJdMVTBoIcYx0UFd6khjEklGkRFSdQY0ZWkoaQjKEM5imy872X8se3/db7xIf/56BQPjNkayra1IjG6miCWdWhpIJdtquo5fZDTJCaGIrulCIbRqpjRh8E5SSe42YgCJ+YnJfYbyvcM5A0ZyB4jkDJVevK7lqbcmVA8VX9ePC1euKruw1zfEaZ3sNgBkKBA/4LD2wh8JDtR9Ro5/M8PSBybpO5laJrMlhlUtFxvFOXkdGmOLFnYCdsEJ0/KPygDJ8wA+0g9tP7OlpX1BqmFk7t/XH/WNNDV1gbL7jZc3VLUlB1dQYgGREsWpRTazSdYHy0ZL4tTBjTggueWD9M+N1gzh++PSW21/OklQnhlQg9yqIsQdxRKB9bmRe7qIypHhAKAcqPHCCCBBi2tYoR5u4ktm+0iv7DApXdnjLTVNWrV7meOa+17/b9cPYzTB+Oe7u2zz3Cp1O6DZIvIEeLZeWqv5Q70Ss8nUnBdcWLrS8++Kv+BD6R/zAq59/+PWqFGvCrDVpgmbC/y5ipkISpGRCz3m1kzXDRN8Y775xSknRje3jsjhHINT5kkNrNEK4U3waFBoN6HlKqMoo0r5e5gUgnDfTePFLRv399Q9lihsyIjv1sj5iQohiURqJW83lhJ2EThEIF8cUToLK6Na3vlbNbVRGNhD1Jg/2iGLzKj79gYtNGVlnmN/62O3P/8IafjpwpHSpJTmiSiXuNsipWwxeITo5Di25kQvjPcqIujRh1UDzgxPrmwJfksYE1FvS4DMyN7XnIcb0Li38SLzpDQovfHmmRprT4tdM4EfzwQcfvxA8EPJxycfwILP7bbZ5BtMVxFiCOfEYTkEURURHUFdGgN4SQIMdAhxd4aThMJTKjbJYShoB72QbL/c/ZGBPTlIZGx//aUFURo9kXVOZFlVPBBsCZCKj2SqrWgL4ZyesiH1WSImkgQefjhP5RC12BJEfhQ4cIiplSarUxJRwqB02VkIS0UW7WmTTiG3E7dBGZuec2CNhFaeOc8+jPoQ48cqL60kKqUyVl54c5+T1zKmzRQntyWE1GpHNSGeihAq0qCJDYIOkCg04ybMnhlU15K87fHCS/F2ee+Ct5TdZ0wQNpIfQyTmki4jEi5QTmIENK5k9oBJ23ziz5N7eJ8+eGR7vpxzaf+zRdS8kzCpMDa4p+YuneLavUAro7kF6l3mMMuQ9zqhQRuVbXEQBkjsLnCQpEXTRS3wmRb9pdj+cssSg1fMu0zYVDHzw4hdnTl8wEzLsfQOP3zCjyCDx6aU+cpo4oEI5GU5iB6+HxbMq82c3vv70h/+QTYKf4EoeGfEPDZ49fWLwwO6fnrj9tQVTdAkzS7Oi2lVCNJ3n2vk4J3qETPilQeYqmg375Vl+VW9WdNM1f8p/76Vt4z3OdQQI4eLXSb1wnQeAkDSCkgQsGi1IvTmxPQtDS3dcbGP6EcZbszFNWJce2Q6AqhLh7awlu0yaCV3kuoJ7wbEsqGKRwDgJQOhZ/UBmXGVeXCtcafi8A11A3Roip6QW9yyZtaq34f5jh35pM06fOPP8xncTI1eoRV3Fs3tNcu85Iw0xLUB1AqrlxVmWBVdW53iP/TSRaU9gbH1CcxKcYrHdQNxxsMCbZPWp7QSmKxUerdyhjDSny8omMHPOBx98/ELwQMjHJR8jZ5kD29mmqUCDbDcqiwaSfgiEfupQ3wEoGIKu9N0CllSNAhCirkwX9aaH9wj8bUFs05SRp2vZ0/+6uYIPPi4wMEP47ZHsayvToxqoAaBagsb0Ws5Tm4htALYhsMGrlZAhcQukjVJEZx9mZjogPaGTmw2L6FzNxc2/iUKMRhQwQ6M5QIkDzd9ktEuQzKuowocs0EYoo6lCt0bqzhP2JIdWpimWnzcQqoU2g9SD7Eq3irgvkNQQam/iJE9mXxayulF186QB4YuPvVe21JEmqIfZuWYUCAGSuQwhKZKUeYpm92uF3TdMNd7t2QK0M95P8fuZ44dOvrrlg7lTdQkzSvKiW0tm95Uo+gzELs8odRllLoPYCcukaheoz63nTgFXFBeYczsJS7iMco9J3ld69c0qiRWOWHrc6rUND1zgDBjo7t51jy+YYdKLvTqxh2vwQyB04dUl4VoKYQtTwuszJLXA0oMnhwDbhodGRs6OjAz7Tx4d/On7o1/8/dsHe/9Wle7KFJcnhZamh5gx+Sl2a/GyxNwgla7VkOcUFL+x/SzeWxLvK7rSdd1lunb9rft3/zTejTervUkh1XCFEyB0E05wj3ZC4jVP/E4AV24ILt25fe+FHKtfDQBCX91DaXG1GaSHUE2KM9XcLpNqYZHTKMHOvcSQ6gRB4UXtIYSDA6fJOLctLbxaI7ZiPzAtBRdj6bJe6smNak8RVNzjfvKXq6HhAjt55HSmqCwnqskodcJFy9lpSuAkOvG7BXOwgJf25NAG/dzOFx5+ZwL3Ai6wwkVtKfA1IraeA0IqBCUhNo/IhB6d3JkWXZ8qXcUDIR98TE7wQMjHJR/+Yfanr9n6qWznTLaHONEjB4Yg7HWG+i0kE0jVR9F/QsB0hNHkIaFBAUuYEDVmWmcwDVeMvNTNnJ6kMjY+/tPCT4HwmkplZD2qI0hdKhGZO0owK6hVYOEoQUTyKrWpCBzqJHaOEMRUD9OJivY47SazYUwx/V/23jM8iivrGv137/3eb4IDUaG71UqdWyIaY7IQyjl2DpIIEkE559C5Wy3A9jhjPONsDPY4J4wNxgRjDAgcCLYxDmBABCGpwz37nGrZM+PxixLJZz311FOSmq46VaeKvWrvvZaVyZCQyi4Rwxt9aUOoCEW0kyheqhD3E0Pu0ccJcXqQiJ3AN9hywg3xgSVJw8gQXu7XLWjAGUKTVtwJBg9ChpdilVF4za8UW3URTrTT6MDCFu1DZ3+6RoTwnRd2rYw1J7DKNdB9hG3xIJNjhh4//CN4rCH2JXUq+QZECB+zbxpGhtCL8xsXzl7a9e7BZYtaFk3UxU5ereR3LJ/StTTSqZU4dBE2PVqkDvB+hHjdRmrhsBarhckWIroIfB73SonhuquENq20E121FG55Gn+1aeVDroER+VJsXLdlzni9mu/QwBTCpcuDEp34zOBZZ84MaU5iVyqmN+gXNmsXNOgWNirn12oW1OnmN+XNa9bMasyRVKeHVmUE1+Xy2pTgm2JR8pjvkfN9Rbm4KJokqzUiy9IpXXqpLTZgZZJg5bHukwN9QzvJKPovz7XH+pfImJQXmeeDTaE+axOxPYffvpC1/Br0EK6tfSZNUJnObdKKu2R8sJDB7NfM6PTwzTqxA53MaL81UUFjaztx5XLf9n/uS+OvzAprUGHjE6wEAyqdckQIpdB7WZLk2P7q/qsZV3V2Z1JIuYzXrkNzFRNCrEyDWL2VlP6iB0hWWGtaeE2tumsUR4F2rYtqiGeXKkRGbUSnQmiTCS1y6HHFpRMSsLWEoneJNZlbnSAsGrY1KwUFxZBACSHFDQ+P23v2G2/lOG/TeE87ZoCkMxCEZMCMHrab4UcvozLKJowRU0G09vdif0Jv/Xhv9XjX7g3evn+366WgGBVgQnguc2ZJUnAVkVD3FXli+zIQ0zNBxyC4UJixRSFU32H2Au/IGQoBRMsGRaF8RBGJNgzDBqF5CVwESGuiBYt8Yr8HAeRP1GKSqcOcUIT9D8QWLDGKhUZJFxkihGEdCYGlCeIhq4z29fYjthDPKkdBORAYH00Fo3DciQQloxKbPrIL7SvKf0Wj4oGzP12je+29TbtXLDHG+JfqJM5BZzNCIYCx4HJZ3MXnQKdo3kTt484Xh20GiCLUvisD+3d8/vKGrSsTjNH+y+L8VuaGNusiOqGIFLFBsV3DOD1YSZmuQogzdXBxcZqOD9WkSlJKilmiRmTTiEG4NZNXny4qsRQ/MhJ1x43rNs+dmKcVdiJCCFcfXxql2PIrTRRS7WnMCm3JDGvM5DWkh9Wlh9Smh9QhspEWXJceVJcV3CALa1XwOhBP0GARGph4AgtJBuLXHCQ9aIDpjWub8yOceqk1lVsRF77ig1f3DucMe7zlMntcQCm6L1SgYmpT+l6FDGoFYUKIpnHbwsClXxwcc0K4rvaZVF5lKqcREUJyGkEPk0+quKF4WwNOgOYl/tiHcCxLRk9/f27FkvYE1kq5oEMtgeSzWkxml0UpsUMN8KSiR41bTn937mq+7cOX9+XMqM4IadRKfBY1QmJVj98a4BZopdiWEd6onl/7/Ykzo5Wpc7s82sX18ewyxAARIYSyBdCSgesLTYxSsKeHBl1MCJNElBBSUFwjUEJIccMDEcKeU97K8d7Gcd52oILu5gBXCyxABduB/mFCyCKcENNCps8QtxpiH8LWQG/tnd7qSa4v3vL2917vIVHcmkCE8IdjZzNnQg8hBI5i0mKHczIC0jdoVIgNSgnihCiShn5CHAPZNFLQktFIO7GijFMT4UTbGnCIBoEZHWyjD+AN9MkI8J3XRODfRNhBxJLJ/kHaB7fMGbHyJ+6d87kRDvqz54YZkjnl0EPYM7Tg1dXv0i6ojw8sQ5wKTBewogYmAyYcm+JspMSmA0JoiQooLE12nPnh/Bid6n/Dm09/VLCgLda/BMzicCsjY4EAa8ZoQSO16SMQITTOm6TbuG7Lf9p2DwkoTr3Uc+Wjtz59sP254mRLPGt1bMCa9OBaXMtn1YhtGlzoSBRfFUDyiS4lEXdhyoChNg+qfK0qRKqFVhAvjbBnhFUnha14au1r504Ph06jA3t83YtzJ+p1IicihFCqKma6KAepIKn21OCSZoXYBK4DEiwOJLaCeqrAqkI8R2gFHgjVsFYVz6Lk48JCPuOuofAZMMp4BkQL1WIbopfZoQ2JrDWKu2o2PfaWa2A4pxcdfFmuDV1HOQ8RQgcQQhHz4oOoUMpw+yLYToS1R7GWXQtCWPN0Cq8iLahJJ+kiL1nQWs5kXK1yPrrWnUrcQ7iEOxwrl6sEmq5HD357z+3qtKBqnBsEASdSag5vZCI6U7jVyaFr3nxmx1VO7As/X8qPbUngVCoEWHyY3CmkY1loJsPUwXsfQ5a4/JGOTcMosf5NoImhXVQXzypFD0CsJoobCGEqQuMiEbZR417cFG5Vsoj2EFJQXCNQQkhxw8Pj8V740Vs+wdtwByaEATgBiI0HoWSUjf0nAom+KK4axYqjQAtJIjGAmBN6a+/w1vh5Tn3qcY2OlB8Fxb+BlIwiQpjIrcL5QNIVg6kg5FKMcqFRjgihGBoIc/ltWeHNOcKW1ND6zLDGjNCm9FC0bswMbcoMa0oPa0RLWkh9WkgD+hMsYfCB9JAG9Ju0ULLUpYbWoiUtpA59Ev3bHF6bTGCAgkDGCgL3KGIGgtMsiJPYZOHGFG4lzhAOTSvC7XbnRzUlBOIeQuLC5yMGoEIhxhYUYps2olMlsSwOLFoeZTh96qqSFSPHS49uVc9qjGeVIyJNkqJEWobZwDlDjcSqkyDe0jHfT/+P+14ercTDuZ8ubH9tf1fNP0oyLDGsoljWmhRuHfRHSaBFUA3u7UQoCOso4suh9mULIRYXmLH2DBTsIQ6JTQ6tKcGlOVMqP377YO/Q84RoXI+v2zxnAhBCNd8GOR8xyQf6iByemUAIIYltwSr/NlBGwRtqkV0FMjl2jQi3C/IxCeSZFTxgCypss8HYxINmjxn7LlhzeW0JrLI4TtHSxc3P/O314bFBr48QxvghQohVRn2EkGTFZTgp5/Mh7FiECOHYl4yuq346TVCZymUIIUmdDRJCtCAKjfg8IoSxwct7xqxk9PyZi69s/OCe2/Jk4W0gLiom9zV53WDRRHQuGF9QK+s6+PGXVzs0j6dj5UOp/KrM0FaN2EHK2hVCQgiZXj5dRKdeas8Kq1HMLD//8+g4o6C5oQNRmRIghGI7nEzmUYnlW/E2lvA1JyNCSEVlKCiuFSghpLjhgQKcS2e8FWArDyqjbT6O18om3oNozQjJtOBeQegnJP4TAd62QCI84wZCeJu3LsBz5qjHNTpvOiko/g2+HsI1iBDKxUQ+FPfy4YgcCszQBmKDIoNM0JEV3pQSUrVikVU9u1UxvT53am3utFrZtDrZ1FrF9DrZ9LrcGTXZ06pyptXkzqiTzajPnV4vn1Enn1mnuKtefle9DG3PqpfPrpPfXaec3aS5p1U+BXHIumxemxIXXylI2aRosIHQjF0ibLnhxiRuZfzQCSFCUZwhgVUuCzdA7aXPi5wJTLEZHQpPdVIHYhqIF2nuab5mhPDZe9+UT6lPDqqFnIPIx1h87otKRlTGopXYcnnNi1h5Tz3wz9E9gMsXrxz8+Fjb8oeKkoxpoorEoIqMkHo5vwOnZ61EQREHu8QiEgpHsSgI1hASMr6RUNcKUqVOjdiy2K/QvHrDse6TQz0SFEBvWLflngl5WqFTxbMqmIJhbPwtwL2s6EgkkBtUMWWHNqhV/sVcHs4VLnk1DyoGEbMKpgIWlwoz/ZDow3xTRnDjEr9VOdMrG3Tr335+p9s1/AgePezLcq0x/qUKPqLTnaRklCS65bjTTI5T7oi+IkK4IKBg7Amhd33Ns2mCKkQINYOEkGGDJkJjEIVW8C1L/IpjQpaPXQ/h0UPflmc44v0rIB8rwio7+P0CdoxAnMp8118Umx97D/HGq//Od5/fpV/YlsStxeIuv3QaQ1MiLOAHqIc2v9bFLN2BnV+OSpIQTQ9dVL0vQ4gloPBYmGZXHyFE65Tg6hTJSkoIKSiuDSghpLgZcPlnb7W/t+4OLwiNBrpb/IkDIeM73xrIMEDfAqIyzSwvKRkFWsgC38Kav3gbWJ6e77yeEQk2UFD8N7iJ7cT04qTgasVgySj09ZlAwU8A5XlY7sUkFxrSQuozJTVb/rbjpUe2P73uzX90vvZk1+uwOF97et0bz9z7Fvol2cDbb6Afn733rRceeHfLo++jZdOD77306PuvPPHhlse2bn54K/pxXc1zWdLaTF6TOsKmiXCoJBBaMYqjoNSPo3lECPnGhKCKBPGQVUYRytIdiZwKFIsjQkh82ElKwWdICGVsWmmnWmKLCSxOkVR8/821MKb3eDxPOF7JkdRmhjRCzkFCeixx3ybJaOEWSnQq9JGOzNC6uNAVmza8NUYH8+0XP62tfSo/qiVdVJ7ILU0LqZPxDZjGYHYqsjAto5iAkcQXyMww8jzAEtEJzIvozOG3RAeueO3p7VcuDy0Kh5LRtZsRIdSIujAhJA1aJoXQCFXKTNUoVvnHEv+EUaDjwclkULiBikSRTc0Yr+PWMpwGJA4WPl8TEJXJDm9OCCiLD10ln1W16aF3z/440pZREJWR2eICyuBUiB1EfPIXQigcJIS2HF77/ID8sSaEiL2srXo6XVidFtKsjVgr9w2fEbnB5FAtcsh5ZkQIo0PHqmS0v29g+xufLvQrSOfUY3UffI2w8ir07kosSUE18yfm7/2ge0hfe/F8b8PS++K55dhKFDcnM68AGKsPldiul3ZqxMYY9jJHyRM/nhwFgW4oGV3YEMcux8b0DjlpRRYxbYTksakmPYTB1cnSVSN5v0BBQXH1oISQ4mbA5XPehiBv7Z2etgB3W6C72d+FlhZ/0iWI1WUG2SBpI/SHPGEbZoPgYo9+7+et/pO3MQiSjZ4R9Q5RUPw3eDze09+eB5XR4Gos6AIhrIII6IkxLcR+gOhPuXxDAqsie1r1xXNX3MOtr/uXXbs9P3/fI5tZmcKtVkssmgg7rgbEXhQiJlEGiSAxiqQ7YgOLY4UFQzWmR6hV3ZccXJUd3k5KRgmlQYRBLYFBEQEV6G+U2JM4FTHcwm+++uEaaEKgsT9ieDGdV5kT1qwR20nUjhnLL/1yJPOQP9WZFFSuml331gujqaRP8Gv/7ss9V95+endpcmc0p3DR5KLkoFoZrwNqLLFlglL0K0IoYJrxsF0hY1ahEZvzIq1xrBJ78ZNf7h+ys8IT67fMm5Svj1gHLhFiIjI0eEKwgyVpGBMxNhi4m9EKGWweUGgid4Rlimxqoo7DN+WEtWeHtuaEt2aENiQHVSVyyuPZa6IC8mOClm955IORU8FBVMjs8WA7YQZCKLYpsJkKQ8AEJPGL5ptdJkCEMO8aEEJnxVOpwqq00BZtRJfKJ1ak4IE9gwK/ZNGIHLJwc/Tk4ihuwYWzY0IIf/j6zOPmf84bvxQsLiGva9NAMhneccAjRWxaMG5ZwQLDF5/CVBm84zy/hV9/LfrxUfNm5fRmGb8DZKJ8nbe/8pm04jJmc1pYRTR76ZejcbYH+l3qRfXxrHKFwITuVuUgIQQ2iMitlRjTI1qYFFyVKllFRWUoKK4NKCGkuBnQe95t4HuqbkO8zt3BxlYT/m5gfQHeNo67jU0sKLDfIO4ebAOreiI6CnIyaGnxB1GZ5hDvuePgY0FBMQbAxvTnMu+qTAiqwB70mBDiWFaOI3IVlN4ZcdbOkhJckxFZ3HPmsntUaqI83vOnL8pmlWbxGjQSFNvZMSO1Kn3lgrjTDxy9c3nGeFZpvGj5MLIZzboHUoMrZGHteoldLUDDAR82NSIzImzYTYzpxYgQOtNDG6f/NevIvhPDFvO8eqBdGEofWDi5ADEfKEIDAU+GZREFFBWmYWq+bVlk18KJhS15D3bvPjamhwSWcX0DF85dPrjzaLvu4dl/yY2ZUJQTWq+WdugirDqJAyvKmhlCKGC8zlWYTqMhaCMd+VPWZYQ2ZgiqXnnig6HufeO6zXPG67QihyrcgvNIvjnAeFRC5A2EMNyaFdyayq1LCarP5LbIwjtyw9tlAkNmWGsqpzkzuCUzpDmVU5/oXxk7qXT+bctn/Fk7409pFYq7AAAgAElEQVSaWXfoogKX5c9v3mj+58mjP104d6m/zzVaQTvYIaicCawyBc+oFNtkkEqF9KAK+2TAfENnCa6yI5tniA5a+uU1EJWpejJdWJUe3KyDElbiEMMUY5MMqkZkk/ONsQEl0dy8MSoZ3bpld6aoLNa/GJF85jWHyIxlnKzQJyww5IS2PNHx9g8nzl651H/5Qh9ao6UXb1zquXLp/JWL53rR0nuxr693gCz9VwYu9/Tt+OdnTfJHssNb5ESXWEQIIRh4gnIsEEI72lFWWNNdt6n2f/SFa2RSTF6cIVTOr4kJLJHzDNjOdFDriHFPhZy5xIqen/GsiiRB0bD7USkoKIYESggpbgb0nvd08LyVt7ubJrvaWFhOJgAIYVuAB8pBWcR8wk3YIDQWst3EmRCYISGKAd6GCd6WMO+ln2jJKMUYgRDC3LurEzgVWETUSqoW5XwTGMcLMCGE/AaoqyeHVCeJCkeLEIL00tnL2XcVI0Kok3biAlEmg4HzP5gMwI/23HBjjP+aJWH5w8gQ/t36am5EbVZok05MvMuINzfYlBMNGwjWofzMkSswSP4nbfsrn6HwdOSj+32ggdcVrF0waXneFCdWsTcpfRoqSp+SPiRI+bZ86do5d+get7x0ldL8IwQYVPT2f3/i9P4dn7eoH0gOLYkJWJ0WXKvgG7Qozsa2E5hjkBpOKNfUYVFZrcSeF7lWE2FZ4rf6MfPLKKYf0n4fX7t59p1ajdCuDMVkWETqUU2MUyVRGwJdU1N6aH3e3eZl8205Ec2JoVVx7JL5k5YvmlQUPakoavLyxf7L4jhF6YJy9V1NJQn2B5pe3LplL2IFRz49/s2X35/9sWfUg3V0B1UpHAkBpfIwA9HwJOkjQhUYng9EyJ4bZoxiF4xKzur3j+fe2qczhNXp3Gad2Enyk+AoIyQF4dACqgZfeENsYOni4IKxIIRoCr3w0FtRE5bKee06UeegRYRSYFQKyFQ3Zoa35N9tXRptVi9oyp1dnT27EpZZaCnPmlWBNjJnlmXMLEufgdalmTNLs++ukN1Tq5hTnzu9NkfUlMvvUDJl7UYFUy8KPc9odCA2K7DpRbZ7bs9bV/PMt0d/HOFw0JzRLKqLZ5fI+Aa12D6Y/iV6xaTKXSOxKcQmqGznF3ppgpCC4pqAEkKKmwG9573t4d6aOzzNfp4ONqJ5WCcmgCxepm+QxfgQYpkZN2aGHpI8bGNj24lx3tZwb/9FL/0fhmJsgKjd6W/Oye6uSeRU4EYjG5ThYXVEkKDAWQ4Uw6FwB2yXg6sShSt6fh41QnjpXG/WLEQIG3WSTjWxRPdpTqhIgSIoiNhR1BUXWBITNpyS0X1bP89b2JoWXAeEkD/IuCyEgBGLBbUY7P4QM4z8U9aGjtdOnxxz54ljB78rz7UvCVhdMLVLRbrOiIiOgPFgVOFyVo3Irhc57r5N/fLGrUNtzBshUBD85f5v3nlhV0VmZzx7VRKnEk0PjZhYR+KME+MqacX51U44hxHOvKldiyavNqx8/MTh74e0uw1rN8+6U6sV2RXhFlANJT7jQstg8K3ALoLpwfUrl9g3P7xt//avPn6ne9sr+9/dtPvVp3a88sT2t57d+fYLO9/bvGvbK3s/enP/J9sOd+86eur46csXrrgGXGOn84G+uVLeGRdQKuMZiEMd4/8uHKxuxcI8EoeMZ4zmLv/y4JDraYeKexuezhBVZzCE0KJgeKlV4ZtpGnSv8Y3xgWVLQpaNBSE8vPd429IHoyas0IudynCs5YMpPVMLDTPcmMNryw1vT+LWxLLK41hlceyyeKjpRUtZAqc8AW1wyuPQbzgVcezyWFZpXGBZXGA5WiewytODG3N5RgXfpAZOCG8o8P0CX64WWrQicB/JkzjiAyqyptTs2npohMNBl1i7sC6BUwa3gMRB9ijHGXKSHkTUVA2aWKYEdkU8IoQUFBTXBJQQUtwMQITQwPdW3+4rGSWsz+dK30pygLhAtI3FWBHiz+B1oLedAzIzNXd42/leV5+X9iRQjA0wITwvm12dGFQB+qLQl2WRCc1YDAO0ZJgwCzvUIUKYJCrqOXNpVMJrHyEszeI1aSWdKiFIRzK29USQUEwMvuwKgTGBU7okfDgZwp+/71mdakrmVoHwPc+q4JmJ1CTxPFSRJKTYqpHYEemdMy6/JMH51YEh62QOFa8/uT1vfgsi4fpIB1a/JBVoJmJehzMq0A6nF3fKQtvmTtC/s+Xj0SnTHSL6egd2v3vQvmajalozItVgFyk2DxoSKnBpKwqRcRMmrPOmrosJKF+TZN/+yv4h7QgRwrvH6RAhlIdZQMtUQDR1rAwh9KV2kwKrarLWf/YRY1TgdrkH+lx9l/t7L/b3XxkY6HchHosm5zV9Xnq8lQpnPKsMjOmFPolRyAraFGKcLYRyTStkCMM7ohAhPDS2GUKEe+ufThfVpCFCKHFCBybx9hTh9CA+HjhOvikhoCyaOyYZwpc3vKuYVp3CrsoTr1WEm1QCpmSUMRcFWmhEN7VKYM0Ka80Mbc7mtebw22SC9lx+Ry7fkMtrl4HaLZiFasQ2tcTG5DaFRDQIrERlfCN8gJQWi8xqCVFIJhXgVq0YOKGc1zFn/NKXn/ig9+KIcv6YENaCMT0YnzjIhIT0oMDMKGDBAUCdcyKnMkFACSEFxTUCJYQUNwE8vec9Jom36nZPs5+7HZeMtiI2GMCwQdwoiLd9VoSIFrYxXBE8Kto4OEN4m9coovWiFGMHFDqf+fZ87uzKxKBK0rpGMoRyHPGgcEfNEEJo8EsIKk8SrxxFQnjx7OXMmcWZvEad1KkW2kGbXsT4xePuIEYIVM43JnJKY/gFw+ghRAyhQX9vcnClgm/WCB2IEJIEDhG3YCr6oFHNppXYE9lVySGln7x/eIQW8P8rrGWPpPLKssIQE7ZBhlCAU7IkhSLA4h8Ci0bkKJCui/Vfo5vfvG/7kTE9nt8Bukwnuk890PhiprAmO7wZvCj4Juz2Dk2YKGTXYkkexLcRo9ZHOtO5Dcrpjc/dPwRNVLSLx7pe/BUhtDI5UvGgMSMpOLQkB1aVpXTu+/C6nY3fRJXSGQ9el4if2JUCnxmGhKhQDjabWXN5hsXBK64BIVxf+1SaoDqV26wFQmgmPY0+fw7waYQcrMAcH1C6OGj0CeGFs5fX1f1jiV+hPNyoFznlPET8TIz5J3AnUuRpVGDJKKysa8K1CUZG1tiXEAb1WrFDI7ZrpHboU4VtBwgCix1glelTjlX5OKGKKdNFnA08KtFs0Usdi/2Km/MeOvjx0ZGMCD3uNAtq41mlSpwhZFRkseKREogojAtLnpoS2RVJwiIqKkNBcW1ACSHFzYArPW7bDG/1nZ4Wf1wyil3p2wLBZpApDQ3ESjOkdpSRkwFfilbiQ8iGjbrbvUbJ9R4Jxa0MFLucPXUBEcIEdgXx18LxGcMJfb1bJg2OwOLZZVAyeubyaBHCC0AI1yBCqI9YqxY5SAEnZgKM24GKIYSmJHZ5rGCYEvkPt72YI63LDG3WiR1KXCaKfR1I+RyJ1xH9QEGkQ8brWDRx6XP3vX3m+zGsGu29cGVVZnssaw0kSbCHHjoSGT7hg+154I4o6VwasXb27aqHO178/uvTY3c8V4PuPceadQ+heFctscn4RmidwuE4JoR28AYU2TAh7MzltaXxqh42vnj1X45mwqPOF++6Q4MIgCIcvkrxi7AQ3hGeiuhEpbFqVsVYdr97cOxGOgxUKZzxAZgQioEQku5KrJfLiMeSNw4ynik6ZMwzhOiOXl/zVLqgCjKEEV2YvZCyWyIPC2vEshDBTggsW8Jd2nN2yFn338enH35enumI9StW8R1qgV3BI1MFU3oRERAGEihn5FhIsTRTL63C1pE+MwlfZliEH0d80IxREF9HyJ9b5czbnF+EeZX4PQJig6TTDxHCrLDmFF7Z5g3vjYSjuQkh/CVDSDg2rheVMM2i0GUtRo+pihTRSkoIKSiuDSghpLgJ4OntGXDO9dTcCQ6EmBAC32tjY80YSA8iNuhiNEVxM2EL+hMH2GM7Io3wSfQPwcbQPOV6D4XiVgaKXX4+1ZMDGcIqTAht2N8ZDA/kOFAj793hlTyKINnl8fzlo0gIL567nD2rJJPfpItYqxI5ICUoIcWiOH2H6zlJD2ECuyyWN5ySUYQ973SvTDInsCq0IhuKODF7wXthTPYGd2TTiu1R45cVJ9r2bRvDHNQnW48o59YkBlVqpQ45UWeBKjgmrsXFdaDUr5U4NELzjL/m7v3g8DUQPv199F7se+/FPUv8V0EgLjLJhMZBjVY1lPWSKBwyhLnhbUncsr+1Pn/1X44C7kccm2bdqdVJOxVhpH2UKLJYmOCblKcK7ens2hULjR+/fWDsRjpUYFEZnCHkm1SIh/yLTK6F0VMB43KHLMwYxc2/BoTw3pqnMoXV6cHNWqkTF4tamO5cX08mYjVqoTWRVbEkeOm5M6Nmv0H2vtH+UqagIjO4USPqxL2mZqZ7kMmqQV00eeWkIulTAXa5hDy5RcVUI9sUfFirREz/IbGmJAaAMtBxsaqkNqWvRpS8tCLMEJd/Q5WpWmTRQtrfsmji8gfan79w9vKwB4Xmp3pBbRy7DN2kYC9Bjgdkiq049YqJKIjKmJODKpOFRaN4PikoKH4HlBBS3Ay4cmHg3mhvzZ2e5slehhAGukmNKBgPBjJWhKSHEPoG2d4WKBP1tLHIGnwI6273Wmdc75FQ3MogJaPZd1cmcqpwlIPfu4ttOIHGiP6Tl+4oGIoNLIsfTVEZz6Vzl3Nnl2bxm/WRXdh5AqigSjJohm7xpVaghzBOsGx4GcKL53s7Vj0UE7Aay6JASSokPJnsDWlqgt4ktQgEM5MCKmNZRf98YtsYcTB0wuvV9yYFl+aEtaDd4c4urEvBSNibfETCphBY04LrE3mrjnZ/OxZHMiSgK77n/e4Y1kql0IgukAIIIWTAEBvURNi1aJE6NBFQ0Zcd2poeXvWocfMQvh2XjM4ar9VGdMrC8OUQMd1Zg7QTC97akgIrly003GiEsFLpTGBVIDKjFttJblBBfBRFjFsdJjB2WbhhcfCya1Ayuq76qQxRTXpoq1raBT4uWD+JtBGSdJxaaFfyLYnsiujQgvM/j2aG8FJPr3H1Q7F+q5R8kx7d0YJfsn+/CLEIjHKcZJbzO3B+HtggInuQAGRS92jy25S4IRNTRxP4TIpMuJrdlMvvkAmMCnhQ4KcT+pjAgGtQTdgNxcz0HotA+TN/qjM5qLpadt+ud7uHPSh0iZULamOB8+NqWyx8hSWRGY9WBX6Dg44tERFC8epRPJ8UFBS/A0oIKW4CeBAhfDDFUzPO2zLZ044Ioc95oiXAhdfYcwKURbH6KMvTjDghx9vmjz4M6cF2jqdlsrd+nLdr3vUeCsWtDGJMnzm7Mim4Cte2WUFOBq2J5zKK+PGbeC28F7fGssvADPBs72gRwsvnr5AMoXZKlzrCocb1V0TBUiVkEgIo8JLxOuICi2N5w1EZJXio/UVEKTO4DXqpHQWRWomdZD5xJyEeKUR4NkRIssNb5tyhtazacPTAdyMf43/iyuX+zBklKcFVOFFpB3M/3GnGtFehmJgPw0fsNCesfUnAqr81bBrT+tWrx8HdR3OkddkhjVqpXQ76+xaSwNGg4BvM5awKNCKpIz24USapf7Lztav/ZjQTNnRtmj1Oo5U45Tyg68AKxKCGIschPqS2QPPWlsqtWbaoY+eNRAjdLneF3JkQWKHiWzUSpxqRfDHDA8HsgTTlwrYtJ7x1ccjSa5Ah7Kp6Ml1UiwlhJyGEhFTL8RsfhRi3BPOt6JijuPrRJYSHPj5WleNMZJdr0F0mtoJ7jdA0qC8KJFlgVIYb5OEGWbgJPCTDjXKeGbFTJVrzTLIwQ26YQRFuzA03gLoM35jDM2bz2rPCW7PCWrPC23L4hixeW2ZYS2ZoU2Zocy6/XSnG71AEhA2CKjJ6jKjFZq3EqpVYCqY6VZKOGM6azronR3JKlQuqY1klcnBkteNyVpy4liDmb/HZTsAjJSmoMiWSEkIKimsESggpbgb0XRx4JA0IYZu/1xgEgjEt4EqP1t6WQJfPfwI4YTM2nGjDtLCN5WkH5wmvIcjbPNlbO8n7WM71HgnFrQxiO5E+Y00SF1MUiU0F2TMskIhZCv6lRR/RicKdOHZJkmTluR8vjormCgqzei/2qe6pyAitV4scaqFNTUwX+ChAxFqgAqZmFURlgqoSRauGLYDx1WffVivXLpq8Mk/apRU61XxSh4ZrzPDLfpyAgkAZRe2xfiVp4WXP3f/myMf4b7h88UpZhj2RuyaH14zOKjrDkPoQMvIYSqxbqBRY1WAWZ0oPqY8KXv7t0R9G7qw9crgG3LvfPRTHLsoIa8qfshb8JyRAeMjZU4sIJzTpIxxJrOpl802v/+OjIX3/xnWb547X64Wdap5VLfb1g/lSuCom0WRJZteoZzV++NonYzTM4cDjrVWvTeRUQikjovdChy+/bYabyKcrg4hEdnj73IC8I/uPj2mLGbqt1tY8lSaoTA9u0kg7IbFG5E9I/SoWmFFBatqSwClZHKQZ9kuW34Rh5SPJwWW5YW06SSduAgQ7U32kUysBJRh0cyUGlEVPKpp359LZ45fOv3PZ4slFsQFr4gNL4gKK0TqBVRrvXxzjtzI2YHVM4KolAauW+MMSw1odyy5GB5wQVBIfVBITWJjAWpkT1og4oYJv1OACUY0Ev5XAmXY1Lm2AVKHIkhfpjGWtqdevO3X0zPAG5R5wy+fWxrPKFAIjJn6gf0sEipVC7KzIN4IcF9hOlMYLl4/i+aSgoPgdUEJIcRPA03exf6PCUz0B6j+NXNCPAUt6IITulkBsQ8/oi3pwYyFigy74faC3PcjbzvEYON7mSd7GAO9zK673UChuZXgQITxxNn366pTgaojpxVYSzvpsJ0BOXS226CLApg8RwgRR0fmfRkdl1IvTZaq5lZlhDYw8I9AAfAAC4gxhJaIyMhCVqUgSr7x4fpiNQH29/Q90PB8duDIzuKVAsl4ejnaB25OwTzfxQMeZKKuMb0Bha5z/mhbtg4d3nxiVYRJc7rnyweZ9ycHFadwahdBATrUCq2X42ghNwB+EVo3QLuN1JIWUN+sfRBxyFI9h2Bjod+1860BMQFFmeJs+sksttamlVrTGzhBmLAhp14qsaJ7E+ZfUK+7/9IMvhvT9f1+/Zf5EfZ64S8u3/0o30qzy6YUoYHpYEwOq1HchQrhvjIY5DHiAEDqTOBVyHthOkONkXjeImI5Q/F4DE0K//CP7T4yp6Ijb5Vlf9ywihCncBrXUQbKsjPEmlkJRgCILqCsh9rWQrR1FldEfTvxcnGJLZFUAPYOaArAPUfDMaqFdj6ipwJAWXF2VuW7by/s+fvvgzncOfPTGZ7veObT3/cN73z+Clk+2Hdn3wed7th7e81737ncP7X63e9e7h9CP8IFthz/Bf8LbR3a9c/Djtw68/fSumoz7Y/3XaHC7oBrsW6wkW4jfIOCuRb5JJ+1KC66XT6vbaP3n8MblGnAp5tcmsMoQ8UPznDwngRCivYC6EuwFu4maEzkViQL6XzYFxTUCJYQUNwP6Lg08u9xTMwn6Aw1cyA22Iiro5yWEsBk3DYKUKGkjZHtaECfEHYZtHKCIHWxP4wRvE9vzWu31HgnFrQy323Pmm3Pp09ckB1dioTwbUaHANW8mUlSJCKGeIYSlCaKVo9VDiNB3ZUA5tzIrvAGrAmJLeiFDA5hGHZ/KaDKnKllcNGxCiLD3/e6KXOfCCYV5kk5FiFklACpI9ojiObCjgMwkyN+rReas4EZlZNNDLS+ORIvi10CE6sjeEwVR7fGBJbm8NnRusacCEFHsaYYlRuGcg4gOiqfTuTVZkeUHPz7qGhhyehDR9SuX+1AUOypHTtDz86VXN26P8V8tE5h1UqcKdDtIVhCou5pI8oCujCV6UtH6umd++vbskL5/4/rN84AQdmqhc8ysHBSfJPXDIkZrJCmgSjWj/sNXb6AMIWJ3VYrOBEgfmaAAGI4f2/2JmCEwWWixPYfXMS8g//PPRvMtw28dkPe++ucyRJWpwQ0aaaeCMXsAYR45lnIBURmxA82xRFZZFFs3ioTwmXVvKqc1ZXAbcUk2+KkQRV+d2LE0cm1maINiasMG08t9vQNulxstaG6jBT1MyEIA2/BXz6/+iv9Gfo8/ieY2uqHOn7745lMfzfyLTM5v1+LqZSLRpCTapFiiFuwrxHaZ0JAQVFqrcQ6vtAHtWrWgNoFdhu5WrdShJnapIrIjk4roo+J7OYlTmSSiPoQUFNcIlBBS3ATw9F92vdboqfEDyVADF0wIWzAhbPX3QKUoIypDegixJyGLaMwgogiEsJ3tbRjvbQ72bLNf76FQ3MoAldFvz6fPLEaEEIs02BSMhp5FjkkLLCKLDuy/oGQ0QbJqtHwIEQb6BpTzKjN5TZCyYMoOMRscTBUSVwaBOYVbnSQuHJ6oDMGFc5efvvf1KP9l6UH1On6nWmAjaQTGTwzc/3C1qhBFeCa1wJQWVFMwr33zw+/1XxkY8TBd3XuOt654eP6E5ekhDQoioYnty7DYhpkJZNHwhSAumh3elBJW0lbwwPCI9/nTF5596I2Xnth67PDJ0ZLG+WLf16bljyeyKzVSh17iBFFWkQW3EVpwKAx6KjrowGyLCVz11PrXh7pfRAjnTNTpRA6NgEiJ4PpGbEbvk7pFG7bkwCrNjZchrFY6E9kV2NQBMoSqQQt1YvZAql7F9mxe+/zAgs8PjDEh9Hrva3guQ1iZxm3AQk1wCxMvREwIIQWtJoSQXbI4aNQIIbriJRn21NBqOa9DQ97v4Hcu6LQURHQtjehKYpXXKtZ/+uHQUse/A8Tuvv7i1GJWfhq3DjKE/1oErmBcLohmrz2RU5kf1XRo1/Hh7MjtUWNjevRw0AEhZCqliX6smhE7RVfclBxUlSxZOVoDpKCg+H1QQkhxM8DV59r5sKeG7UVU0MR1E1EZxAbb/KGZsI24DrJcmBPi7UDSSehtY0NSsT3QUz/O28b37nnseo+E4lYGEMKTiBCWJHErMf3DhFBMCCHUi2JhDCCEOENYnCxdPYqEsL+3XzGvIpPfrBJ3QiQNcb8JE0LiPUACa6sc0bOwmgRR0UgIIcJnO7+oyHbOuX2pWuBQCx2YEJpIEAnRPB+7n0H7olErtsh5bancqoIFhree+/hSz5VhD/lSTy8Kgs1rNi70K0wNrlOIDIzNGjbjZmT3mRJZi0Zkl/E7Ytlr8hY3f/zmoeHt8ctPv8lb3CSfVW0uffTlJ98/sOtLdAzD+yqCM9+fQxwvSwrG9PrITkaSh5EJgfQgCv1Bo1XamciqzI2se+OZoTUQImxYt2nORC0ihGooGbUqfqFSvjZCTAhT2TW6e5p3vPHpSIYzunCD7QQaeLmcB8YYCuZFA2azeBSgiwNJVAcihPMC88ecEHq899YjQliVygFCqPDZ/cmFPjdCYKcOdLMncUoXBY1Oyajb5Tl+6HvZXbWpwTXg0g4uNTipK7DI+abl09arBaZkbtnDhhd7L/aNfHcEiIqfO93TtvTBJX6r1SKzFrKRjCatypeeRU8t7LvoyAhpzhBVrqt9ejijc3tUi+rjWGVKgVEv8RFCXCytkhBCaELPSYXYlMStSo8sHq0BUlBQ/D4oIaS4GeAecH/xtqcxFOgfIoSgHcpytwV4ED+EfCCbyMkw+cBWDs4WsglRRBwSug3rx3sNYu/+5673SChuZYAx/Xc9GTOKk4KqcKUoaMkoJURRHbstQ8Rj1YIKhSmOVZwiWX3+zKXRUhlF0SGxndBKnSqhDcWRpP7KV/EFaRYVhLCm9LDqJNHKEQavVy73b3vlk9iwVXEB1WAPIGAaCBkLbD7TSajFAok6FPAJDMnB1TnT6t5+fteJI6euXOobUvcX+vB3x398Z9OuOs19iwNWJXPqsFQmNkzD+vtyrCjD8F6BGQWaGrE1NrAkI6J8g+2lYQ/z3ef3FMxtjfEvnDteHxNaWKNY++rTHx7Y9cXJoz8hZjgkiRrXgPvU16eff/DNguiWaP9ViApqcRYXKl1xPR62CLchHqsR2dRCc9T45S26Bw/uOja0I/Z4N6zdNHuCRi9xagQOFRHGZERQYC+47Q1kYBEh1M9t2fHmjUUIK2SO+IAyBR9YnxI4IXbV4zOOC3Jy/BJHLr9jXmDeWJeMetweyBCKqlO5jRqJU8n40ZvxTCNT3aKWdqql1uSgsqgg/agQwiuX+x5u3ZIlrMkJawUZKqw6O5icXHX3/enBNXnz2t989uOR74uAFJEO9LsO7jwa5Z8vE7Tq8XsKKMYmuWUhLgLHIlVqeM+CHl9lqnnV6CEw5H2B7URdXGCpAvcQknc3Kiy7RYSRlVjaVCk2pYbUZk8tH60x+kY6ut9HQXHrgBJCipsBHpfn1H5vq8jb4u/q4LiADQYiQuhuhnpRoH8tLE8L6SEEfkg4oact0AsLJoR147yWKd7Ph6DeTkExVGBCeCF9ZnEit8rnYW1hLOCIf5rEhsI7nRRFuqY4dmkyIoSnRydDiHaNgjPZ3LJsQQshhGrSd4RJIDABEZF0t8oFxtSQygRB4ciD1++/OX1vwzMz/6rKCmvGdY82Fen4AipoUfKBIqqFVo3IqpPY8yI6NRJTMrc6jrvKsGzD3q3dZ3/qQTHo/0oLXQOuc2cunDz+g7P8iWT+6vkTClKC6jRiByhPYO8yQhIw/WZq2+SIiErsKUHVMUFFa+uevNQzfC2ZdVXP6Ke15k+z6afa00PqoiYun3WHIlWw2rbmiW0vf3Ls8Mkfvztz/syFvt5+t8v9n5cSIm2XG12a09+fO9b93brap5OFqxZOXopCbX3kWkT/1BLGex2XE8M5RAE3+n0mt35xwNJ3NlIT8joAACAASURBVO0c6BtakS3a42Ndm+4Zr8uTdGkxIZQTZX+yCIk0C9DmFE6tdk7zjUUIXZ5ymR0RQiXfohV3QtUodvzD9npmxgMQTWmJPZvfPgerjI7p8aCT+bem5zPFNYgQqkFllPhbYiN4MUkVWlVSh1pqS+JURAXlXTg70nsK7RHN9lT+6lRuNaJMeIaAWDER/FQJTavuXh/PWrW2+ulvvvhxVMb4a6Bd50wtSeZWaMRWLZjKmMDMk3RBEykdAZOET2RVJ4tWHdp1fKiyva4BNyaE0CZKVEbhFhAz3aFKEZPeVwpMGSGN2VMr+q8MoKcEWsPSN/DLRt/AQJ/v9/+6/Pr3aBv9c/Kb3kt96F+NVs82BcUtBkoIKW4GoDDh9BfuDom3CfsQQoYwEDoJQV2GRTihBy/EdsLdyvY2s7ztgTg9iPOE9RO89ru8J7Zf75FQ3MqAYO7UhbTpa5KCK7EpvF0pQfGildhOKPHLfvR7DcgVmmI4xUkRo0YIvThllzOnNIvfpI/oguwKo9CIE4N83EOICaFCYEgNrUwQLR+VbMbp78/mLWyIYRUq+B1aUadKZAclRnB9MGNrbEjiQQWaFNFgu07s0ItRKN+02G9FNKtgbdWTX+3/XxrzEJv6/viZjuUPLApQzLtdm86p1IhNKrGdROREXBTSNVgvRyWyyaF9EXzMEHmbfYfOUPTo8UOnRjJAa9ETqsgWjdSSH+nUQrdYp1pgTmaVzp2omvKn1NkTcnLvKnNUPLHn3cNnf+jpvdjncTFXk1BBRBTPnOrZtnnfssXN0QFLoyasSAd5Eoc+wgmyMSLM20EAFoRD4EexQyMBzSHEPGvl933+6ZB99tB+H1+3GRFCnbhTJ+xUSYBLMESdlDgya2tiYI367ubtr99QhNBdIXcksCoQ5cDnwY4JmAkIA+5KJQk64kM41193DXoI19U9kyGuzghp1kmdSvICAhKV0D1IDBLV6DhFtsSgyqjgUeghRLzli0+/ieWuyAithRtHbEeTGfwYQWLHkis0KAXt6PbZ9Mg7I2/H/U9cudz3SPvmxNAimaBNI7XLcdWoTxaLKZQF0Re+NTu0LTZoZVmW89KFoVVQI0KoXlCXwK6Q801qRAjFmBCCyigUx2okFjXY80DhaFJQTaKg5OCO48cPnjrw4dH9739x6KNjR3af+Hzv1+i5cfSzk2gDLQc+Onpgx1fdu47j5RhaPt9zovvj44d2Hj2y58TR/d+hf44+j7Y/2PJJ956jF3tGR9qKguIWAyWEFDcDUMh85pjHMtXbMMGDbehxsag/dqhHhJDjaSU1ohxcPgpm9J5WDlBBMKgI9Lb4eeru8Ky9x3PyBtLTo7j1QEpGU6YXJyBCCFVPNjmKoiBDaEU/qqXQQwhO7hEOhdgEVmDiop4zl0ctQ3ipX4YIIa9JF9mFuKiCSQ8SXUSLT97GJhMYUkIq4oWjkCH04gj+p5M/q2ZXJgWXyfkdGqGduAX4UlJQo6gSmjQiswZ3Q+HuOJtKbEjhVMUFFaUKVxUsaOrIe/Dpzjc+fv3g53u+PtF96vDuE9tf2f9k12sNuvXauTUZwjXZ/HqVpEMXadVEQMJELbQxdY9ibC8B5BCFlXal0CbnIf5pyQlvWDAuv1n74P4PvxqhEkyD4iF1RJtObNOLnMowmyLEpgt3IE6oCG3PDKuN55TEsFbGc1YmcFfGhxamRpTKZlUWRDeVpVnLUi3LoxvVd5eli1clh61MCS2RS5p1M+y6qU4NVtvXguGbjYh/IjYLxYFECVZqTuVWLJpY8MkHh/uHmB4k2Lh+y9xJer3UCbYT8DLC8i9ao7i+F+06PqBaMavxgxtJVMbt9pTLO+NZFZDiFjvVIshwKvCFZgwzGFEZR3Z4x9xA/VgTQrfL46x4Ml1YnRbSTFRGscQoVrJljgRNZgea8ElB5QuDNOd/vjDCPf548mfTysfiuKsUglbwo5cAIVSR0mKRBd28SdyK3Bl177/yyVj4baDzf/zw94pZtVnhDboIO9xTWJ4KkrQC5oUCOgwNGrLQHBdcGhW87OefeoZ0IOh+lM2pjg0sk/OM5EaAxxR+U4YemPCIwOpKaqFFHtaazinPFFamicpjwlZGhxTGhRUm8orQjZYYXhgftiIudEVsyPJobl5MSH48b0UCrzAhdEVc8Iq4kGVxoctjwwqjgvIWBMjRMt9fFs3WR7E0y2KbPtv5+aifNwqKWwCUEFLcDEAhc88pj2Oap/5O8B5sDXS3BHjxmuiLEhNCaCPEixexwZYgD9GVaUc/+nurbvOYprqPbr3eI6G4lYHm6YXTl9Kmr04KqtSIrbqITo3UDhVfUptSisiMRS1CdMWoi7ApESFklSSJV104O2q2E1cu9yvnVAAhnLJWE+EEqXoBY4SoYjwwrHKRNZvfnhxclixdMYpvyg/u/rIo0ZgUXIk4Yb7UqRc7NUIriJqIfWV+kGowgeqpyKqRoIDSij6ZHlKfwC6NDSiM56xIFxdrZtfnL2hZsbijKNqcP68tZ0pNQsiaJf5FCYElOWHN2L/RrpXaMXGyYiMNkwKdTzDuw1YNUGxmVgo6csIbl/itaM174JP3j4xcdUM5twkdpwrcBWzQIcmDDCQO0CFGlws6ssNbM0IaU9iVCf4lcX4lMf5FYAXuXxQ1uWDeBO3ccfqFE4riA6oyQppkgg6ioAgsHezdoC9LJYD8rQpcOhBhRifHnBFaF8dZ+bjlnz//eH54x/zEvVvmTc7TRTgLpnSpxcSzAQt1ismRo4kBxb1J7CrtnLbtb+wf4SkaXdRq1oLKKB9d7rWQIcRmkgyPxbQBt1k60kKaED348tA3Y3s0Hm8XIoSCqtSQBrXU/ivRYHw8uJwVEUV0jydyKqODdSMkhOgB8sX+b9JFlancGqXAhPgSUCYR4oSdGnGnWujIDG+JmrziMfPLp06cHq0h/hv6rgwUxrWnhoCTqj6iC14ogOkipAfRYLGlKq7aFVllvNYlASsft/7z7E89V//96HGXe3dZrF8JmvnoCQklo0K7SmDHGX58ibFcMNwXApOM15ER0pwW3ATZQk5VUlBVCrcmmVOTzK5J5dSiNSycquSgytSg6hR2TQq7Gv0+hYX+VJuMNoJqUzjVSayKxMCy9ODaBeNVZVmmw/uOjtGpo6C4qUEJIcVNAY+396zHMcNbd4enxc/TzmKoYCusccIw0NMc4MWdhF5oJoQ8oQeM6bHEaKufp+qvXsMUz9c7r/dAKG5peLyXzvdmzyxOCarUSWx66JoDt3EVFH2hwNGsFiNCaEKEUCU1x7JLUyVren4eHVEZhL7L/Yp7KjLCG/OmrdNHdmExRhRPQ7WqSoLrEkU2RAizwtuSuCXpU1Ze7Bk1zzSPx7tr68F69X0Z4TU5oc0FkQ5EC7WQogTnCZ+iiRmSACBaSAz3iEaFIZfXmhnWiEhXKheitxQc7aF1Grc2M7QxO7wFkS7SyARmfRJGmx5RTTVucMLkyqIWIpJjyg1vQ5F0dOByxAb3bTsy1GK23xqYNzWyPC24QYMJJzbEwy15uHQQ9zuRBCxkQRV8FL8assNaM0Oa0ZIR3JQe3JAR2pQV1p4TZgR7RoFFzgPvBxWpuyMOE4i0Y89GwjmzQ5sSw0rMKx89efTHYec2N67bcs84HTon+VPWq0gGRjR45sGBUCG0yfmWRFZV/sL2j97+bKRnafTg8Xhq1M6EwBJ0TnSRQAixSK+VqXqF2lqbWmxXSTpTghsSwou+OPD1mBrTowmwrvqZVAGiIrV413A7wyHBYoXJILRqIzq1EY4kTvWSEP0ICeGlnivvvbh33h1LM7iN2HjQTsarFjm0Yie6oMns6jj2yp1vfTbQN5rGmP+GRwwv5kbWo5kMVbLQvYl4mg0qDqDgHM1/tFigvJlvSmZVKmc1HO0+efVXAT3u5HMqYicVo0usj3Sq8OigPBgUZYnzIZQHE4sUXGtglfPQnWWUo4WPFpMc1x0oicEMljJGH1DyLSo+/EM0seGtDQ/da9DGrBJYNQKbTmhfOmXdkoDlLQX3fnVwyGXYFBR/BFBCSHEzAP1n03fRY5/prb3D2+rnbicNhD4q2BLoZdYsYIOYEIJVfRsQQm8HyRD+1Wua4fmx+3qPhOJWBqnbzEKEkFulk9r1kZ3Q/wNvvu3YfByk8xCT0Uc6VBJTPKcsTVJy/vTF0esh7JPNLkeEMH/aWv2UTlKICJEc0CfcroZ+FFmzw1uTg0syphWPei/Nnq0HbcUbtbNaMkNqNAKTXuLQiqw+YUaLiklP4Z5GkMcA/oMXu0bqIA11KMiT8RCvM6DID20jGqaV2jXEpZ2Y9UksTMeRBJ1JI2QFITYFe2sZIrrsijRhub1i42cffTkM/cP/hNvlSYkszQht0IJxPNa9EBNqjXV6hD43bTjD6ANwqOSvRCwUn3NcQ8v/tQQrk6/DGjxQGqcCLVabjG9IDqpOF1Q26u4/vPeYa2A4rt9eIirj3DzrDo0GEcLItUqmJM/XQIjlZBCTyeWZkjg1QAjfuoEIIWILNSpnIqsUMWSNtEuBHTUVxDSF8U0B0R2FyJbMrY8PK/xqjDOE6GTeX/dcumiQEMKNzLBBsU0OJi6QIdRI7YiqLQnJGyEhPNb9nWnF44vuLEI3KbBfkBey43nVqQWNU3O835plC9s//3RsC2W79xxfFtORwqlC85lQMoWIZJhtTO0oZmtqgTU3rHXuxLwdb+zvvXS1qXj0n7lyQUWsfzEidXlTurRShwb3ScJDErKC+HWJkLlfwL0GzVsebh/l4+JqkfVXxc/4TRPfquBZgfuhNWzg2w3IoRUtasQGRZ0F4rVFMx+I9S/qKPzbV4fG+CUCBcXNCUoIKW4SDPS67bO8Nbd7Wya727HZIJSM4qUZ2KCHaI0iKtiCGCCxoAj0tAVgQujnrfyL1zLLcxZL0tH/DCjGBijO6Lvcnz5jdTK3Uhdh10UgnuMghFANzBDRGFBU109xqKWWeHZ5mrTs/E8X3UOU6ftv6L8ykDO7ND2sPm9qF9q1CosxohgOhbAaQghxSJ3Na00OKUmdsnosxBWOHvr2Ccc/i5OtaUHl2aFNKr4Rl705mKwgzlJCV5LIhGmh1Ze5smiEVjVmUEQflXBFsI6Q4LWYIYQaLEGhEiNiZtaILTr0T6Bl0ZwV2pQSVKGcUb++6akfvz07Wm2Z6JQmRxanh9RqpMBFoR8SHRvIwGArEeLqgUvpwKINZwsVgl9ygAo+VltFtIEH2ozYm9GkxM6QxAJEBRKskGaU8VrjAovTxGXtRQ/t3XpkhIf9qHPTrDvUelB2df5iTC8epFWwX1m4MTmoVj+/fcebN1DJKLoXapVdSawyBZo5EqdcZMf0FR0/KAbB5IG0M0yhpKC6a0AIEe6vezZTXJnMrUV3E7qVlIybqA0Ln0IJpVrqQHMygVURHZLfM4K+XDRpP3pjf2p4WZJ/tVxkVGGdJDU8QDrRqdBKnbnhbbF+Kx8zvvTTyZ9HcYD/iSu9/XW6dakhlXKeAdggH89t6PGzYBtGswzr+uokTjTH5k8s+Fvj898d++nqv18+vyw2sFgpMpMnlRa3FsPpJdY18ECwMYXNAqscEoBwK8n4kBJk7CgZm1NsfEq4H8+iCDcrYY0JJM8khzSjVSt0aAWOfPG6wpn3x/kVti67/8sDJyghpKD4T1BCSHGTwNXvctzjqbzN0zTRgwmhC9KDLIb+tRCKCIu3jdnGhNDf0+7vbZnkrfyzxzrb0/Pd9R4Gxa0MIISX+jNmrEkMKkeUT4sTX1qIFx0aEIcwQ9Wo1KyfYldJLXFBlSmSkrM/Xhg5ISTxzUCfK3dOWQYQwnXaCCeRB4QX+RIsxIKzcyi8ywpvTQpZkxKx4uLIjOn/G65c6t+z9VBxiiFdUJLKrcwVtGkjHDp0EiCHBiqaEOaC25gVK8EA0dIAIYQ4T42FcBjuRxZsY6jBAq0aMeGEaDHj39vUAmtOWGtyUFWWpLowzviE45XhqbD8JqAuoXcgY3pFIqc8O6xFLjDgDkDo6VKBpoiVEcoX4q48MSnLhIiWdOjhXkHc7ii2QSUbuIqbGUIoYrzXNIjwCIxpIXXR/svTpWvW1j359ZHvR3zYng1rX7xnnEYvtSFCqPJZ0uOTbyd5NjU6mFBjUlBt/sKOj94+MCqna1QAJaMqZ1xAsYxn0Eo7VSIHpl5MbhOfNMi+InKbxKmPD1txtHvMCeH66qfTBOVJQTVKCbxbUUlt0BgMF86KpVCsuLfQFBtYGhO6rOfsxWHv6PyZi8/c98bs27QZnGYVPDGAI6mlTrWkE6wOxfY0Tl1cwKov9n0zpvWiBBtsW5Qzm1O5TZhWmRQCIzSgioijKSKERjSRCqasXT7t3mROheau+r3vD6H6JmdOWQK7FF1N3RSnNtKBng8wMyGXjpPA+LURPCiEkDYkRarEjpJpJSVVrIxyFdPVCRs8MxDIcLOKj9igUYabMPPFXTqBM1+8tnDG/Uv8C2s1XUc+PTZmp42C4iYGJYQUNwk8bs/aBd7KO7yNE70dLMQJXeA8EeghDoREVwZXkCJC6G3DbYSt2HaCIYR/9TrmeS6fud7DoLiVQTKEWXeVxLNLlGKDRmqBzFIkon8ojrRqInEbYYRRLTFkh7cuYZUkSVae/u7csIsDf71ftO7r7ZfNqcgUNubPWKub4lCIjEqhSSHsUCAmIzahBf1GJjRk85qTg1enSceKEJLjuXju8gv3vqOaVRXDKkwJrkKHoY+w501x6iI6dVIw31ORNCDICYLKvAbLSGqJWAumjthE0Uq0NxGXRmutBMXiNo3EqpfYtKC42JYSVJ0YtCp3WtVD7S9+8/kPYzGWSo0zSVi8JHBVXEB5WnCTklSHiohnIFTNDSY2IWUUblYDIfQViPJJdo4pGQX+AH8CZquDsaD5YIwLWBPFzlfeXbvl0fcvnB1x0yOxnVi75Z7xWo3EmA+JYiPW8oEuR6WAWRRCY05YWzK3EgjhjVQyiiZypcK+2K8oi9eqljrQCZSLTLkCA2Igcp5BzjcALcdOgMlBdbGhBV8eHHPbic6yvyeHlySyK5WM0wmRaAJ5G5UUbYN6sELcEc8qS+AVnjtzYdjZpz3vHSpOsdx9my47rE0rsesjnVpoQu7USDu1kZ0KsTmRXSqT1P347dimBwkO7z1emdu1xL9YxiftrwYFeoAITehyyERG8JVBc3hq57KZ96mkHdGBS19/5kP0/LnKL8++pzyeU4ZuZF2EE1FfpdSmkFhkOM1O9KI00HEN9Bur+AC7A71ieJqhXRuUaDIITHJeh1zYARNDYITPCI3o+aYSkuJS9KAz5qKZL7HlRa7VS535U5xLp3ctnryiQmbt3vfVmJ46CoqbFJQQUtw0cN8X7akehwihpyPQ3cF40zPOE82YHLZjJ3rIDbIhQ9gS4G3x87b5exsneSv+7O2a5+k9d70HQXErA1RGf76UNn3lvHEFyUHVGWF1meF1mfymtLD6eE6FQtqqjujQRHZoIzvk4pZYTkmCaMWp42dcA6Pwvp9w0cxZq2PYxVn85ixBc46gRSlszRW05PJbZIKmHFFztqg5k9+QHFIVH7wqSbJ07AjhIHov9ZmKH1sSvGzGX3Lmj89LC6nWSAy6qY78ac78aWtBhRWyfNA45BNWsUKBK/ZjwP7soLKokzq0Urt+iiN/ulMbaVOJjTnhDUsmLp9zuzolvPhx06unjp0erT7M38Th3SfaCx6OYueJ/ycl8v/mzB63NJFbnSVs1kZY86d2FUxblz+lKw+IbqdKaAfjOJENrbFpIQxBJ0HH70Cxry6ySy3tRFxdF2lOD6qZ/ReN9P+kJYavemXjjrM/jdSugMDt9rhc7kedm6bclpMUVJ3NR1e/VSlqk4tbc0UtMmGLTNSSI2zODGtMDa6LDiiW31V/Q9lOIKzJMMwdl58cVJMZ2pzObcwObc7mNWeENWaFN+Tym9FkRj+mhzYu9i+eOT6ze9/RMb306HyaVj+2mL1i0cSiNG5denBtRkhdekh9BlrC6jPD0boundeQFFK7YFJhQnjRudMXhl2N+OT9r84ap1o0uTBb0JjKrk5j16ay61JYdcnsusTAqsWTVs2ZoG5WPzwkSc9hY6DPZSp9cN54TRq3IjusPguNN7g2J6wuCz3T0JBD69LCGjL4jTJhm0zaMs9vaYPmvoM7r4poDfS7Umesuvt2fQq3NkvQksZrRN+TLWzKCq/PRKc0pDEztAnWwQ1oSefWpwXVpgXVo+mawq1LQz8G1+GlNi2kNjWkBv0+mV2bxK5L5tSjEwXioiBJVZ3MqU7i1KSFNObwWnPC0bRpy+K1zr5TX5pj6v6EEkIKit8AJYQUNw0G7o/x1Iz7JUPI6MqwPK1BuIeQbJMGwkBPM9vT6g8OhB1sT7O/t+oO77rF3oFReAFPQfHfgFjZpfOXs+esnuuviw4piglbERu2LJ6/Io5XGBVUsDAgb0GAZp6feu5k7Tw//Tx/beb04h+++XlUCKEX9xDqYmvmBWjnTtbPD1gaHbRiCXd5XGhhTGjRkhB0JCuig5cuCNTPnayJCl4qn1t+6cKYGzSjYP3cmQtff/n9a//YUZ7ZOX+yfur/zZ51uzLaf1UKtyo7vEkhMmqlIMeaH9GVF+lEa524E/EorcRRENFVMGWtPtKuFhozwxpiA4rn3Zk/88/KueP0maLqVt1DO17/7NSJ0xfPXx55ivX3gU4sCvRPfX36yKfHX3ps25oUa3Tw8mnjMu++XXnP7dr545cumVyMwtDM8FYZ5LJAgFSDBjWlEy3aKQ5NhEUhMWQJ21NCGmI55fMm5N91W84itq441b773W70tZcvXhktpVkvPucvPPpmdHDBQv+CRawVMaEro8OKooNgWRJSFBu6Mia4aDFnGZokd0/QKefWbn9zH+FU172xCh2Ae8DdmL9+YWDBIvaKuPA1CbziGG5hFHdpFAfN5+WLOcujWMvQxI5iL5/rr54bpDqw50u3awwPG02truon4gVF81n5MaGFi4OXobspNrQIbUQFL1/ELpgXmLeAs3wBe/ldE2UpU9f8dOosupTokIZ6Qc+fuXhv65NT/pw68zb53IC82LCVCwLz5vnrFgTkLWIVRLELFrK1ydLlbzz1MZotYzTYXwNdiy0btyrm1d7tp5ztr57Dyp+HHh2B2rks7T3+mrv9tGiZPVFz13jZrHHqmXfkymdXv7tl19VMITTZ8mLr40JXpUuqc6bXZk+tTpdWpknLloQXLgldEc1Fl3h5VOCyRYFL0cCjg1fA2IPyl4QVoSU6BF2CwujgQvQ0Q0/XKO6yBex8tI4OXbE4ZFk0dxmaLTHwxEM/5i/k6Ob7a++ZqL7rztxZ42T3jNdF3p7WtHzdV4eoyigFxW+AEkKKmwauB5PctRO8TZNwJjDA0+bnbvN3tWBC2MbGCzjUkx5CRAi9mBCCAg0ihNV3eO+P87pHrb+IguI3gSLIg3u/2Lu9+9OPPv905xGy7N95ZN9Hh/d+0L3ng4O73z+w+/2Dez/s3vvhoYO7v+jr7R+tQBx9z8G9X+7aemDPtkOffHh4344j+3YcRrtGR4K2P/0IHcORT7Z37/nw0Cc7Dh/c86VrlMRs/leg4Pj8zxePdZ9EB/b+K3sfNW4pTrVlT6lMCFu9hFO4yG/ZwslLF04umDtBt2ji0hj/ojjW6ljW6ij/wnmT8mdPUM2doF7svzR/fqu9+O/P3//W+y/v3b/jy68///7yhSvXmMOgi4uY4VcHv0FXc/vb+zY/stVe8o/liw1JoasXTtLfPU4x60753AnahX7LFgQsm+8PlCwqYGmUPwpwCxPDitWzmurk9z/SvuWNZ3d8sqP7q4PfXr0245Dww8kzu7ceRAuaBnD10aWHyYA2YBv95pPth9EM3L2t+9Der0bupT6KQBf0+JGTcHgfdH+yHd04X8A2HC0c8J5tsHyCt/duR9O4+2LP5TGdA+i7Txw5ic4eOgx8Bx3+dCe6r/EpxXfTXrihDqOjQvc1Yqf9VwbIKIZ6VOg5cOLzkx+9vW/n2/s/fu8gukb4mw+hkaJdoxt5347uA7s/P3t6FFqOrxJnfjzfve/o7g8PwmFsP7zng0O7Pzy0+4NDu7Yd3I2XXVsP7nx3P6zf2f/Zx19cvW3mkf3H0JU9sOurg7thQRsHdn35yUfwqMQjhbO9j4waneQdh9EyeM7JQp6raAOdJfwshWXPB917t8HpQsuebQfRsnvrAXRsO97at/OdT3e/f2jX+5991f3N5Yv0vTAFxW+AEkKKmwb998V76v2hLbCD7W4LcHcEuhEnBAbI8bZzPB0cTzssbtgAcgjFoq1+HgML2GPdBPeDqV7PNfqvlILiP0GiRAgUxyyC9eDsxNUU0V2vdFB/38APX//8yQeHt768+80Xdrzy1LbNG9599oHXn+h6+YH25x5se/YRw6bHTJsfM295zPrS486Xnrz/n5see+vVp7btfOuzY4e+O/fTBaDQY1kleJVAcfn5M5eOd5/a81732y/sfPmJ955/5I1nHnjlmftf/XvXKxvsWx61vvi4Y8vT9776wkNvvbRx65vP7fjwtX0HP/7q1LHTly+OCQ8cBJ4G7v+VOVz3lOB/A9wobo8vb+lb3JB2891E1+7IrybdN3i0wwYZHblq14zyDQnMmccjHXyUwag9cC+M/Jk2/EuKDgCAp4dvQYc0uMFs4++/ER4dFBQ3JighpLhp4Lo/2dPgD17zBo6rLcDVjgihv7uNBVSwg+PtYEN1aAcihEHudrYbbbcHeNv8vCa2t93P3TjJtSH3eo+AgoLiX4Dis4F+15XL/RfOXjqN6N7Jsz99d/Y0LOd+/qHnwtnL6E9jXRE6cgB/cbnRQPqvDPRevNJz9tLZH3vO/njh/JmLF8+jIfS5+l03KvmioKCgoKCghJDi5oH7D5NswAAABQNJREFUoRxvU6C3zd9jYAMVbA8AURnEACExGORpZ2NOiNOD7cAPIUOIOKGB5W2Z6G72cz+pv94joKCgoKCgoKCgoLixQAkhxU0D92MaT0uQt83P0+HvaffztPu7EC1EhBB3D3qBBHI8iAciZoi228GP3gPWFAGexjs9rYHu54qu9wgoKCgoKCgoKCgobixQQkhxM4D4bm/Qe1qD3a1+7nZ/T/Nkd4u/q4XtbuO427GoTDvHYwBC6IEiUrbbgH4TiAiht4PlbZkAXHHT6us9DAoKCgoKCgoKCoobC5QQUtw06P17kas5DBznTdyBjoB+RAvb/d0WntsqcFl4HpvAYxW4zeFuQ4jHFOxBhLCVhRjjQAfH3TgBMUnXS1XXewQUFBQUFBQUFBQUNxYoIaS4aXBlU62rPsiz5v9zw/L/orWn7H+8FX/yVP4ZLd6qvzBLzV+9NX/2Vv/JW327t/zP8Jni/8dd69+/qeR6j4CCgoKCgoKCgoLixgIlhBQ3DVxffej6u8a1fp77b4td6+cP2Kb1W6e5O8I9HTxXa4irJcRtEHks0zy2mR7r9AHbTFd78EAHt98YOmASDGzIdXe/dr1HQEFBQUFBQUFBQXFjgRJCipsGnt4ez9e7PV++6z66Fa09h193db/m+Wyz98AWtIblwMueQ695ul/3HHrdjdafveD+7Hn3wRfdh172nNjpvXTmeo+AgoKCgoKCgoKC4sYCJYQUtzDAN3cEfrcUFBQUFBQUFBQUtzgoIaSgoKCgoKCgoKCgoPiDghJCCgoKCgoKCgoKCgqKPygoIaSgoKCgoKCgoKCgoPiDghJCCgoKCgoKCgoKCgqKPygoIaSgoKCgoKCgoKCgoPiDghJCCgoKCgoKCgoKCgqKPygoIaSgoKCgoKCgoKCgoPiDghJCCgoKCgoKCgoKCgqKPygoIaSgoKCgoKCgoKCgoPiDghJCCgoKCgoKCgoKCgqKPygoIaSgoKCgoKCgoKCgoPiDghJCCgoKCgoKCgoKCgqKPygoIaSgoKCgoKCgoKCgoPiDghJCCgoKCgoKCgoKCgqKPygoIaSgoKCgoKCgoKCgoPiDghJCCgoKCgoKCgoKCgqKPygoIaSgoKCgoKCgoKCgoPiDghJCCgoKCgoKCgoKCgqKPygoIaSgoKCgoKCgoKCgoPiDghJCCgoKCgoKCor/v/06EAAAAAAQ5G89yGURwJQQAgAATAkhAADAlBACAABMCSEAAMCUEAIAAEwJIQAAwJQQAgAATAkhAADAlBACAABMCSEAAMCUEAIAAEwJIQAAwJQQAgAATAkhAADAlBACAABMCSEAAMCUEAIAAEwJIQAAwJQQAgAATAkhAADAlBACAABMCSEAAMCUEAIAAEwJIQAAwJQQAgAATAkhAADAlBACAABMCSEAAMCUEAIAAEwJIQAAwJQQAgAATAkhAADAlBACAABMCSEAAMCUEAIAAEwJIQAAwJQQAgAATAkhAADAlBACAABMCSEAAMCUEAIAAEwJIQAAwJQQAgAATAkhAADAlBACAABMCSEAAMCUEAIAAEwJIQAAwJQQAgAATAkhAADAlBACAABMCSEAAMCUEAIAAEwJIQAAwJQQAgAATAkhAADAlBACAABMCSEAAMCUEAIAAEwJIQAAwJQQAgAATAkhAADAlBACAABMCSEAAMCUEAIAAEwJIQAAwJQQAgAATAkhAADAVGXpS2RrAXCtAAAAAElFTkSuQmCC";
        
        if (consentType === 'PATIENT_COUNSELLING') {
          // Generate Patient Counselling, Education & Documentation Consent Form
          // Each language on separate page - matching Digital Consent Form format
          const patientName = patient ? `${patient.firstName} ${patient.lastName}` : '__________';
          const patientAge = patient?.dateOfBirth ? calculateAge(patient.dateOfBirth) : '__________';
          const patientGender = patient?.gender || '__________';
          const patientUhid = patient?.uhidNumber || patient?.id?.substring(0, 8).toUpperCase() || '__________';
          const currentDate = new Date().toLocaleDateString('en-IN', { day: '2-digit', month: '2-digit', year: 'numeric' });
          
          const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Patient Counselling, Education & Documentation Consent Form</title>
  <style>
    @page { size: A4; margin: 15mm; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Arial, sans-serif; font-size: 11pt; line-height: 1.5; color: #333; }
    
    .page { width: 210mm; min-height: 297mm; padding: 15mm; margin: 10mm auto; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); page-break-after: always; }
    .page:last-child { page-break-after: auto; }
    
    /* Hospital Header */
    .hospital-header { display: flex; align-items: center; gap: 20px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid #4a2683; }
    .logo-section { display: flex; align-items: center; }
    .hospital-logo { height: 50px; width: auto; }
    .hospital-info { flex: 1; }
    .hospital-name { font-size: 16pt; font-weight: bold; color: #2c5aa0; margin-bottom: 2px; }
    .hospital-address { font-size: 9pt; color: #333; margin: 2px 0; }
    .hospital-contact { font-size: 9pt; color: #333; font-weight: bold; }
    
    /* Patient Info Row */
    .patient-row { display: table; width: 100%; border-bottom: 1px solid #333; padding: 8px 0; margin-bottom: 20px; }
    .patient-row-item { display: table-cell; }
    .patient-label { font-weight: bold; font-size: 10pt; }
    .patient-value { font-size: 10pt; margin-left: 5px; }
    
    /* Form Title */
    .form-title { text-align: center; font-size: 14pt; font-weight: bold; margin: 20px 0; padding: 10px; background: #f5f5f5; }
    .form-title-sub { font-size: 10pt; margin-top: 5px; }
    
    /* Info Fields */
    .info-fields { margin: 20px 0; }
    .info-field { margin: 10px 0; font-size: 11pt; }
    .field-line { display: inline-block; border-bottom: 1px solid #333; min-width: 200px; }
    
    /* Consent Section */
    .consent-section { margin: 25px 0; }
    .consent-heading { font-size: 13pt; font-weight: bold; margin-bottom: 15px; padding: 8px; background: #4a90a4; color: white; }
    .consent-text { text-align: justify; margin: 12px 0; font-size: 11pt; line-height: 1.7; }
    
    /* Declaration Section */
    .declaration { margin-top: 30px; padding: 15px; border: 1px solid #ddd; background: #fafafa; }
    .declaration-title { font-weight: bold; margin-bottom: 10px; font-size: 12pt; }
    
    /* Signature Section */
    .signature-section { margin-top: 40px; }
    .signature-row { display: table; width: 100%; margin-top: 20px; }
    .signature-item { display: table-cell; width: 50%; vertical-align: top; padding-right: 20px; }
    .signature-item:last-child { padding-right: 0; padding-left: 20px; }
    .signature-field { margin: 8px 0; font-size: 10pt; }
    .signature-line { border-bottom: 1px solid #333; height: 25px; margin: 10px 0 5px 0; }
    .signature-label { font-size: 9pt; color: #666; }
    
    .hindi, .marathi { font-family: 'Noto Sans Devanagari', 'Mangal', Arial, sans-serif; }
    
    @media print { 
      .page { padding: 0; }
    }
  </style>
</head>
<body>

<!-- ==================== PAGE 1: ENGLISH ==================== -->
<div class="page">
  <div class="hospital-header">
    <div class="logo-section">
      <img src="${hospitalLogoBase64}" alt="Gravity Hospital Logo" class="hospital-logo">
    </div>
    <div class="hospital-info">
      <div class="hospital-name">Gravity Hospital & Research Centre</div>
      <div class="hospital-address">Gat No. 167, Sahyog Nagar, Triveni Nagar Chowk,<br>Pimpri-Chinchwad, Maharashtra - 411062</div>
      <div class="hospital-contact">Contact: 7796513130, 7769651310</div>
    </div>
  </div>
  
  <div class="patient-row">
    <div class="patient-row-item"><span class="patient-label">Patient Name:</span> <span class="patient-value">${patientName}</span></div>
    <div class="patient-row-item"><span class="patient-label">UHID No:</span> <span class="patient-value">${patientUhid}</span></div>
    <div class="patient-row-item"><span class="patient-label">Gender:</span> <span class="patient-value">${patientGender}</span></div>
    <div class="patient-row-item"><span class="patient-label">Age:</span> <span class="patient-value">${patientAge}</span></div>
  </div>
  
  <div class="form-title">
    PATIENT COUNSELLING, EDUCATION & DOCUMENTATION CONSENT FORM
  </div>
  
  <div class="info-fields">
    <div class="info-field">Department: <span class="field-line"></span></div>
    <div class="info-field">Date: ____ / ____ / ______</div>
  </div>
  
  <div class="consent-section">
    <div class="consent-heading">1. PATIENT COUNSELLING, EDUCATION & DOCUMENTATION CONSENT</div>
    
    <p class="consent-text">I confirm that I have received proper counselling and education regarding my illness, diagnosis, treatment plan, medicines, procedures, possible risks, benefits, and alternatives.</p>
    
    <p class="consent-text">The information was explained to me in a language I understand. I was given the opportunity to ask questions and all my questions were answered.</p>
    
    <p class="consent-text">I have been informed that my counselling details will be documented in the hospital system and used for <strong>continuity of care</strong>, <strong>legal requirements</strong>, and <strong>medical records</strong>. My personal information will be kept <strong>confidential</strong>.</p>
    
    <p class="consent-text"><strong>I voluntarily give my consent for patient counselling, education, and documentation.</strong></p>
  </div>
  
  <div class="declaration">
    <div class="declaration-title">DECLARATION</div>
    <p class="consent-text">We confirm that all the above information has been explained to us clearly. We have understood the same and have given this consent voluntarily, without any pressure.</p>
  </div>
  
  <div class="signature-section">
    <div class="signature-row">
      <div class="signature-item">
        <div class="signature-field">Relative / Attendant Name: ______________________________</div>
        <div class="signature-field">Relationship with Patient: ______________________________</div>
        <div class="signature-line"></div>
        <div class="signature-label">Signature / Thumb Impression</div>
        <div class="signature-field">Date: ____ / ____ / ______</div>
      </div>
      <div class="signature-item">
        <div class="signature-field">Doctor Name: ______________________________</div>
        <div class="signature-field">Designation: ______________________________</div>
        <div class="signature-line"></div>
        <div class="signature-label">Signature</div>
      </div>
    </div>
  </div>
</div>

<!-- ==================== PAGE 2: MARATHI (à¤®à¤°à¤¾à¤ à¥€) ==================== -->
<div class="page">
  
  <div class="info-fields marathi">
    <div class="info-field">Department: <span class="field-line"></span></div>
    <div class="info-field">Date: ____ / ____ / ______</div>
  </div>
  
  <div class="consent-section">
    <div class="consent-heading marathi">1. à¤°à¥à¤—à¥à¤£ à¤¸à¤®à¥à¤ªà¤¦à¥‡à¤¶à¤¨, à¤¶à¤¿à¤•à¥à¤·à¤£ à¤µ à¤¦à¤¸à¥à¤¤à¤à¤µà¤œà¥€à¤•à¤°à¤£ à¤¸à¤‚à¤®à¤¤à¥€</div>
    
    <p class="consent-text marathi">à¤®à¤¾à¤à¥à¤¯à¤¾ à¤†à¤œà¤¾à¤°à¤¾à¤¬à¤¾à¤¬à¤¤, à¤¨à¤¿à¤¦à¤¾à¤¨, à¤‰à¤ªà¤šà¤¾à¤° à¤¯à¥‹à¤œà¤¨à¤¾, à¤”à¤·à¤§à¥‡, à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾, à¤¸à¤‚à¤­à¤¾à¤µà¥à¤¯ à¤§à¥‹à¤•à¥‡, à¤«à¤¾à¤¯à¤¦à¥‡ à¤µ à¤ªà¤°à¥à¤¯à¤¾à¤¯ à¤¯à¤¾à¤‚à¤šà¥€ à¤¯à¥‹à¤—à¥à¤¯ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤µ à¤¸à¤®à¥à¤ªà¤¦à¥‡à¤¶à¤¨ à¤®à¤²à¤¾ à¤¦à¥‡à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥‡ à¤†à¤¹à¥‡, à¤¯à¤¾à¤šà¥€ à¤®à¥€ à¤–à¤¾à¤¤à¥à¤°à¥€ à¤¦à¥‡à¤¤à¥‹/à¤¦à¥‡à¤¤à¥‡.</p>
    
    <p class="consent-text marathi">à¤¹à¥€ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¥‡à¤² à¤…à¤¶à¤¾ à¤­à¤¾à¤·à¥‡à¤¤ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤¹à¥‡. à¤®à¤²à¤¾ à¤ªà¥à¤°à¤¶à¥à¤¨ à¤µà¤¿à¤šà¤¾à¤°à¤£à¥à¤¯à¤¾à¤šà¥€ à¤¸à¤‚à¤§à¥€ à¤¦à¥‡à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤£à¤¿ à¤®à¤¾à¤à¥à¤¯à¤¾ à¤¸à¤°à¥à¤µ à¤ªà¥à¤°à¤¶à¥à¤¨à¤¾à¤‚à¤šà¥€ à¤‰à¤¤à¥à¤¤à¤°à¥‡ à¤¦à¥‡à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€.</p>
    
    <p class="consent-text marathi">à¤®à¤¾à¤à¥à¤¯à¤¾ à¤¸à¤®à¥à¤ªà¤¦à¥‡à¤¶à¤¨à¤¾à¤šà¥€ à¤¨à¥‹à¤‚à¤¦ à¤°à¥à¤—à¥à¤£à¤¾à¤²à¤¯ à¤ªà¥à¤°à¤£à¤¾à¤²à¥€à¤®à¤§à¥à¤¯à¥‡ à¤•à¥‡à¤²à¥€ à¤œà¤¾à¤ˆà¤² à¤µ à¤¤à¥€ <strong>à¤‰à¤ªà¤šà¤¾à¤°à¤¾à¤¤à¥€à¤² à¤¸à¤¾à¤¤à¤¤à¥à¤¯</strong>, <strong>à¤•à¤¾à¤¯à¤¦à¥‡à¤¶à¥€à¤° à¤†à¤µà¤¶à¥à¤¯à¤•à¤¤à¤¾</strong> à¤µ <strong>à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯ à¤¨à¥‹à¤‚à¤¦à¥€à¤‚à¤¸à¤¾à¤ à¥€</strong> à¤µà¤¾à¤ªà¤°à¤²à¥€ à¤œà¤¾à¤ˆà¤². à¤®à¤¾à¤à¥€ à¤µà¥ˆà¤¯à¤•à¥à¤¤à¤¿à¤• à¤®à¤¾à¤¹à¤¿à¤¤à¥€ <strong>à¤—à¥‹à¤ªà¤¨à¥€à¤¯</strong> à¤ à¥‡à¤µà¤²à¥€ à¤œà¤¾à¤ˆà¤².</p>
    
    <p class="consent-text marathi"><strong>à¤°à¥à¤—à¥à¤£ à¤¸à¤®à¥à¤ªà¤¦à¥‡à¤¶à¤¨, à¤¶à¤¿à¤•à¥à¤·à¤£ à¤µ à¤¦à¤¸à¥à¤¤à¤à¤µà¤œà¥€à¤•à¤°à¤£à¤¾à¤¸à¤¾à¤ à¥€ à¤®à¥€ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¥‡à¤¨à¥‡ à¤¸à¤‚à¤®à¤¤à¥€ à¤¦à¥‡à¤¤ à¤†à¤¹à¥‡.</strong></p>
  </div>
  
  <div class="declaration">
    <div class="declaration-title marathi">à¤œà¤¾à¤¹à¥€à¤°à¤¨à¤¾à¤®à¤¾</div>
    <p class="consent-text marathi">à¤µà¤°à¥€à¤² à¤¸à¤°à¥à¤µ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤†à¤®à¥à¤¹à¤¾à¤²à¤¾ à¤¸à¥à¤ªà¤·à¥à¤Ÿà¤ªà¤£à¥‡ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤¹à¥‡. à¤•à¥‹à¤£à¤¤à¤¾à¤¹à¥€ à¤¦à¤¬à¤¾à¤µ à¤¨ à¤†à¤£à¤¤à¤¾ à¤†à¤®à¥à¤¹à¥€ à¤¹à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¥‡à¤¨à¥‡ à¤¦à¥‡à¤¤ à¤†à¤¹à¥‹à¤¤.</p>
  </div>
  
  <div class="signature-section">
    <div class="signature-row">
      <div class="signature-item">
        <div class="signature-field marathi">à¤¨à¤¾à¤¤à¤²à¤—à¤¾à¤šà¥‡ à¤¨à¤¾à¤µ: ______________________________</div>
        <div class="signature-field marathi">à¤°à¥à¤—à¥à¤£à¤¾à¤¶à¥€ à¤¨à¤¾à¤¤à¥‡: ______________________________</div>
        <div class="signature-line"></div>
        <div class="signature-label marathi">à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€ / à¤…à¤‚à¤—à¤ à¤¾</div>
        <div class="signature-field marathi">Date: ____ / ____ / ______</div>
      </div>
      <div class="signature-item">
        <div class="signature-field marathi">à¤¡à¥‰à¤•à¥à¤Ÿà¤°à¤¾à¤‚à¤šà¥‡ à¤¨à¤¾à¤µ: ______________________________</div>
        <div class="signature-field marathi">à¤ªà¤¦à¤¨à¤¾à¤®: ______________________________</div>
        <div class="signature-line"></div>
        <div class="signature-label marathi">à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div>
      </div>
    </div>
  </div>
</div>

<!-- ==================== PAGE 3: HINDI (à¤¹à¤¿à¤‚à¤¦à¥€) ==================== -->
<div class="page">
  
  <div class="info-fields hindi">
    <div class="info-field">Department: <span class="field-line"></span></div>
    <div class="info-field">à¤¦à¤¿à¤¨à¤¾à¤‚à¤•: ____ / ____ / ______</div>
  </div>
  
  <div class="consent-section">
    <div class="consent-heading hindi">1. à¤°à¥‹à¤—à¥€ à¤ªà¤°à¤¾à¤®à¤°à¥à¤¶, à¤¶à¤¿à¤•à¥à¤·à¤¾ à¤à¤µà¤‚ à¤ªà¥à¤°à¤²à¥‡à¤–à¤¨ à¤¸à¤¹à¤®à¤¤à¤¿</div>
    
    <p class="consent-text hindi">à¤®à¥ˆà¤‚ à¤¯à¤¹ à¤ªà¥à¤·à¥à¤Ÿà¤¿ à¤•à¤°à¤¤à¤¾/à¤•à¤°à¤¤à¥€ à¤¹à¥‚à¤ à¤•à¤¿ à¤®à¥à¤à¥‡ à¤®à¥‡à¤°à¥€ à¤¬à¥€à¤®à¤¾à¤°à¥€, à¤¨à¤¿à¤¦à¤¾à¤¨, à¤‰à¤ªà¤šà¤¾à¤° à¤¯à¥‹à¤œà¤¨à¤¾, à¤¦à¤µà¤¾à¤‡à¤¯à¥‹à¤‚, à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾à¤“à¤‚, à¤¸à¤‚à¤­à¤¾à¤µà¤¿à¤¤ à¤œà¥‹à¤–à¤¿à¤®à¥‹à¤‚, à¤²à¤¾à¤­à¥‹à¤‚ à¤à¤µà¤‚ à¤µà¤¿à¤•à¤²à¥à¤ªà¥‹à¤‚ à¤•à¥‡ à¤¬à¤¾à¤°à¥‡ à¤®à¥‡à¤‚ à¤‰à¤šà¤¿à¤¤ à¤ªà¤°à¤¾à¤®à¤°à¥à¤¶ à¤”à¤° à¤¶à¤¿à¤•à¥à¤·à¤¾ à¤¦à¥€ à¤—à¤ˆ à¤¹à¥ˆà¥¤</p>
    
    <p class="consent-text hindi">à¤¯à¤¹ à¤œà¤¾à¤¨à¤•à¤¾à¤°à¥€ à¤®à¥à¤à¥‡ à¤®à¥‡à¤°à¥€ à¤¸à¤®à¤ à¤•à¥€ à¤­à¤¾à¤·à¤¾ à¤®à¥‡à¤‚ à¤¦à¥€ à¤—à¤ˆ à¤¹à¥ˆà¥¤ à¤®à¥à¤à¥‡ à¤ªà¥à¤°à¤¶à¥à¤¨ à¤ªà¥‚à¤›à¤¨à¥‡ à¤•à¤¾ à¤…à¤µà¤¸à¤° à¤¦à¤¿à¤¯à¤¾ à¤—à¤¯à¤¾ à¤”à¤° à¤®à¥‡à¤°à¥‡ à¤¸à¤­à¥€ à¤ªà¥à¤°à¤¶à¥à¤¨à¥‹à¤‚ à¤•à¥‡ à¤‰à¤¤à¥à¤¤à¤° à¤¦à¤¿à¤ à¤—à¤à¥¤</p>
    
    <p class="consent-text hindi">à¤®à¥ˆà¤‚ à¤¸à¤®à¤à¤¤à¤¾/à¤¸à¤®à¤à¤¤à¥€ à¤¹à¥‚à¤ à¤•à¤¿ à¤®à¥‡à¤°à¥‡ à¤ªà¤°à¤¾à¤®à¤°à¥à¤¶ à¤•à¤¾ à¤µà¤¿à¤µà¤°à¤£ à¤…à¤¸à¥à¤ªà¤¤à¤¾à¤² à¤ªà¥à¤°à¤£à¤¾à¤²à¥€ à¤®à¥‡à¤‚ à¤¦à¤°à¥à¤œ à¤•à¤¿à¤¯à¤¾ à¤œà¤¾à¤à¤—à¤¾ à¤”à¤° à¤‡à¤¸à¤•à¤¾ à¤‰à¤ªà¤¯à¥‹à¤— <strong>à¤‰à¤ªà¤šà¤¾à¤° à¤¨à¤¿à¤°à¤‚à¤¤à¤°à¤¤à¤¾</strong>, <strong>à¤•à¤¾à¤¨à¥‚à¤¨à¥€ à¤†à¤µà¤¶à¥à¤¯à¤•à¤¤à¤¾à¤“à¤‚</strong> à¤à¤µà¤‚ <strong>à¤®à¥‡à¤¡à¤¿à¤•à¤² à¤°à¤¿à¤•à¥‰à¤°à¥à¤¡</strong> à¤¹à¥‡à¤¤à¥ à¤•à¤¿à¤¯à¤¾ à¤œà¤¾à¤à¤—à¤¾à¥¤ à¤®à¥‡à¤°à¥€ à¤µà¥à¤¯à¤•à¥à¤¤à¤¿à¤—à¤¤ à¤œà¤¾à¤¨à¤•à¤¾à¤°à¥€ <strong>à¤—à¥‹à¤ªà¤¨à¥€à¤¯</strong> à¤°à¤–à¥€ à¤œà¤¾à¤à¤—à¥€à¥¤</p>
    
    <p class="consent-text hindi"><strong>à¤®à¥ˆà¤‚ à¤°à¥‹à¤—à¥€ à¤ªà¤°à¤¾à¤®à¤°à¥à¤¶, à¤¶à¤¿à¤•à¥à¤·à¤¾ à¤à¤µà¤‚ à¤ªà¥à¤°à¤²à¥‡à¤–à¤¨ à¤•à¥‡ à¤²à¤¿à¤ à¤…à¤ªà¤¨à¥€ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¤¾ à¤¸à¥‡ à¤¸à¤¹à¤®à¤¤à¤¿ à¤¦à¥‡à¤¤à¤¾/à¤¦à¥‡à¤¤à¥€ à¤¹à¥‚à¤à¥¤</strong></p>
  </div>
  
  <div class="declaration">
    <div class="declaration-title hindi">à¤˜à¥‹à¤·à¤£à¤¾</div>
    <p class="consent-text hindi">à¤‰à¤ªà¤°à¥‹à¤•à¥à¤¤ à¤¸à¤­à¥€ à¤œà¤¾à¤¨à¤•à¤¾à¤°à¥€ à¤¹à¤®à¥‡à¤‚ à¤¸à¥à¤ªà¤·à¥à¤Ÿ à¤°à¥‚à¤ª à¤¸à¥‡ à¤¸à¤®à¤à¤¾à¤ˆ à¤—à¤ˆ à¤¹à¥ˆà¥¤ à¤¹à¤® à¤¬à¤¿à¤¨à¤¾ à¤•à¤¿à¤¸à¥€ à¤¦à¤¬à¤¾à¤µ à¤•à¥‡ à¤¯à¤¹ à¤¸à¤¹à¤®à¤¤à¤¿ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¤¾ à¤¸à¥‡ à¤ªà¥à¤°à¤¦à¤¾à¤¨ à¤•à¤° à¤°à¤¹à¥‡ à¤¹à¥ˆà¤‚à¥¤</p>
  </div>
  
  <div class="signature-section">
    <div class="signature-row">
      <div class="signature-item">
        <div class="signature-field hindi">à¤ªà¤°à¤¿à¤œà¤¨ à¤•à¤¾ à¤¨à¤¾à¤®: ______________________________</div>
        <div class="signature-field hindi">à¤°à¥‹à¤—à¥€ à¤¸à¥‡ à¤¸à¤‚à¤¬à¤‚à¤§: ______________________________</div>
        <div class="signature-line"></div>
        <div class="signature-label hindi">à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤° / à¤…à¤‚à¤—à¥‚à¤ à¤¾ à¤¨à¤¿à¤¶à¤¾à¤¨</div>
        <div class="signature-field hindi">à¤¦à¤¿à¤¨à¤¾à¤‚à¤•: ____ / ____ / ______</div>
      </div>
      <div class="signature-item">
        <div class="signature-field hindi">à¤¡à¥‰à¤•à¥à¤Ÿà¤° à¤•à¤¾ à¤¨à¤¾à¤®: ______________________________</div>
        <div class="signature-field hindi">à¤ªà¤¦à¤¨à¤¾à¤®: ______________________________</div>
        <div class="signature-line"></div>
        <div class="signature-label hindi">à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div>
      </div>
    </div>
  </div>
</div>

</body>
</html>`;
          
          res.setHeader('Content-Type', 'text/html; charset=utf-8');
          return res.send(htmlContent);
        }
        

        // ========== 2. Patient Education Consent ==========
        if (consentType === 'PATIENT_EDUCATION') {
          const patientName = patient ? `${patient.firstName} ${patient.lastName}` : '__________';
          const patientAge = patient?.dateOfBirth ? calculateAge(patient.dateOfBirth) : '__________';
          const patientGender = patient?.gender || '__________';
          const patientUhid = patient?.uhidNumber || patient?.id?.substring(0, 8).toUpperCase() || '__________';
          const currentDate = new Date().toLocaleDateString('en-IN', { day: '2-digit', month: '2-digit', year: 'numeric' });
          
          const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Patient Education Consent</title>
  <style>
    @page { size: A4; margin: 15mm; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Arial, sans-serif; font-size: 11pt; line-height: 1.6; color: #333; }
    .page { width: 210mm; min-height: 297mm; padding: 15mm; margin: 10mm auto; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); page-break-after: always; }
    .page:last-child { page-break-after: auto; }
    .hospital-header { display: flex; align-items: center; gap: 20px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid #4a2683; }
    .logo-section { display: flex; align-items: center; }
    .hospital-logo { height: 50px; width: auto; }
    .hospital-info { flex: 1; }
    .hospital-name { font-size: 16pt; font-weight: bold; color: #2c5aa0; margin-bottom: 2px; }
    .hospital-address { font-size: 9pt; color: #666; }
    .hospital-contact { font-size: 9pt; color: #333; font-weight: bold; }
    .form-title { text-align: center; font-size: 16pt; font-weight: bold; margin: 20px 0; color: #333; }
    .form-title-icon { font-size: 20pt; }
    .patient-info-box { border: 1px solid #333; padding: 10px; margin: 15px 0; background: #f9f9f9; display: flex; flex-wrap: wrap; gap: 15px; }
    .patient-info-item { font-size: 10pt; min-width: 150px; }
    .patient-label { font-weight: bold; }
    .dept-date-row { display: flex; justify-content: space-between; margin: 15px 0; font-size: 11pt; }
    .section { margin: 20px 0; }
    .section-title { font-size: 12pt; font-weight: bold; color: #2c5aa0; margin-bottom: 10px; padding: 8px 12px; background: transparent; display: flex; align-items: center; gap: 10px; }
    .section-title::before { content: ""; display: inline-block; width: 14px; height: 14px; background: #2c5aa0; flex-shrink: 0; }
    .section-content { text-align: justify; margin: 10px 0; font-size: 11pt; line-height: 1.8; padding-left: 15px; }
    .declaration { margin: 25px 0; padding: 15px; border: 2px solid #4a2683; background: #fafafa; }
    .declaration-title { font-weight: bold; font-size: 12pt; margin-bottom: 10px; }
    .signature-grid { margin-top: 30px; }
    .signature-row { display: flex; justify-content: space-between; margin: 15px 0; }
    .signature-field { font-size: 10pt; }
    .signature-line { border-bottom: 1px solid #333; min-width: 200px; display: inline-block; margin-left: 10px; }
  </style>
</head>
<body>

<!-- English Page -->
<div class="page">
  <div class="hospital-header">
    <div class="logo-section">
      <img src="${hospitalLogoBase64}" alt="Gravity Hospital Logo" class="hospital-logo">
    </div>
    <div class="hospital-info">
      <div class="hospital-name">Gravity Hospital & Research Centre</div>
      <div class="hospital-address">Gat No. 167, Sahyog Nagar, Triveni Nagar Chowk,<br>Pimpri-Chinchwad, Maharashtra - 411062</div>
      <div class="hospital-contact">Contact: 7796513130, 7769651310</div>
    </div>
  </div>
  
  <div class="form-title"><span class="form-title-icon">ðŸ¥</span> PATIENT EDUCATION CONSENT</div>
  
  <div class="patient-info-box">
    <span class="patient-info-item"><span class="patient-label">Patient Name:</span> ${patientName}</span>
    <span class="patient-info-item"><span class="patient-label">UHID No:</span> ${patientUhid}</span>
    <span class="patient-info-item"><span class="patient-label">Gender:</span> ${patientGender}</span>
    <span class="patient-info-item"><span class="patient-label">Age:</span> ${patientAge} years</span>
  </div>
  
  <div class="dept-date-row">
    <span>Department: _____________________</span>
    <span>Date: ____ / ____ / ______</span>
  </div>

  <div class="section">
    <div class="section-title">1. HEALTH EDUCATION ACKNOWLEDGEMENT</div>
    <div class="section-content">
      I acknowledge that I have been educated about my health condition, disease process, preventive measures, medication schedule, dietary advice, physical activity, and warning signs requiring medical attention.<br><br>
      I understand that patient education is essential for better health outcomes and recovery.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. TREATMENT COMPLIANCE</div>
    <div class="section-content">
      I agree to follow the instructions provided by the healthcare team regarding medications, lifestyle modifications, and follow-up visits.<br><br>
      I understand the importance of adherence to the prescribed treatment plan.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. CONSENT FOR EDUCATION</div>
    <div class="section-content">
      I give my consent for the hospital to provide ongoing health education and documentation of the same as required by hospital policies.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">DECLARATION</div>
    We confirm that all the above information has been explained to us clearly.<br>
    We have understood the same and have given this consent voluntarily, without any pressure.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">Relative / Attendant Name: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Relationship with Patient: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Signature / Thumb Impression: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Marathi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. à¤†à¤°à¥‹à¤—à¥à¤¯ à¤¶à¤¿à¤•à¥à¤·à¤£ à¤ªà¤¾à¤µà¤¤à¥€</div>
    <div class="section-content">
      à¤®à¤¾à¤à¥à¤¯à¤¾ à¤†à¤°à¥‹à¤—à¥à¤¯ à¤¸à¥à¤¥à¤¿à¤¤à¥€à¤¬à¤¾à¤¬à¤¤, à¤†à¤œà¤¾à¤°à¤¾à¤šà¥€ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾, à¤ªà¥à¤°à¤¤à¤¿à¤¬à¤‚à¤§à¤¾à¤¤à¥à¤®à¤• à¤‰à¤ªà¤¾à¤¯, à¤”à¤·à¤§à¤¾à¤‚à¤šà¥‡ à¤µà¥‡à¤³à¤¾à¤ªà¤¤à¥à¤°à¤•, à¤†à¤¹à¤¾à¤° à¤¸à¤²à¥à¤²à¤¾, à¤¶à¤¾à¤°à¥€à¤°à¤¿à¤• à¤¹à¤¾à¤²à¤šà¤¾à¤² à¤µ à¤§à¥‹à¤•à¥à¤¯à¤¾à¤šà¥€ à¤²à¤•à¥à¤·à¤£à¥‡ à¤¯à¤¾à¤¬à¤¾à¤¬à¤¤ à¤®à¤²à¤¾ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤¦à¥‡à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤¹à¥‡.<br><br>
      à¤°à¥à¤—à¥à¤£ à¤¶à¤¿à¤•à¥à¤·à¤£à¤¾à¤®à¥à¤³à¥‡ à¤†à¤°à¥‹à¤—à¥à¤¯ à¤¸à¥à¤§à¤¾à¤°à¤£à¥à¤¯à¤¾à¤¸ à¤®à¤¦à¤¤ à¤¹à¥‹à¤¤à¥‡, à¤¹à¥‡ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤²à¥‡ à¤†à¤¹à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. à¤‰à¤ªà¤šà¤¾à¤° à¤ªà¤¾à¤²à¤¨</div>
    <div class="section-content">
      à¤”à¤·à¤§à¥‡, à¤œà¥€à¤µà¤¨à¤¶à¥ˆà¤²à¥€à¤¤à¥€à¤² à¤¬à¤¦à¤² à¤µ à¤«à¥‰à¤²à¥‹-à¤…à¤ª à¤­à¥‡à¤Ÿà¥€à¤‚à¤¬à¤¾à¤¬à¤¤ à¤†à¤°à¥‹à¤—à¥à¤¯ à¤•à¤°à¥à¤®à¤šà¤¾à¤±à¥à¤¯à¤¾à¤‚à¤¨à¥€ à¤¦à¤¿à¤²à¥‡à¤²à¥à¤¯à¤¾ à¤¸à¥‚à¤šà¤¨à¤¾à¤‚à¤šà¥‡ à¤ªà¤¾à¤²à¤¨ à¤•à¤°à¤£à¥à¤¯à¤¾à¤¸ à¤®à¥€ à¤¸à¤¹à¤®à¤¤ à¤†à¤¹à¥‡.<br><br>
      à¤¦à¤¿à¤²à¥‡à¤²à¥à¤¯à¤¾ à¤‰à¤ªà¤šà¤¾à¤° à¤¯à¥‹à¤œà¤¨à¥‡à¤šà¥‡ à¤ªà¤¾à¤²à¤¨ à¤•à¤°à¤£à¥à¤¯à¤¾à¤šà¥‡ à¤®à¤¹à¤¤à¥à¤¤à¥à¤µ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤²à¥‡ à¤†à¤¹à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. à¤¶à¤¿à¤•à¥à¤·à¤£ à¤¸à¤‚à¤®à¤¤à¥€</div>
    <div class="section-content">
      à¤°à¥à¤—à¥à¤£à¤¾à¤²à¤¯à¤¾à¤šà¥à¤¯à¤¾ à¤§à¥‹à¤°à¤£à¤¾à¤‚à¤¨à¥à¤¸à¤¾à¤° à¤†à¤°à¥‹à¤—à¥à¤¯ à¤¶à¤¿à¤•à¥à¤·à¤£ à¤µ à¤¤à¥à¤¯à¤¾à¤šà¥‡ à¤¦à¤¸à¥à¤¤à¤à¤µà¤œà¥€à¤•à¤°à¤£ à¤•à¤°à¤£à¥à¤¯à¤¾à¤¸ à¤®à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¦à¥‡à¤¤à¥‹/à¤¦à¥‡à¤¤à¥‡.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">à¤œà¤¾à¤¹à¥€à¤°à¤¨à¤¾à¤®à¤¾</div>
    à¤µà¤°à¥€à¤² à¤¸à¤°à¥à¤µ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤†à¤®à¥à¤¹à¤¾à¤²à¤¾ à¤¸à¥à¤ªà¤·à¥à¤Ÿà¤ªà¤£à¥‡ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤¹à¥‡.<br>
    à¤•à¥‹à¤£à¤¤à¤¾à¤¹à¥€ à¤¦à¤¬à¤¾à¤µ à¤¨ à¤†à¤£à¤¤à¤¾ à¤†à¤®à¥à¤¹à¥€ à¤¹à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¥‡à¤¨à¥‡ à¤¦à¥‡à¤¤ à¤†à¤¹à¥‹à¤¤.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">à¤¨à¤¾à¤¤à¤²à¤—à¤¾à¤šà¥‡ à¤¨à¤¾à¤µ: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤°à¥à¤—à¥à¤£à¤¾à¤¶à¥€ à¤¨à¤¾à¤¤à¥‡: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€ / à¤…à¤‚à¤—à¤ à¤¾: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Hindi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. ELIGIBILITY DECLARATION</div>
    <div class="section-content">
      I declare that I am eligible under the MJPJAY (Mahatma Jyotiba Phule Jan Arogya Yojana) scheme and have submitted correct and complete documents as required.<br><br>
      I understand the terms and conditions of the scheme and confirm that all information provided is accurate.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. AUTHORIZATION</div>
    <div class="section-content">
      I authorize the hospital to upload my medical details and submit claims as per scheme guidelines.<br><br>
      I understand that any discrepancy in documents may lead to claim rejection, and non-covered expenses shall be borne by me.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. CONSENT FOR PROCESSING</div>
    <div class="section-content">
      I give my consent for the hospital to process my claim under MJPJAY scheme and share necessary medical information with scheme authorities.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">DECLARATION</div>
    We confirm that all the above information has been explained to us clearly.<br>
    We have understood the same and have given this consent voluntarily, without any pressure.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">Relative / Attendant Name: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Relationship with Patient: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Signature / Thumb Impression: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Marathi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. à¤ªà¤¾à¤¤à¥à¤°à¤¤à¤¾ à¤˜à¥‹à¤·à¤£à¤¾</div>
    <div class="section-content">
      à¤®à¥€ MJPJAY (à¤®à¤¹à¤¾à¤¤à¥à¤®à¤¾ à¤œà¥à¤¯à¥‹à¤¤à¤¿à¤¬à¤¾ à¤«à¥à¤²à¥‡ à¤œà¤¨ à¤†à¤°à¥‹à¤—à¥à¤¯ à¤¯à¥‹à¤œà¤¨à¤¾) à¤¯à¥‹à¤œà¤¨à¥‡à¤¸ à¤ªà¤¾à¤¤à¥à¤° à¤…à¤¸à¥‚à¤¨ à¤†à¤µà¤¶à¥à¤¯à¤• à¤•à¤¾à¤—à¤¦à¤ªà¤¤à¥à¤°à¥‡ à¤¯à¥‹à¤—à¥à¤¯à¤°à¥€à¤¤à¥à¤¯à¤¾ à¤¸à¤¾à¤¦à¤° à¤•à¥‡à¤²à¥€ à¤†à¤¹à¥‡à¤¤, à¤…à¤¸à¥‡ à¤˜à¥‹à¤·à¤¿à¤¤ à¤•à¤°à¤¤à¥‹/à¤•à¤°à¤¤à¥‡.<br><br>
      à¤¯à¥‹à¤œà¤¨à¥‡à¤šà¥à¤¯à¤¾ à¤…à¤Ÿà¥€ à¤µ à¤¶à¤°à¥à¤¤à¥€ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤²à¥à¤¯à¤¾ à¤…à¤¸à¥‚à¤¨ à¤¦à¤¿à¤²à¥‡à¤²à¥€ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤¸à¤¤à¥à¤¯ à¤†à¤¹à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. à¤…à¤§à¤¿à¤•à¥ƒà¤¤à¤¤à¤¾</div>
    <div class="section-content">
      à¤°à¥à¤—à¥à¤£à¤¾à¤²à¤¯à¤¾à¤¸ à¤¯à¥‹à¤œà¤¨à¥‡à¤¨à¥à¤¸à¤¾à¤° à¤®à¤¾à¤à¥€ à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤…à¤ªà¤²à¥‹à¤¡ à¤µ à¤¦à¤¾à¤µà¤¾ à¤¸à¤¾à¤¦à¤° à¤•à¤°à¤£à¥à¤¯à¤¾à¤šà¥€ à¤®à¥€ à¤ªà¤°à¤µà¤¾à¤¨à¤—à¥€ à¤¦à¥‡à¤¤à¥‹/à¤¦à¥‡à¤¤à¥‡.<br><br>
      à¤•à¤¾à¤—à¤¦à¤ªà¤¤à¥à¤°à¤¾à¤‚à¤¤à¥€à¤² à¤¤à¥à¤°à¥à¤Ÿà¥€à¤®à¥à¤³à¥‡ à¤¦à¤¾à¤µà¤¾ à¤¨à¤¾à¤•à¤¾à¤°à¤²à¥à¤¯à¤¾à¤¸ à¤¤à¥à¤¯à¤¾à¤šà¥€ à¤œà¤¬à¤¾à¤¬à¤¦à¤¾à¤°à¥€ à¤®à¤¾à¤à¥€ à¤°à¤¾à¤¹à¥€à¤².
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¥‡à¤¸à¤¾à¤ à¥€ à¤¸à¤‚à¤®à¤¤à¥€</div>
    <div class="section-content">
      MJPJAY à¤¯à¥‹à¤œà¤¨à¥‡à¤…à¤‚à¤¤à¤°à¥à¤—à¤¤ à¤®à¤¾à¤à¤¾ à¤¦à¤¾à¤µà¤¾ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¥‡à¤¸à¤¾à¤ à¥€ à¤µ à¤¯à¥‹à¤œà¤¨à¤¾ à¤…à¤§à¤¿à¤•à¤¾à¤±à¥à¤¯à¤¾à¤‚à¤¨à¤¾ à¤†à¤µà¤¶à¥à¤¯à¤• à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤¦à¥‡à¤£à¥à¤¯à¤¾à¤¸à¤¾à¤ à¥€ à¤°à¥à¤—à¥à¤£à¤¾à¤²à¤¯à¤¾à¤¸ à¤…à¤§à¤¿à¤•à¥ƒà¤¤ à¤•à¤°à¤¤à¥‹/à¤•à¤°à¤¤à¥‡.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">à¤œà¤¾à¤¹à¥€à¤°à¤¨à¤¾à¤®à¤¾</div>
    à¤µà¤°à¥€à¤² à¤¸à¤°à¥à¤µ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤†à¤®à¥à¤¹à¤¾à¤²à¤¾ à¤¸à¥à¤ªà¤·à¥à¤Ÿà¤ªà¤£à¥‡ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤¹à¥‡.<br>
    à¤•à¥‹à¤£à¤¤à¤¾à¤¹à¥€ à¤¦à¤¬à¤¾à¤µ à¤¨ à¤†à¤£à¤¤à¤¾ à¤†à¤®à¥à¤¹à¥€ à¤¹à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¥‡à¤¨à¥‡ à¤¦à¥‡à¤¤ à¤†à¤¹à¥‹à¤¤.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">à¤¨à¤¾à¤¤à¤²à¤—à¤¾à¤šà¥‡ à¤¨à¤¾à¤µ: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤°à¥à¤—à¥à¤£à¤¾à¤¶à¥€ à¤¨à¤¾à¤¤à¥‡: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€ / à¤…à¤‚à¤—à¤ à¤¾: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Hindi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. PROCEDURE INFORMATION</div>
    <div class="section-content">
      I have been explained the nature, purpose, benefits, and possible risks of the proposed medical procedure.<br><br>
      I understand that no guarantee of outcome has been given and that results may vary.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. RISKS AND COMPLICATIONS</div>
    <div class="section-content">
      I understand that all medical procedures carry some risks and potential complications.<br><br>
      I voluntarily consent to undergo the procedure with full understanding of potential complications.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. CONSENT FOR PROCEDURE</div>
    <div class="section-content">
      I give my consent for the medical team to perform the procedure and any additional procedures that may be necessary during the course of treatment.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">DECLARATION</div>
    We confirm that all the above information has been explained to us clearly.<br>
    We have understood the same and have given this consent voluntarily, without any pressure.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">Relative / Attendant Name: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Relationship with Patient: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Signature / Thumb Impression: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Marathi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤®à¤¾à¤¹à¤¿à¤¤à¥€</div>
    <div class="section-content">
      à¤ªà¥à¤°à¤¸à¥à¤¤à¤¾à¤µà¤¿à¤¤ à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¥‡à¤šà¥‡ à¤¸à¥à¤µà¤°à¥‚à¤ª, à¤‰à¤¦à¥à¤¦à¥‡à¤¶, à¤«à¤¾à¤¯à¤¦à¥‡ à¤µ à¤¸à¤‚à¤­à¤¾à¤µà¥à¤¯ à¤§à¥‹à¤•à¥‡ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥‡ à¤†à¤¹à¥‡à¤¤.<br><br>
      à¤•à¥‹à¤£à¤¤à¥€à¤¹à¥€ à¤ªà¤°à¤¿à¤£à¤¾à¤®à¤¾à¤šà¥€ à¤¹à¤®à¥€ à¤¦à¥‡à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥‡à¤²à¥€ à¤¨à¤¾à¤¹à¥€ à¤µ à¤ªà¤°à¤¿à¤£à¤¾à¤® à¤¬à¤¦à¤²à¥‚ à¤¶à¤•à¤¤à¤¾à¤¤, à¤¹à¥‡ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤²à¥‡ à¤†à¤¹à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. à¤§à¥‹à¤•à¥‡ à¤†à¤£à¤¿ à¤—à¥à¤‚à¤¤à¤¾à¤—à¥à¤‚à¤¤</div>
    <div class="section-content">
      à¤¸à¤°à¥à¤µ à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾à¤‚à¤®à¤§à¥à¤¯à¥‡ à¤•à¤¾à¤¹à¥€ à¤§à¥‹à¤•à¥‡ à¤µ à¤¸à¤‚à¤­à¤¾à¤µà¥à¤¯ à¤—à¥à¤‚à¤¤à¤¾à¤—à¥à¤‚à¤¤ à¤…à¤¸à¤¤à¤¾à¤¤, à¤¹à¥‡ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤²à¥‡ à¤†à¤¹à¥‡.<br><br>
      à¤ªà¥‚à¤°à¥à¤£ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤˜à¥‡à¤Šà¤¨ à¤®à¥€ à¤¯à¤¾ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¥‡à¤¸ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¥‡à¤¨à¥‡ à¤¸à¤‚à¤®à¤¤à¥€ à¤¦à¥‡à¤¤à¥‹/à¤¦à¥‡à¤¤à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¥‡à¤¸à¤¾à¤ à¥€ à¤¸à¤‚à¤®à¤¤à¥€</div>
    <div class="section-content">
      à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤ªà¤¾à¤° à¤ªà¤¾à¤¡à¤£à¥à¤¯à¤¾à¤¸à¤¾à¤ à¥€ à¤µ à¤‰à¤ªà¤šà¤¾à¤°à¤¾à¤¦à¤°à¤®à¥à¤¯à¤¾à¤¨ à¤†à¤µà¤¶à¥à¤¯à¤• à¤…à¤¸à¤²à¥à¤¯à¤¾à¤¸ à¤…à¤¤à¤¿à¤°à¤¿à¤•à¥à¤¤ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾à¤‚à¤¸à¤¾à¤ à¥€ à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯ à¤Ÿà¥€à¤®à¤²à¤¾ à¤®à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¦à¥‡à¤¤à¥‹/à¤¦à¥‡à¤¤à¥‡.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">à¤œà¤¾à¤¹à¥€à¤°à¤¨à¤¾à¤®à¤¾</div>
    à¤µà¤°à¥€à¤² à¤¸à¤°à¥à¤µ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤†à¤®à¥à¤¹à¤¾à¤²à¤¾ à¤¸à¥à¤ªà¤·à¥à¤Ÿà¤ªà¤£à¥‡ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤¹à¥‡.<br>
    à¤•à¥‹à¤£à¤¤à¤¾à¤¹à¥€ à¤¦à¤¬à¤¾à¤µ à¤¨ à¤†à¤£à¤¤à¤¾ à¤†à¤®à¥à¤¹à¥€ à¤¹à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¥‡à¤¨à¥‡ à¤¦à¥‡à¤¤ à¤†à¤¹à¥‹à¤¤.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">à¤¨à¤¾à¤¤à¤²à¤—à¤¾à¤šà¥‡ à¤¨à¤¾à¤µ: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤°à¥à¤—à¥à¤£à¤¾à¤¶à¥€ à¤¨à¤¾à¤¤à¥‡: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€ / à¤…à¤‚à¤—à¤ à¤¾: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Hindi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. FITNESS EXAMINATION CONSENT</div>
    <div class="section-content">
      I consent to undergo medical examination for assessment of my physical and mental fitness.<br><br>
      I declare that all information provided by me is true and complete to the best of my knowledge.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. CERTIFICATE ISSUANCE</div>
    <div class="section-content">
      I understand that the fitness certificate will be issued based on clinical findings and medical evaluation.<br><br>
      I acknowledge that the certificate reflects my current health status at the time of examination.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. INFORMATION ACCURACY</div>
    <div class="section-content">
      I confirm that I have disclosed all relevant medical history and conditions that may affect the fitness assessment.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">DECLARATION</div>
    We confirm that all the above information has been explained to us clearly.<br>
    We have understood the same and have given this consent voluntarily, without any pressure.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">Relative / Attendant Name: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Relationship with Patient: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Signature / Thumb Impression: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Marathi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. à¤«à¤¿à¤Ÿà¤¨à¥‡à¤¸ à¤¤à¤ªà¤¾à¤¸à¤£à¥€ à¤¸à¤‚à¤®à¤¤à¥€</div>
    <div class="section-content">
      à¤®à¤¾à¤à¥à¤¯à¤¾ à¤¶à¤¾à¤°à¥€à¤°à¤¿à¤• à¤µ à¤®à¤¾à¤¨à¤¸à¤¿à¤• à¤¤à¤‚à¤¦à¥à¤°à¥à¤¸à¥à¤¤à¥€à¤šà¥à¤¯à¤¾ à¤¤à¤ªà¤¾à¤¸à¤£à¥€à¤¸à¤¾à¤ à¥€ à¤®à¥€ à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯ à¤¤à¤ªà¤¾à¤¸à¤£à¥€à¤¸ à¤¸à¤‚à¤®à¤¤à¥€ à¤¦à¥‡à¤¤à¥‹/à¤¦à¥‡à¤¤à¥‡.<br><br>
      à¤®à¥€ à¤¦à¤¿à¤²à¥‡à¤²à¥€ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤¸à¤¤à¥à¤¯ à¤µ à¤ªà¥‚à¤°à¥à¤£ à¤†à¤¹à¥‡, à¤¹à¥‡ à¤®à¥€ à¤ªà¥à¤°à¤®à¤¾à¤£à¤¿à¤¤ à¤•à¤°à¤¤à¥‹/à¤•à¤°à¤¤à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. à¤ªà¥à¤°à¤®à¤¾à¤£à¤ªà¤¤à¥à¤° à¤œà¤¾à¤°à¥€ à¤•à¤°à¤£à¥‡</div>
    <div class="section-content">
      à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯ à¤¤à¤ªà¤¾à¤¸à¤£à¥€à¤šà¥à¤¯à¤¾ à¤¨à¤¿à¤·à¥à¤•à¤°à¥à¤·à¤¾à¤‚à¤¨à¥à¤¸à¤¾à¤° à¤«à¤¿à¤Ÿà¤¨à¥‡à¤¸ à¤ªà¥à¤°à¤®à¤¾à¤£à¤ªà¤¤à¥à¤° à¤¦à¤¿à¤²à¥‡ à¤œà¤¾à¤ˆà¤², à¤¹à¥‡ à¤®à¤²à¤¾ à¤®à¤¾à¤¨à¥à¤¯ à¤†à¤¹à¥‡.<br><br>
      à¤¤à¤ªà¤¾à¤¸à¤£à¥€ à¤µà¥‡à¤³à¥€ à¤®à¤¾à¤à¥à¤¯à¤¾ à¤¸à¤§à¥à¤¯à¤¾à¤šà¥à¤¯à¤¾ à¤†à¤°à¥‹à¤—à¥à¤¯ à¤¸à¥à¤¥à¤¿à¤¤à¥€à¤šà¥‡ à¤ªà¥à¤°à¤®à¤¾à¤£à¤ªà¤¤à¥à¤° à¤ªà¥à¤°à¤¤à¤¿à¤¬à¤¿à¤‚à¤¬à¤¿à¤¤ à¤•à¤°à¤¤à¥‡, à¤¹à¥‡ à¤®à¥€ à¤®à¤¾à¤¨à¥à¤¯ à¤•à¤°à¤¤à¥‹/à¤•à¤°à¤¤à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. à¤®à¤¾à¤¹à¤¿à¤¤à¥€à¤šà¥€ à¤…à¤šà¥‚à¤•à¤¤à¤¾</div>
    <div class="section-content">
      à¤«à¤¿à¤Ÿà¤¨à¥‡à¤¸ à¤®à¥‚à¤²à¥à¤¯à¤¾à¤‚à¤•à¤¨à¤¾à¤µà¤° à¤ªà¤°à¤¿à¤£à¤¾à¤® à¤•à¤°à¤£à¤¾à¤±à¥à¤¯à¤¾ à¤¸à¤°à¥à¤µ à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯ à¤‡à¤¤à¤¿à¤¹à¤¾à¤¸ à¤µ à¤ªà¤°à¤¿à¤¸à¥à¤¥à¤¿à¤¤à¥€ à¤®à¥€ à¤‰à¤˜à¤¡ à¤•à¥‡à¤²à¥à¤¯à¤¾ à¤†à¤¹à¥‡à¤¤, à¤¹à¥‡ à¤®à¥€ à¤ªà¥à¤·à¥à¤Ÿà¥€ à¤•à¤°à¤¤à¥‹/à¤•à¤°à¤¤à¥‡.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">à¤œà¤¾à¤¹à¥€à¤°à¤¨à¤¾à¤®à¤¾</div>
    à¤µà¤°à¥€à¤² à¤¸à¤°à¥à¤µ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤†à¤®à¥à¤¹à¤¾à¤²à¤¾ à¤¸à¥à¤ªà¤·à¥à¤Ÿà¤ªà¤£à¥‡ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤¹à¥‡.<br>
    à¤•à¥‹à¤£à¤¤à¤¾à¤¹à¥€ à¤¦à¤¬à¤¾à¤µ à¤¨ à¤†à¤£à¤¤à¤¾ à¤†à¤®à¥à¤¹à¥€ à¤¹à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¥‡à¤¨à¥‡ à¤¦à¥‡à¤¤ à¤†à¤¹à¥‹à¤¤.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">à¤¨à¤¾à¤¤à¤²à¤—à¤¾à¤šà¥‡ à¤¨à¤¾à¤µ: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤°à¥à¤—à¥à¤£à¤¾à¤¶à¥€ à¤¨à¤¾à¤¤à¥‡: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€ / à¤…à¤‚à¤—à¤ à¤¾: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Hindi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. TREATMENT INFORMATION</div>
    <div class="section-content">
      I have been explained the nature of physiotherapy treatment, expected benefits, duration, and possible discomfort or soreness.<br><br>
      I understand that response to therapy may vary from person to person.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. THERAPY SESSIONS</div>
    <div class="section-content">
      I consent to physiotherapy sessions as advised by the therapist.<br><br>
      I understand the importance of regular attendance and compliance for optimal results.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. CONSENT FOR TREATMENT</div>
    <div class="section-content">
      I give my consent for the physiotherapist to perform the recommended treatment plan and make adjustments as necessary for my recovery.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">DECLARATION</div>
    We confirm that all the above information has been explained to us clearly.<br>
    We have understood the same and have given this consent voluntarily, without any pressure.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">Relative / Attendant Name: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Relationship with Patient: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Signature / Thumb Impression: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Marathi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. à¤‰à¤ªà¤šà¤¾à¤° à¤®à¤¾à¤¹à¤¿à¤¤à¥€</div>
    <div class="section-content">
      à¤«à¤¿à¤œà¤¿à¤“à¤¥à¥‡à¤°à¤ªà¥€ à¤‰à¤ªà¤šà¤¾à¤°à¤¾à¤šà¥‡ à¤¸à¥à¤µà¤°à¥‚à¤ª, à¤«à¤¾à¤¯à¤¦à¥‡, à¤•à¤¾à¤²à¤¾à¤µà¤§à¥€ à¤µ à¤¸à¤‚à¤­à¤¾à¤µà¥à¤¯ à¤µà¥‡à¤¦à¤¨à¤¾ à¤¯à¤¾à¤¬à¤¾à¤¬à¤¤ à¤®à¤²à¤¾ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤¦à¥‡à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤¹à¥‡.<br><br>
      à¤‰à¤ªà¤šà¤¾à¤°à¤¾à¤šà¤¾ à¤ªà¤°à¤¿à¤£à¤¾à¤® à¤µà¥à¤¯à¤•à¥à¤¤à¥€à¤¨à¥à¤¸à¤¾à¤° à¤¬à¤¦à¤²à¥‚ à¤¶à¤•à¤¤à¥‹, à¤¹à¥‡ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤²à¥‡ à¤†à¤¹à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. à¤¥à¥‡à¤°à¤ªà¥€ à¤¸à¤¤à¥à¤°à¥‡</div>
    <div class="section-content">
      à¤¥à¥‡à¤°à¤ªà¤¿à¤¸à¥à¤Ÿà¤¨à¥‡ à¤¸à¥à¤šà¤µà¤¿à¤²à¥‡à¤²à¥à¤¯à¤¾ à¤«à¤¿à¤œà¤¿à¤“à¤¥à¥‡à¤°à¤ªà¥€ à¤‰à¤ªà¤šà¤¾à¤°à¤¾à¤¸ à¤®à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¦à¥‡à¤¤à¥‹/à¤¦à¥‡à¤¤à¥‡.<br><br>
      à¤šà¤¾à¤‚à¤—à¤²à¥à¤¯à¤¾ à¤ªà¤°à¤¿à¤£à¤¾à¤®à¤¾à¤‚à¤¸à¤¾à¤ à¥€ à¤¨à¤¿à¤¯à¤®à¤¿à¤¤ à¤‰à¤ªà¤¸à¥à¤¥à¤¿à¤¤à¥€ à¤µ à¤ªà¤¾à¤²à¤¨ à¤†à¤µà¤¶à¥à¤¯à¤• à¤†à¤¹à¥‡, à¤¹à¥‡ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤²à¥‡ à¤†à¤¹à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. à¤‰à¤ªà¤šà¤¾à¤°à¤¾à¤‚à¤¸à¤¾à¤ à¥€ à¤¸à¤‚à¤®à¤¤à¥€</div>
    <div class="section-content">
      à¤¶à¤¿à¤«à¤¾à¤°à¤¸ à¤•à¥‡à¤²à¥‡à¤²à¥€ à¤‰à¤ªà¤šà¤¾à¤° à¤¯à¥‹à¤œà¤¨à¤¾ à¤°à¤¾à¤¬à¤µà¤¿à¤£à¥à¤¯à¤¾à¤¸à¤¾à¤ à¥€ à¤µ à¤®à¤¾à¤à¥à¤¯à¤¾ à¤¬à¤±à¥à¤¯à¤¾ à¤¹à¥‹à¤£à¥à¤¯à¤¾à¤¸à¤¾à¤ à¥€ à¤†à¤µà¤¶à¥à¤¯à¤• à¤¬à¤¦à¤² à¤•à¤°à¤£à¥à¤¯à¤¾à¤¸à¤¾à¤ à¥€ à¤«à¤¿à¤œà¤¿à¤“à¤¥à¥‡à¤°à¤ªà¤¿à¤¸à¥à¤Ÿà¤²à¤¾ à¤®à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¦à¥‡à¤¤à¥‹/à¤¦à¥‡à¤¤à¥‡.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">à¤œà¤¾à¤¹à¥€à¤°à¤¨à¤¾à¤®à¤¾</div>
    à¤µà¤°à¥€à¤² à¤¸à¤°à¥à¤µ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤†à¤®à¥à¤¹à¤¾à¤²à¤¾ à¤¸à¥à¤ªà¤·à¥à¤Ÿà¤ªà¤£à¥‡ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤¹à¥‡.<br>
    à¤•à¥‹à¤£à¤¤à¤¾à¤¹à¥€ à¤¦à¤¬à¤¾à¤µ à¤¨ à¤†à¤£à¤¤à¤¾ à¤†à¤®à¥à¤¹à¥€ à¤¹à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¥‡à¤¨à¥‡ à¤¦à¥‡à¤¤ à¤†à¤¹à¥‹à¤¤.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">à¤¨à¤¾à¤¤à¤²à¤—à¤¾à¤šà¥‡ à¤¨à¤¾à¤µ: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤°à¥à¤—à¥à¤£à¤¾à¤¶à¥€ à¤¨à¤¾à¤¤à¥‡: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€ / à¤…à¤‚à¤—à¤ à¤¾: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Hindi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. RECOVERY PLAN INFORMATION</div>
    <div class="section-content">
      I acknowledge that I have been informed about my recovery plan, medications, activity restrictions, and wound care instructions.<br><br>
      I understand the importance of following these instructions for proper healing.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. WARNING SIGNS AND FOLLOW-UP</div>
    <div class="section-content">
      I have been informed about warning signs that require immediate medical attention.<br><br>
      I understand and acknowledge my follow-up schedule and the importance of regular check-ups.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. COMPLIANCE ACKNOWLEDGEMENT</div>
    <div class="section-content">
      I commit to following all recovery instructions and contacting the hospital if any complications arise.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">DECLARATION</div>
    We confirm that all the above information has been explained to us clearly.<br>
    We have understood the same and have given this consent voluntarily, without any pressure.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">Relative / Attendant Name: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Relationship with Patient: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Signature / Thumb Impression: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Marathi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. à¤°à¤¿à¤•à¤µà¥à¤¹à¤°à¥€ à¤¯à¥‹à¤œà¤¨à¤¾ à¤®à¤¾à¤¹à¤¿à¤¤à¥€</div>
    <div class="section-content">
      à¤®à¤¾à¤à¥à¤¯à¤¾ à¤°à¤¿à¤•à¤µà¥à¤¹à¤°à¥€ à¤¯à¥‹à¤œà¤¨à¥‡à¤¬à¤¾à¤¬à¤¤, à¤”à¤·à¤§à¥‡, à¤¹à¤¾à¤²à¤šà¤¾à¤²à¥€à¤µà¤°à¥€à¤² à¤¨à¤¿à¤°à¥à¤¬à¤‚à¤§ à¤µ à¤œà¤–à¤®à¥‡à¤šà¥à¤¯à¤¾ à¤•à¤¾à¤³à¤œà¥€à¤¬à¤¾à¤¬à¤¤ à¤®à¤²à¤¾ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤¦à¥‡à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤¹à¥‡.<br><br>
      à¤¯à¥‹à¤—à¥à¤¯ à¤¬à¤°à¥‡ à¤¹à¥‹à¤£à¥à¤¯à¤¾à¤¸à¤¾à¤ à¥€ à¤¯à¤¾ à¤¸à¥‚à¤šà¤¨à¤¾à¤‚à¤šà¥‡ à¤ªà¤¾à¤²à¤¨ à¤†à¤µà¤¶à¥à¤¯à¤• à¤†à¤¹à¥‡, à¤¹à¥‡ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤²à¥‡ à¤†à¤¹à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. à¤§à¥‹à¤•à¥à¤¯à¤¾à¤šà¥€ à¤²à¤•à¥à¤·à¤£à¥‡ à¤†à¤£à¤¿ à¤«à¥‰à¤²à¥‹-à¤…à¤ª</div>
    <div class="section-content">
      à¤¤à¤¾à¤¤à¥à¤•à¤¾à¤³ à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯ à¤®à¤¦à¤¤ à¤†à¤µà¤¶à¥à¤¯à¤• à¤…à¤¸à¤²à¥‡à¤²à¥à¤¯à¤¾ à¤§à¥‹à¤•à¥à¤¯à¤¾à¤šà¥à¤¯à¤¾ à¤²à¤•à¥à¤·à¤£à¤¾à¤‚à¤¬à¤¾à¤¬à¤¤ à¤®à¤²à¤¾ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤¦à¥‡à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤¹à¥‡.<br><br>
      à¤®à¤¾à¤à¥‡ à¤«à¥‰à¤²à¥‹-à¤…à¤ª à¤µà¥‡à¤³à¤¾à¤ªà¤¤à¥à¤°à¤• à¤µ à¤¨à¤¿à¤¯à¤®à¤¿à¤¤ à¤¤à¤ªà¤¾à¤¸à¤£à¥€à¤šà¥‡ à¤®à¤¹à¤¤à¥à¤¤à¥à¤µ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤²à¥‡ à¤†à¤¹à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. à¤…à¤¨à¥à¤ªà¤¾à¤²à¤¨ à¤ªà¥‹à¤šà¤ªà¤¾à¤µà¤¤à¥€</div>
    <div class="section-content">
      à¤¸à¤°à¥à¤µ à¤°à¤¿à¤•à¤µà¥à¤¹à¤°à¥€ à¤¸à¥‚à¤šà¤¨à¤¾à¤‚à¤šà¥‡ à¤ªà¤¾à¤²à¤¨ à¤•à¤°à¤£à¥à¤¯à¤¾à¤šà¥€ à¤µ à¤•à¥‹à¤£à¤¤à¥à¤¯à¤¾à¤¹à¥€ à¤—à¥à¤‚à¤¤à¤¾à¤—à¥à¤‚à¤¤à¥€à¤šà¥à¤¯à¤¾ à¤ªà¤°à¤¿à¤¸à¥à¤¥à¤¿à¤¤à¥€à¤¤ à¤°à¥à¤—à¥à¤£à¤¾à¤²à¤¯à¤¾à¤¶à¥€ à¤¸à¤‚à¤ªà¤°à¥à¤• à¤¸à¤¾à¤§à¤£à¥à¤¯à¤¾à¤šà¥€ à¤®à¥€ à¤¹à¤®à¥€ à¤¦à¥‡à¤¤à¥‹/à¤¦à¥‡à¤¤à¥‡.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">à¤œà¤¾à¤¹à¥€à¤°à¤¨à¤¾à¤®à¤¾</div>
    à¤µà¤°à¥€à¤² à¤¸à¤°à¥à¤µ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤†à¤®à¥à¤¹à¤¾à¤²à¤¾ à¤¸à¥à¤ªà¤·à¥à¤Ÿà¤ªà¤£à¥‡ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤¹à¥‡.<br>
    à¤•à¥‹à¤£à¤¤à¤¾à¤¹à¥€ à¤¦à¤¬à¤¾à¤µ à¤¨ à¤†à¤£à¤¤à¤¾ à¤†à¤®à¥à¤¹à¥€ à¤¹à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¥‡à¤¨à¥‡ à¤¦à¥‡à¤¤ à¤†à¤¹à¥‹à¤¤.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">à¤¨à¤¾à¤¤à¤²à¤—à¤¾à¤šà¥‡ à¤¨à¤¾à¤µ: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤°à¥à¤—à¥à¤£à¤¾à¤¶à¥€ à¤¨à¤¾à¤¤à¥‡: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€ / à¤…à¤‚à¤—à¤ à¤¾: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Hindi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. PROCEDURE INFORMATION</div>
    <div class="section-content">
      I give my informed consent for the planned medical or surgical procedure after understanding its nature, benefits, risks, and alternatives.<br><br>
      I understand that possible complications may occur and outcomes cannot be guaranteed.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. AUTHORIZATION</div>
    <div class="section-content">
      I authorize the treating doctor and medical team to perform necessary procedures in my best interest.<br><br>
      I consent to any additional procedures that may be required during the course of treatment.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. CONSENT ACKNOWLEDGEMENT</div>
    <div class="section-content">
      I confirm that I have had the opportunity to ask questions and all my concerns have been addressed satisfactorily.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">DECLARATION</div>
    We confirm that all the above information has been explained to us clearly.<br>
    We have understood the same and have given this consent voluntarily, without any pressure.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">Relative / Attendant Name: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Relationship with Patient: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Signature / Thumb Impression: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Marathi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤®à¤¾à¤¹à¤¿à¤¤à¥€</div>
    <div class="section-content">
      à¤ªà¥à¤°à¤¸à¥à¤¤à¤¾à¤µà¤¿à¤¤ à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯/à¤¶à¤¸à¥à¤¤à¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¥‡à¤šà¥‡ à¤¸à¥à¤µà¤°à¥‚à¤ª, à¤«à¤¾à¤¯à¤¦à¥‡, à¤§à¥‹à¤•à¥‡ à¤µ à¤ªà¤°à¥à¤¯à¤¾à¤¯ à¤¸à¤®à¤œà¥‚à¤¨ à¤˜à¥‡à¤Šà¤¨ à¤®à¥€ à¤¸à¥à¤œà¤¾à¤£ à¤¸à¤‚à¤®à¤¤à¥€ à¤¦à¥‡à¤¤à¥‹/à¤¦à¥‡à¤¤à¥‡.<br><br>
      à¤¸à¤‚à¤­à¤¾à¤µà¥à¤¯ à¤—à¥à¤‚à¤¤à¤¾à¤—à¥à¤‚à¤¤ à¤¹à¥‹à¤Š à¤¶à¤•à¤¤à¥‡ à¤µ à¤ªà¤°à¤¿à¤£à¤¾à¤®à¤¾à¤‚à¤šà¥€ à¤¹à¤®à¥€ à¤¦à¥‡à¤¤à¤¾ à¤¯à¥‡à¤¤ à¤¨à¤¾à¤¹à¥€, à¤¹à¥‡ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤²à¥‡ à¤†à¤¹à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. à¤…à¤§à¤¿à¤•à¥ƒà¤¤à¤¤à¤¾</div>
    <div class="section-content">
      à¤®à¤¾à¤à¥à¤¯à¤¾ à¤¹à¤¿à¤¤à¤¾à¤¸à¤¾à¤ à¥€ à¤†à¤µà¤¶à¥à¤¯à¤• à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤•à¤°à¤£à¥à¤¯à¤¾à¤šà¥€ à¤ªà¤°à¤µà¤¾à¤¨à¤—à¥€ à¤®à¥€ à¤¡à¥‰à¤•à¥à¤Ÿà¤° à¤µ à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯ à¤ªà¤¥à¤•à¤¾à¤¸ à¤¦à¥‡à¤¤à¥‹/à¤¦à¥‡à¤¤à¥‡.<br><br>
      à¤‰à¤ªà¤šà¤¾à¤°à¤¾à¤¦à¤°à¤®à¥à¤¯à¤¾à¤¨ à¤†à¤µà¤¶à¥à¤¯à¤• à¤…à¤¸à¤²à¥à¤¯à¤¾à¤¸ à¤…à¤¤à¤¿à¤°à¤¿à¤•à¥à¤¤ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾à¤‚à¤¸à¤¾à¤ à¥€ à¤®à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¦à¥‡à¤¤à¥‹/à¤¦à¥‡à¤¤à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. à¤¸à¤‚à¤®à¤¤à¥€ à¤ªà¥‹à¤šà¤ªà¤¾à¤µà¤¤à¥€</div>
    <div class="section-content">
      à¤®à¤²à¤¾ à¤ªà¥à¤°à¤¶à¥à¤¨ à¤µà¤¿à¤šà¤¾à¤°à¤£à¥à¤¯à¤¾à¤šà¥€ à¤¸à¤‚à¤§à¥€ à¤®à¤¿à¤³à¤¾à¤²à¥€ à¤µ à¤®à¤¾à¤à¥à¤¯à¤¾ à¤¸à¤°à¥à¤µ à¤¶à¤‚à¤•à¤¾à¤‚à¤šà¥‡ à¤¸à¤®à¤¾à¤§à¤¾à¤¨à¤•à¤¾à¤°à¤• à¤‰à¤¤à¥à¤¤à¤° à¤®à¤¿à¤³à¤¾à¤²à¥‡, à¤¹à¥‡ à¤®à¥€ à¤ªà¥à¤·à¥à¤Ÿà¥€ à¤•à¤°à¤¤à¥‹/à¤•à¤°à¤¤à¥‡.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">à¤œà¤¾à¤¹à¥€à¤°à¤¨à¤¾à¤®à¤¾</div>
    à¤µà¤°à¥€à¤² à¤¸à¤°à¥à¤µ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤†à¤®à¥à¤¹à¤¾à¤²à¤¾ à¤¸à¥à¤ªà¤·à¥à¤Ÿà¤ªà¤£à¥‡ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤¹à¥‡.<br>
    à¤•à¥‹à¤£à¤¤à¤¾à¤¹à¥€ à¤¦à¤¬à¤¾à¤µ à¤¨ à¤†à¤£à¤¤à¤¾ à¤†à¤®à¥à¤¹à¥€ à¤¹à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¥‡à¤¨à¥‡ à¤¦à¥‡à¤¤ à¤†à¤¹à¥‹à¤¤.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">à¤¨à¤¾à¤¤à¤²à¤—à¤¾à¤šà¥‡ à¤¨à¤¾à¤µ: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤°à¥à¤—à¥à¤£à¤¾à¤¶à¥€ à¤¨à¤¾à¤¤à¥‡: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€ / à¤…à¤‚à¤—à¤ à¤¾: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Hindi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. ANAESTHESIA TYPE INFORMATION</div>
    <div class="section-content">
      I have been explained the type of anaesthesia to be administered (Local / Spinal / General / Regional), its purpose, and expected effects.<br><br>
      I understand the differences between the types of anaesthesia and why a particular type has been recommended for my procedure.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. RISKS AND SIDE EFFECTS</div>
    <div class="section-content">
      I have been informed about the potential risks, side effects, and alternatives to the recommended anaesthesia type.<br><br>
      I understand that unforeseen complications may occur despite proper care and precautions.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. CONSENT FOR ANAESTHESIA</div>
    <div class="section-content">
      I voluntarily consent to the administration of anaesthesia as explained by the anaesthesiologist. I authorize changes to the anaesthesia plan if medically necessary.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">DECLARATION</div>
    We confirm that all the above information has been explained to us clearly.<br>
    We have understood the same and have given this consent voluntarily, without any pressure.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">Relative / Attendant Name: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Relationship with Patient: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Signature / Thumb Impression: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Marathi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">1. à¤à¤¨à¥‡à¤¸à¥à¤¥à¥‡à¤¶à¤¿à¤¯à¤¾ à¤ªà¥à¤°à¤•à¤¾à¤° à¤®à¤¾à¤¹à¤¿à¤¤à¥€</div>
    <div class="section-content">
      à¤¦à¥‡à¤£à¥à¤¯à¤¾à¤¤ à¤¯à¥‡à¤£à¤¾à¤±à¥à¤¯à¤¾ à¤à¤¨à¥‡à¤¸à¥à¤¥à¥‡à¤¶à¤¿à¤¯à¤¾à¤šà¤¾ à¤ªà¥à¤°à¤•à¤¾à¤° (à¤²à¥‹à¤•à¤² / à¤¸à¥à¤ªà¤¾à¤¯à¤¨à¤² / à¤œà¤¨à¤°à¤² / à¤°à¥€à¤œà¤¨à¤²), à¤¤à¥à¤¯à¤¾à¤šà¤¾ à¤‰à¤¦à¥à¤¦à¥‡à¤¶ à¤µ à¤…à¤ªà¥‡à¤•à¥à¤·à¤¿à¤¤ à¤ªà¤°à¤¿à¤£à¤¾à¤® à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥‡ à¤†à¤¹à¥‡à¤¤.<br><br>
      à¤à¤¨à¥‡à¤¸à¥à¤¥à¥‡à¤¶à¤¿à¤¯à¤¾à¤šà¥à¤¯à¤¾ à¤ªà¥à¤°à¤•à¤¾à¤°à¤¾à¤‚à¤®à¤§à¥€à¤² à¤«à¤°à¤• à¤µ à¤®à¤¾à¤à¥à¤¯à¤¾ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¥‡à¤¸à¤¾à¤ à¥€ à¤µà¤¿à¤¶à¤¿à¤·à¥à¤Ÿ à¤ªà¥à¤°à¤•à¤¾à¤° à¤•à¤¾ à¤¸à¥à¤šà¤µà¤¿à¤²à¤¾ à¤—à¥‡à¤²à¤¾ à¤†à¤¹à¥‡, à¤¹à¥‡ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤²à¥‡ à¤†à¤¹à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. à¤§à¥‹à¤•à¥‡ à¤†à¤£à¤¿ à¤¦à¥à¤·à¥à¤ªà¤°à¤¿à¤£à¤¾à¤®</div>
    <div class="section-content">
      à¤¸à¥à¤šà¤µà¤¿à¤²à¥‡à¤²à¥à¤¯à¤¾ à¤à¤¨à¥‡à¤¸à¥à¤¥à¥‡à¤¶à¤¿à¤¯à¤¾ à¤ªà¥à¤°à¤•à¤¾à¤°à¤¾à¤šà¥‡ à¤¸à¤‚à¤­à¤¾à¤µà¥à¤¯ à¤§à¥‹à¤•à¥‡, à¤¦à¥à¤·à¥à¤ªà¤°à¤¿à¤£à¤¾à¤® à¤µ à¤ªà¤°à¥à¤¯à¤¾à¤¯ à¤®à¤²à¤¾ à¤¸à¤¾à¤‚à¤—à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥‡ à¤†à¤¹à¥‡à¤¤.<br><br>
      à¤¯à¥‹à¤—à¥à¤¯ à¤•à¤¾à¤³à¤œà¥€ à¤µ à¤¸à¤¾à¤µà¤§à¤—à¤¿à¤°à¥€ à¤˜à¥‡à¤Šà¤¨à¤¹à¥€ à¤…à¤¨à¤ªà¥‡à¤•à¥à¤·à¤¿à¤¤ à¤—à¥à¤‚à¤¤à¤¾à¤—à¥à¤‚à¤¤ à¤¹à¥‹à¤Š à¤¶à¤•à¤¤à¥‡, à¤¹à¥‡ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤²à¥‡ à¤†à¤¹à¥‡.
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. à¤à¤¨à¥‡à¤¸à¥à¤¥à¥‡à¤¶à¤¿à¤¯à¤¾à¤¸à¤¾à¤ à¥€ à¤¸à¤‚à¤®à¤¤à¥€</div>
    <div class="section-content">
      à¤­à¥‚à¤²à¤¤à¤œà¥à¤œà¥à¤žà¤¾à¤‚à¤¨à¥€ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤¿à¤¤à¤²à¥à¤¯à¤¾à¤ªà¥à¤°à¤®à¤¾à¤£à¥‡ à¤à¤¨à¥‡à¤¸à¥à¤¥à¥‡à¤¶à¤¿à¤¯à¤¾ à¤¦à¥‡à¤£à¥à¤¯à¤¾à¤¸ à¤®à¥€ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¥‡à¤¨à¥‡ à¤¸à¤‚à¤®à¤¤à¥€ à¤¦à¥‡à¤¤à¥‹/à¤¦à¥‡à¤¤à¥‡. à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯ à¤†à¤µà¤¶à¥à¤¯à¤•à¤¤à¥‡à¤¨à¥à¤¸à¤¾à¤° à¤à¤¨à¥‡à¤¸à¥à¤¥à¥‡à¤¶à¤¿à¤¯à¤¾ à¤¯à¥‹à¤œà¤¨à¥‡à¤¤ à¤¬à¤¦à¤² à¤•à¤°à¤£à¥à¤¯à¤¾à¤¸ à¤®à¥€ à¤…à¤§à¤¿à¤•à¥ƒà¤¤ à¤•à¤°à¤¤à¥‹/à¤•à¤°à¤¤à¥‡.
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">à¤œà¤¾à¤¹à¥€à¤°à¤¨à¤¾à¤®à¤¾</div>
    à¤µà¤°à¥€à¤² à¤¸à¤°à¥à¤µ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤†à¤®à¥à¤¹à¤¾à¤²à¤¾ à¤¸à¥à¤ªà¤·à¥à¤Ÿà¤ªà¤£à¥‡ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥€ à¤†à¤¹à¥‡.<br>
    à¤•à¥‹à¤£à¤¤à¤¾à¤¹à¥€ à¤¦à¤¬à¤¾à¤µ à¤¨ à¤†à¤£à¤¤à¤¾ à¤†à¤®à¥à¤¹à¥€ à¤¹à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¥‡à¤¨à¥‡ à¤¦à¥‡à¤¤ à¤†à¤¹à¥‹à¤¤.
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">à¤¨à¤¾à¤¤à¤²à¤—à¤¾à¤šà¥‡ à¤¨à¤¾à¤µ: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤°à¥à¤—à¥à¤£à¤¾à¤¶à¥€ à¤¨à¤¾à¤¤à¥‡: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€ / à¤…à¤‚à¤—à¤ à¤¾: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">Date: ____ / ____ / ______</span>
    </div>
  </div>
</div>

<!-- Hindi Page -->
<div class="page">
  
  <div class="dept-date-row">
    <span>Department: _______________________</span>
    <span>à¤¦à¤¿à¤¨à¤¾à¤‚à¤•: ____ / ____ / ______</span>
  </div>

  <div class="section">
    <div class="section-title">1. à¤à¤¨à¥‡à¤¸à¥à¤¥à¥€à¤¸à¤¿à¤¯à¤¾ à¤ªà¥à¤°à¤•à¤¾à¤° à¤œà¤¾à¤¨à¤•à¤¾à¤°à¥€</div>
    <div class="section-content">
      à¤®à¥à¤à¥‡ à¤¦à¤¿à¤ à¤œà¤¾à¤¨à¥‡ à¤µà¤¾à¤²à¥‡ à¤à¤¨à¥‡à¤¸à¥à¤¥à¥€à¤¸à¤¿à¤¯à¤¾ à¤•à¤¾ à¤ªà¥à¤°à¤•à¤¾à¤° (à¤²à¥‹à¤•à¤² / à¤¸à¥à¤ªà¤¾à¤‡à¤¨à¤² / à¤œà¤¨à¤°à¤² / à¤°à¥€à¤œà¤¨à¤²), à¤‰à¤¸à¤•à¤¾ à¤‰à¤¦à¥à¤¦à¥‡à¤¶à¥à¤¯ à¤”à¤° à¤…à¤ªà¥‡à¤•à¥à¤·à¤¿à¤¤ à¤ªà¥à¤°à¤­à¤¾à¤µ à¤®à¥à¤à¥‡ à¤¸à¤®à¤à¤¾à¤¯à¤¾ à¤—à¤¯à¤¾ à¤¹à¥ˆà¥¤<br><br>
      à¤à¤¨à¥‡à¤¸à¥à¤¥à¥€à¤¸à¤¿à¤¯à¤¾ à¤•à¥‡ à¤ªà¥à¤°à¤•à¤¾à¤°à¥‹à¤‚ à¤®à¥‡à¤‚ à¤…à¤‚à¤¤à¤° à¤”à¤° à¤®à¥‡à¤°à¥€ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤•à¥‡ à¤²à¤¿à¤ à¤µà¤¿à¤¶à¥‡à¤· à¤ªà¥à¤°à¤•à¤¾à¤° à¤•à¥à¤¯à¥‹à¤‚ à¤¸à¥à¤à¤¾à¤¯à¤¾ à¤—à¤¯à¤¾ à¤¹à¥ˆ, à¤¯à¤¹ à¤®à¥ˆà¤‚ à¤¸à¤®à¤à¤¤à¤¾/à¤¸à¤®à¤à¤¤à¥€ à¤¹à¥‚à¤à¥¤
    </div>
  </div>

  <div class="section">
    <div class="section-title">2. à¤œà¥‹à¤–à¤¿à¤® à¤”à¤° à¤¦à¥à¤·à¥à¤ªà¥à¤°à¤­à¤¾à¤µ</div>
    <div class="section-content">
      à¤…à¤¨à¥à¤¶à¤‚à¤¸à¤¿à¤¤ à¤à¤¨à¥‡à¤¸à¥à¤¥à¥€à¤¸à¤¿à¤¯à¤¾ à¤ªà¥à¤°à¤•à¤¾à¤° à¤•à¥‡ à¤¸à¤‚à¤­à¤¾à¤µà¤¿à¤¤ à¤œà¥‹à¤–à¤¿à¤®, à¤¦à¥à¤·à¥à¤ªà¥à¤°à¤­à¤¾à¤µ à¤”à¤° à¤µà¤¿à¤•à¤²à¥à¤ªà¥‹à¤‚ à¤•à¥‡ à¤¬à¤¾à¤°à¥‡ à¤®à¥‡à¤‚ à¤®à¥à¤à¥‡ à¤œà¤¾à¤¨à¤•à¤¾à¤°à¥€ à¤¦à¥€ à¤—à¤ˆ à¤¹à¥ˆà¥¤<br><br>
      à¤‰à¤šà¤¿à¤¤ à¤¦à¥‡à¤–à¤­à¤¾à¤² à¤”à¤° à¤¸à¤¾à¤µà¤§à¤¾à¤¨à¥€ à¤•à¥‡ à¤¬à¤¾à¤µà¤œà¥‚à¤¦ à¤…à¤ªà¥à¤°à¤¤à¥à¤¯à¤¾à¤¶à¤¿à¤¤ à¤œà¤Ÿà¤¿à¤²à¤¤à¤¾à¤à¤‚ à¤¹à¥‹ à¤¸à¤•à¤¤à¥€ à¤¹à¥ˆà¤‚, à¤¯à¤¹ à¤®à¥ˆà¤‚ à¤¸à¤®à¤à¤¤à¤¾/à¤¸à¤®à¤à¤¤à¥€ à¤¹à¥‚à¤à¥¤
    </div>
  </div>

  <div class="section">
    <div class="section-title">3. à¤à¤¨à¥‡à¤¸à¥à¤¥à¥€à¤¸à¤¿à¤¯à¤¾ à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¤¹à¤®à¤¤à¤¿</div>
    <div class="section-content">
      à¤à¤¨à¥‡à¤¸à¥à¤¥à¥‡à¤Ÿà¤¿à¤¸à¥à¤Ÿ à¤¦à¥à¤µà¤¾à¤°à¤¾ à¤¸à¤®à¤à¤¾à¤ à¤—à¤ à¤…à¤¨à¥à¤¸à¤¾à¤° à¤à¤¨à¥‡à¤¸à¥à¤¥à¥€à¤¸à¤¿à¤¯à¤¾ à¤¦à¥‡à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤®à¥ˆà¤‚ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¤¾ à¤¸à¥‡ à¤¸à¤¹à¤®à¤¤à¤¿ à¤¦à¥‡à¤¤à¤¾/à¤¦à¥‡à¤¤à¥€ à¤¹à¥‚à¤à¥¤ à¤šà¤¿à¤•à¤¿à¤¤à¥à¤¸à¤•à¥€à¤¯ à¤†à¤µà¤¶à¥à¤¯à¤•à¤¤à¤¾ à¤¹à¥‹à¤¨à¥‡ à¤ªà¤° à¤à¤¨à¥‡à¤¸à¥à¤¥à¥€à¤¸à¤¿à¤¯à¤¾ à¤¯à¥‹à¤œà¤¨à¤¾ à¤®à¥‡à¤‚ à¤¬à¤¦à¤²à¤¾à¤µ à¤•à¥‡ à¤²à¤¿à¤ à¤®à¥ˆà¤‚ à¤…à¤§à¤¿à¤•à¥ƒà¤¤ à¤•à¤°à¤¤à¤¾/à¤•à¤°à¤¤à¥€ à¤¹à¥‚à¤à¥¤
    </div>
  </div>

  <div class="declaration">
    <div class="declaration-title">à¤˜à¥‹à¤·à¤£à¤¾</div>
    à¤‰à¤ªà¤°à¥‹à¤•à¥à¤¤ à¤¸à¤­à¥€ à¤œà¤¾à¤¨à¤•à¤¾à¤°à¥€ à¤¹à¤®à¥‡à¤‚ à¤¸à¥à¤ªà¤·à¥à¤Ÿ à¤°à¥‚à¤ª à¤¸à¥‡ à¤¸à¤®à¤à¤¾à¤ˆ à¤—à¤ˆ à¤¹à¥ˆà¥¤<br>
    à¤¹à¤® à¤¬à¤¿à¤¨à¤¾ à¤•à¤¿à¤¸à¥€ à¤¦à¤¬à¤¾à¤µ à¤•à¥‡ à¤¯à¤¹ à¤¸à¤¹à¤®à¤¤à¤¿ à¤¸à¥à¤µà¥‡à¤šà¥à¤›à¤¾ à¤¸à¥‡ à¤ªà¥à¤°à¤¦à¤¾à¤¨ à¤•à¤° à¤°à¤¹à¥‡ à¤¹à¥ˆà¤‚à¥¤
  </div>
  
  <div class="signature-grid">
    <div class="signature-row">
      <span class="signature-field">à¤ªà¤°à¤¿à¤œà¤¨ à¤•à¤¾ à¤¨à¤¾à¤®: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤°à¥‹à¤—à¥€ à¤¸à¥‡ à¤¸à¤‚à¤¬à¤‚à¤§: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤° / à¤…à¤‚à¤—à¥‚à¤ à¤¾ à¤¨à¤¿à¤¶à¤¾à¤¨: <span class="signature-line"></span></span>
    </div>
    <div class="signature-row">
      <span class="signature-field">à¤¦à¤¿à¤¨à¤¾à¤‚à¤•: ____ / ____ / ______</span>
    </div>
  </div>
</div>

</body>
</html>`;
          res.setHeader('Content-Type', 'text/html; charset=utf-8');
          return res.send(htmlContent);
        }

        // ========== MJPJAY Scheme Consent ==========
        if (consentType === 'MJPJAY_SCHEME') {
          const patientName = patient ? `${patient.firstName} ${patient.lastName}` : '__________';
          const patientAge = patient?.dateOfBirth ? calculateAge(patient.dateOfBirth) : '__________';
          const patientGender = patient?.gender || '__________';
          const patientUhid = patient?.uhidNumber || patient?.id?.substring(0, 8).toUpperCase() || '__________';
          
          const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>MJPJAY Scheme Consent</title>
  <style>
    @page { size: A4; margin: 15mm; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Arial, sans-serif; font-size: 11pt; line-height: 1.6; color: #333; }
    .page { width: 210mm; min-height: 297mm; padding: 15mm; margin: 10mm auto; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); page-break-after: always; }
    .page:last-child { page-break-after: auto; }
    .hospital-header { display: flex; align-items: center; gap: 20px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid #4a2683; }
    .logo-section { display: flex; align-items: center; }
    .hospital-logo { height: 50px; width: auto; }
    .hospital-info { flex: 1; }
    .hospital-name { font-size: 16pt; font-weight: bold; color: #2c5aa0; margin-bottom: 2px; }
    .hospital-address { font-size: 9pt; color: #666; }
    .hospital-contact { font-size: 9pt; color: #333; font-weight: bold; }
    .form-title { text-align: center; font-size: 16pt; font-weight: bold; margin: 20px 0; color: #333; }
    .patient-info-box { border: 1px solid #333; padding: 10px; margin: 15px 0; background: #f9f9f9; display: flex; flex-wrap: wrap; gap: 15px; }
    .patient-info-item { font-size: 10pt; min-width: 150px; }
    .patient-label { font-weight: bold; }
    .dept-date-row { display: flex; justify-content: space-between; margin: 15px 0; font-size: 10pt; }
    .section { margin: 15px 0; }
    .section-title { font-size: 12pt; font-weight: bold; margin-bottom: 8px; color: #2c5aa0; }
    .section-content { text-align: justify; }
    .checkbox-item { display: flex; align-items: flex-start; gap: 8px; margin: 8px 0; }
    .checkbox { width: 14px; height: 14px; border: 1px solid #333; display: inline-block; flex-shrink: 0; margin-top: 3px; }
    .signature-section { margin-top: 40px; display: flex; justify-content: space-between; }
    .signature-block { text-align: center; width: 45%; }
    .signature-line { border-top: 1px solid #333; margin-top: 40px; padding-top: 5px; }
    @media print { .page { margin: 0; box-shadow: none; } }
  </style>
</head>
<body>
<!-- English Page -->
<div class="page">
  <div class="hospital-header">
    <div class="logo-section">
      <img src="data:image/png;base64,${hospitalLogoBase64}" alt="Hospital Logo" class="hospital-logo" />
    </div>
    <div class="hospital-info">
      <div class="hospital-name">Gravity Hospital & Research Centre</div>
      <div class="hospital-address">123 Medical Drive, Healthcare District<br>City, State - 400001</div>
      <div class="hospital-contact">Phone: +91 22 1234 5678 | Email: info@gravityhospital.com</div>
    </div>
  </div>

  <div class="form-title">MJPJAY Scheme Consent Form</div>
  
  <div class="patient-info-box">
    <span class="patient-info-item"><span class="patient-label">Patient Name:</span> ${patientName}</span>
    <span class="patient-info-item"><span class="patient-label">UHID:</span> ${patientUhid}</span>
    <span class="patient-info-item"><span class="patient-label">Gender:</span> ${patientGender}</span>
    <span class="patient-info-item"><span class="patient-label">Age:</span> ${patientAge} years</span>
  </div>
  
  <div class="dept-date-row">
    <span>Department: ______________________</span>
    <span>Date: ____ / ____ / ______</span>
  </div>

  <div class="section">
    <div class="section-title">Declaration of Eligibility under MJPJAY Scheme</div>
    <div class="section-content">
      I, the undersigned, hereby declare that I am a beneficiary under the Mahatma Jyotiba Phule Jan Arogya Yojana (MJPJAY) scheme 
      and I authorize Gravity Hospital & Research Centre to:
      <br><br>
      <div class="checkbox-item"><span class="checkbox"></span> Upload my medical records and treatment details to the MJPJAY portal</div>
      <div class="checkbox-item"><span class="checkbox"></span> Submit claims on my behalf for the treatment received</div>
      <div class="checkbox-item"><span class="checkbox"></span> Share necessary information with insurance authorities</div>
      <div class="checkbox-item"><span class="checkbox"></span> Process my case as per MJPJAY guidelines and procedures</div>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Patient/Guardian Acknowledgement</div>
    <div class="section-content">
      I understand that the treatment will be provided as per the MJPJAY scheme guidelines. I confirm that all information 
      provided by me is true and correct. I understand that providing false information may lead to disqualification from the scheme.
    </div>
  </div>

  <div class="signature-section">
    <div class="signature-block">
      <div class="signature-line">Patient/Guardian Signature</div>
    </div>
    <div class="signature-block">
      <div class="signature-line">Hospital Representative</div>
    </div>
  </div>
</div>

<!-- Marathi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">à¤®à¤¹à¤¾à¤¤à¥à¤®à¤¾ à¤œà¥à¤¯à¥‹à¤¤à¤¿à¤¬à¤¾ à¤«à¥à¤²à¥‡ à¤œà¤¨ à¤†à¤°à¥‹à¤—à¥à¤¯ à¤¯à¥‹à¤œà¤¨à¤¾ (MJPJAY) à¤…à¤‚à¤¤à¤°à¥à¤—à¤¤ à¤ªà¤¾à¤¤à¥à¤°à¤¤à¥‡à¤šà¥€ à¤˜à¥‹à¤·à¤£à¤¾</div>
    <div class="section-content">
      à¤®à¥€, à¤–à¤¾à¤²à¥€ à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€ à¤•à¥‡à¤²à¥‡à¤²à¤¾/à¤•à¥‡à¤²à¥‡à¤²à¥€, à¤¯à¤¾à¤¦à¥à¤µà¤¾à¤°à¥‡ à¤˜à¥‹à¤·à¤¿à¤¤ à¤•à¤°à¤¤à¥‹/à¤•à¤°à¤¤à¥‡ à¤•à¥€ à¤®à¥€ à¤®à¤¹à¤¾à¤¤à¥à¤®à¤¾ à¤œà¥à¤¯à¥‹à¤¤à¤¿à¤¬à¤¾ à¤«à¥à¤²à¥‡ à¤œà¤¨ à¤†à¤°à¥‹à¤—à¥à¤¯ à¤¯à¥‹à¤œà¤¨à¤¾ (MJPJAY) à¤¯à¥‹à¤œà¤¨à¥‡à¤šà¤¾/à¤šà¥€ à¤²à¤¾à¤­à¤¾à¤°à¥à¤¥à¥€ à¤†à¤¹à¥‡ 
      à¤†à¤£à¤¿ à¤®à¥€ à¤—à¥à¤°à¥…à¤µà¤¿à¤Ÿà¥€ à¤¹à¥‰à¤¸à¥à¤ªà¤¿à¤Ÿà¤² à¤…à¤à¤¡ à¤°à¤¿à¤¸à¤°à¥à¤š à¤¸à¥‡à¤‚à¤Ÿà¤°à¤²à¤¾ à¤–à¤¾à¤²à¥€à¤² à¤—à¥‹à¤·à¥à¤Ÿà¥€à¤‚à¤¸à¤¾à¤ à¥€ à¤…à¤§à¤¿à¤•à¥ƒà¤¤ à¤•à¤°à¤¤à¥‹/à¤•à¤°à¤¤à¥‡:
      <br><br>
      <div class="checkbox-item"><span class="checkbox"></span> à¤®à¤¾à¤à¥‡ à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯ à¤°à¥‡à¤•à¥‰à¤°à¥à¤¡ à¤†à¤£à¤¿ à¤‰à¤ªà¤šà¤¾à¤° à¤¤à¤ªà¤¶à¥€à¤² MJPJAY à¤ªà¥‹à¤°à¥à¤Ÿà¤²à¤µà¤° à¤…à¤ªà¤²à¥‹à¤¡ à¤•à¤°à¤£à¥‡</div>
      <div class="checkbox-item"><span class="checkbox"></span> à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤ à¤‰à¤ªà¤šà¤¾à¤°à¤¾à¤‚à¤¸à¤¾à¤ à¥€ à¤®à¤¾à¤à¥à¤¯à¤¾ à¤µà¤¤à¥€à¤¨à¥‡ à¤¦à¤¾à¤µà¥‡ à¤¸à¤¾à¤¦à¤° à¤•à¤°à¤£à¥‡</div>
      <div class="checkbox-item"><span class="checkbox"></span> à¤µà¤¿à¤®à¤¾ à¤…à¤§à¤¿à¤•à¤¾à¤±à¥à¤¯à¤¾à¤‚à¤¸à¥‹à¤¬à¤¤ à¤†à¤µà¤¶à¥à¤¯à¤• à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤¸à¤¾à¤®à¤¾à¤¯à¤¿à¤• à¤•à¤°à¤£à¥‡</div>
      <div class="checkbox-item"><span class="checkbox"></span> MJPJAY à¤®à¤¾à¤°à¥à¤—à¤¦à¤°à¥à¤¶à¤• à¤¤à¤¤à¥à¤¤à¥à¤µà¥‡ à¤†à¤£à¤¿ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾à¤‚à¤¨à¥à¤¸à¤¾à¤° à¤®à¤¾à¤à¥à¤¯à¤¾ à¤•à¥‡à¤¸à¤µà¤° à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤•à¤°à¤£à¥‡</div>
    </div>
  </div>

  <div class="signature-section">
    <div class="signature-block">
      <div class="signature-line">à¤°à¥à¤—à¥à¤£/à¤ªà¤¾à¤²à¤• à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div>
    </div>
    <div class="signature-block">
      <div class="signature-line">à¤°à¥à¤—à¥à¤£à¤¾à¤²à¤¯ à¤ªà¥à¤°à¤¤à¤¿à¤¨à¤¿à¤§à¥€</div>
    </div>
  </div>
</div>

<!-- Hindi Page -->
<div class="page">

  <div class="section">
    <div class="section-title">à¤®à¤¹à¤¾à¤¤à¥à¤®à¤¾ à¤œà¥à¤¯à¥‹à¤¤à¤¿à¤¬à¤¾ à¤«à¥à¤²à¥‡ à¤œà¤¨ à¤†à¤°à¥‹à¤—à¥à¤¯ à¤¯à¥‹à¤œà¤¨à¤¾ (MJPJAY) à¤•à¥‡ à¤¤à¤¹à¤¤ à¤ªà¤¾à¤¤à¥à¤°à¤¤à¤¾ à¤•à¥€ à¤˜à¥‹à¤·à¤£à¤¾</div>
    <div class="section-content">
      à¤®à¥ˆà¤‚, à¤…à¤§à¥‹à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°à¥€, à¤à¤¤à¤¦à¥à¤¦à¥à¤µà¤¾à¤°à¤¾ à¤˜à¥‹à¤·à¤£à¤¾ à¤•à¤°à¤¤à¤¾/à¤•à¤°à¤¤à¥€ à¤¹à¥‚à¤‚ à¤•à¤¿ à¤®à¥ˆà¤‚ à¤®à¤¹à¤¾à¤¤à¥à¤®à¤¾ à¤œà¥à¤¯à¥‹à¤¤à¤¿à¤¬à¤¾ à¤«à¥à¤²à¥‡ à¤œà¤¨ à¤†à¤°à¥‹à¤—à¥à¤¯ à¤¯à¥‹à¤œà¤¨à¤¾ (MJPJAY) à¤¯à¥‹à¤œà¤¨à¤¾ à¤•à¤¾/à¤•à¥€ à¤²à¤¾à¤­à¤¾à¤°à¥à¤¥à¥€ à¤¹à¥‚à¤‚ 
      à¤”à¤° à¤®à¥ˆà¤‚ à¤—à¥à¤°à¥ˆà¤µà¤¿à¤Ÿà¥€ à¤¹à¥‰à¤¸à¥à¤ªà¤¿à¤Ÿà¤² à¤à¤‚à¤¡ à¤°à¤¿à¤¸à¤°à¥à¤š à¤¸à¥‡à¤‚à¤Ÿà¤° à¤•à¥‹ à¤¨à¤¿à¤®à¥à¤¨à¤²à¤¿à¤–à¤¿à¤¤ à¤•à¥‡ à¤²à¤¿à¤ à¤…à¤§à¤¿à¤•à¥ƒà¤¤ à¤•à¤°à¤¤à¤¾/à¤•à¤°à¤¤à¥€ à¤¹à¥‚à¤‚:
      <br><br>
      <div class="checkbox-item"><span class="checkbox"></span> à¤®à¥‡à¤°à¥‡ à¤®à¥‡à¤¡à¤¿à¤•à¤² à¤°à¤¿à¤•à¥‰à¤°à¥à¤¡ à¤”à¤° à¤‰à¤ªà¤šà¤¾à¤° à¤µà¤¿à¤µà¤°à¤£ MJPJAY à¤ªà¥‹à¤°à¥à¤Ÿà¤² à¤ªà¤° à¤…à¤ªà¤²à¥‹à¤¡ à¤•à¤°à¤¨à¤¾</div>
      <div class="checkbox-item"><span class="checkbox"></span> à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤ à¤‰à¤ªà¤šà¤¾à¤° à¤•à¥‡ à¤²à¤¿à¤ à¤®à¥‡à¤°à¥€ à¤“à¤° à¤¸à¥‡ à¤¦à¤¾à¤µà¥‡ à¤ªà¥à¤°à¤¸à¥à¤¤à¥à¤¤ à¤•à¤°à¤¨à¤¾</div>
      <div class="checkbox-item"><span class="checkbox"></span> à¤¬à¥€à¤®à¤¾ à¤…à¤§à¤¿à¤•à¤¾à¤°à¤¿à¤¯à¥‹à¤‚ à¤•à¥‡ à¤¸à¤¾à¤¥ à¤†à¤µà¤¶à¥à¤¯à¤• à¤œà¤¾à¤¨à¤•à¤¾à¤°à¥€ à¤¸à¤¾à¤à¤¾ à¤•à¤°à¤¨à¤¾</div>
      <div class="checkbox-item"><span class="checkbox"></span> MJPJAY à¤¦à¤¿à¤¶à¤¾à¤¨à¤¿à¤°à¥à¤¦à¥‡à¤¶à¥‹à¤‚ à¤”à¤° à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾à¤“à¤‚ à¤•à¥‡ à¤…à¤¨à¥à¤¸à¤¾à¤° à¤®à¥‡à¤°à¥‡ à¤®à¤¾à¤®à¤²à¥‡ à¤•à¥‹ à¤¸à¤‚à¤¸à¤¾à¤§à¤¿à¤¤ à¤•à¤°à¤¨à¤¾</div>
    </div>
  </div>

  <div class="signature-section">
    <div class="signature-block">
      <div class="signature-line">à¤°à¥‹à¤—à¥€/à¤…à¤­à¤¿à¤­à¤¾à¤µà¤• à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div>
    </div>
    <div class="signature-block">
      <div class="signature-line">à¤…à¤¸à¥à¤ªà¤¤à¤¾à¤² à¤ªà¥à¤°à¤¤à¤¿à¤¨à¤¿à¤§à¤¿</div>
    </div>
  </div>
</div>
</body>
</html>`;
          res.setHeader('Content-Type', 'text/html; charset=utf-8');
          return res.send(htmlContent);
        }

        // ========== Billing Acknowledgement ==========
        if (consentType === 'BILLING_ACKNOWLEDGEMENT') {
          const patientName = patient ? `${patient.firstName} ${patient.lastName}` : '__________';
          const patientAge = patient?.dateOfBirth ? calculateAge(patient.dateOfBirth) : '__________';
          const patientGender = patient?.gender || '__________';
          const patientUhid = patient?.uhidNumber || patient?.id?.substring(0, 8).toUpperCase() || '__________';
          
          const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Billing Sheet Acknowledgement</title>
  <style>
    @page { size: A4; margin: 15mm; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Arial, sans-serif; font-size: 11pt; line-height: 1.6; color: #333; }
    .page { width: 210mm; min-height: 297mm; padding: 15mm; margin: 10mm auto; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); page-break-after: always; }
    .page:last-child { page-break-after: auto; }
    .hospital-header { display: flex; align-items: center; gap: 20px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid #4a2683; }
    .logo-section { display: flex; align-items: center; }
    .hospital-logo { height: 50px; width: auto; }
    .hospital-info { flex: 1; }
    .hospital-name { font-size: 16pt; font-weight: bold; color: #2c5aa0; margin-bottom: 2px; }
    .hospital-address { font-size: 9pt; color: #666; }
    .hospital-contact { font-size: 9pt; color: #333; font-weight: bold; }
    .form-title { text-align: center; font-size: 16pt; font-weight: bold; margin: 20px 0; color: #333; }
    .patient-info-box { border: 1px solid #333; padding: 10px; margin: 15px 0; background: #f9f9f9; display: flex; flex-wrap: wrap; gap: 15px; }
    .patient-info-item { font-size: 10pt; min-width: 150px; }
    .patient-label { font-weight: bold; }
    .dept-date-row { display: flex; justify-content: space-between; margin: 15px 0; font-size: 10pt; }
    .section { margin: 15px 0; }
    .section-title { font-size: 12pt; font-weight: bold; margin-bottom: 8px; color: #2c5aa0; }
    .section-content { text-align: justify; }
    .signature-section { margin-top: 40px; display: flex; justify-content: space-between; }
    .signature-block { text-align: center; width: 45%; }
    .signature-line { border-top: 1px solid #333; margin-top: 40px; padding-top: 5px; }
    @media print { .page { margin: 0; box-shadow: none; } }
  </style>
</head>
<body>
<!-- English Page -->
<div class="page">
  <div class="hospital-header">
    <div class="logo-section">
      <img src="data:image/png;base64,${hospitalLogoBase64}" alt="Hospital Logo" class="hospital-logo" />
    </div>
    <div class="hospital-info">
      <div class="hospital-name">Gravity Hospital & Research Centre</div>
      <div class="hospital-address">123 Medical Drive, Healthcare District<br>City, State - 400001</div>
      <div class="hospital-contact">Phone: +91 22 1234 5678 | Email: info@gravityhospital.com</div>
    </div>
  </div>
  <div class="form-title">Billing Sheet Acknowledgement</div>
  <div class="patient-info-box">
    <span class="patient-info-item"><span class="patient-label">Patient Name:</span> ${patientName}</span>
    <span class="patient-info-item"><span class="patient-label">UHID:</span> ${patientUhid}</span>
    <span class="patient-info-item"><span class="patient-label">Gender:</span> ${patientGender}</span>
    <span class="patient-info-item"><span class="patient-label">Age:</span> ${patientAge} years</span>
  </div>
  <div class="dept-date-row">
    <span>Department: ______________________</span>
    <span>Date: ____ / ____ / ______</span>
  </div>
  <div class="section">
    <div class="section-title">Acknowledgement</div>
    <div class="section-content">
      I acknowledge receipt and understanding of the hospital billing structure including consultation fees, investigation charges, procedure costs, room charges, nursing charges, and other applicable fees. I agree to pay all charges as per the hospital tariff.
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">Patient/Guardian Signature</div></div>
    <div class="signature-block"><div class="signature-line">Hospital Representative</div></div>
  </div>
</div>
<!-- Marathi Page -->
<div class="page">
  <div class="section">
    <div class="section-title">à¤¬à¤¿à¤²à¤¿à¤‚à¤— à¤¶à¥€à¤Ÿ à¤ªà¥‹à¤šà¤ªà¤¾à¤µà¤¤à¥€</div>
    <div class="section-content">
      à¤®à¥€ à¤¹à¥‰à¤¸à¥à¤ªà¤¿à¤Ÿà¤² à¤¬à¤¿à¤²à¤¿à¤‚à¤— à¤¸à¤‚à¤°à¤šà¤¨à¥‡à¤šà¥€ à¤ªà¤¾à¤µà¤¤à¥€ à¤†à¤£à¤¿ à¤¸à¤®à¤œ à¤˜à¥‡à¤¤à¥‹ à¤œà¥à¤¯à¤¾à¤®à¤§à¥à¤¯à¥‡ à¤¸à¤²à¥à¤²à¤¾ à¤¶à¥à¤²à¥à¤•, à¤¤à¤ªà¤¾à¤¸à¤£à¥€ à¤¶à¥à¤²à¥à¤•, à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤–à¤°à¥à¤š, à¤–à¥‹à¤²à¥€ à¤¶à¥à¤²à¥à¤•, à¤¨à¤°à¥à¤¸à¤¿à¤‚à¤— à¤¶à¥à¤²à¥à¤• à¤†à¤£à¤¿ à¤‡à¤¤à¤° à¤²à¤¾à¤—à¥‚ à¤¶à¥à¤²à¥à¤• à¤¸à¤®à¤¾à¤µà¤¿à¤·à¥à¤Ÿ à¤†à¤¹à¥‡.
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">à¤°à¥à¤—à¥à¤£/à¤ªà¤¾à¤²à¤• à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div></div>
    <div class="signature-block"><div class="signature-line">à¤°à¥à¤—à¥à¤£à¤¾à¤²à¤¯ à¤ªà¥à¤°à¤¤à¤¿à¤¨à¤¿à¤§à¥€</div></div>
  </div>
</div>
<!-- Hindi Page -->
<div class="page">
  <div class="section">
    <div class="section-title">à¤¬à¤¿à¤²à¤¿à¤‚à¤— à¤¶à¥€à¤Ÿ à¤ªà¤¾à¤µà¤¤à¥€</div>
    <div class="section-content">
      à¤®à¥ˆà¤‚ à¤…à¤¸à¥à¤ªà¤¤à¤¾à¤² à¤¬à¤¿à¤²à¤¿à¤‚à¤— à¤¸à¤‚à¤°à¤šà¤¨à¤¾ à¤•à¥€ à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤à¤¿ à¤”à¤° à¤¸à¤®à¤ à¤•à¥‹ à¤¸à¥à¤µà¥€à¤•à¤¾à¤° à¤•à¤°à¤¤à¤¾/à¤•à¤°à¤¤à¥€ à¤¹à¥‚à¤‚ à¤œà¤¿à¤¸à¤®à¥‡à¤‚ à¤ªà¤°à¤¾à¤®à¤°à¥à¤¶ à¤¶à¥à¤²à¥à¤•, à¤œà¤¾à¤‚à¤š à¤¶à¥à¤²à¥à¤•, à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤²à¤¾à¤—à¤¤, à¤•à¤®à¤°à¥‡ à¤•à¤¾ à¤¶à¥à¤²à¥à¤•, à¤¨à¤°à¥à¤¸à¤¿à¤‚à¤— à¤¶à¥à¤²à¥à¤• à¤”à¤° à¤…à¤¨à¥à¤¯ à¤²à¤¾à¤—à¥‚ à¤¶à¥à¤²à¥à¤• à¤¶à¤¾à¤®à¤¿à¤² à¤¹à¥ˆà¤‚à¥¤
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">à¤°à¥‹à¤—à¥€/à¤…à¤­à¤¿à¤­à¤¾à¤µà¤• à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div></div>
    <div class="signature-block"><div class="signature-line">à¤…à¤¸à¥à¤ªà¤¤à¤¾à¤² à¤ªà¥à¤°à¤¤à¤¿à¤¨à¤¿à¤§à¤¿</div></div>
  </div>
</div>
</body>
</html>`;
          res.setHeader('Content-Type', 'text/html; charset=utf-8');
          return res.send(htmlContent);
        }

        // ========== Fitness Certificate ==========
        if (consentType === 'FITNESS_CERTIFICATE') {
          const patientName = patient ? `${patient.firstName} ${patient.lastName}` : '__________';
          const patientAge = patient?.dateOfBirth ? calculateAge(patient.dateOfBirth) : '__________';
          const patientGender = patient?.gender || '__________';
          const patientUhid = patient?.uhidNumber || patient?.id?.substring(0, 8).toUpperCase() || '__________';
          
          const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Physician Fitness Certificate</title>
  <style>
    @page { size: A4; margin: 15mm; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Arial, sans-serif; font-size: 11pt; line-height: 1.6; color: #333; }
    .page { width: 210mm; min-height: 297mm; padding: 15mm; margin: 10mm auto; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); page-break-after: always; }
    .page:last-child { page-break-after: auto; }
    .hospital-header { display: flex; align-items: center; gap: 20px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid #4a2683; }
    .logo-section { display: flex; align-items: center; }
    .hospital-logo { height: 50px; width: auto; }
    .hospital-info { flex: 1; }
    .hospital-name { font-size: 16pt; font-weight: bold; color: #2c5aa0; margin-bottom: 2px; }
    .hospital-address { font-size: 9pt; color: #666; }
    .hospital-contact { font-size: 9pt; color: #333; font-weight: bold; }
    .form-title { text-align: center; font-size: 16pt; font-weight: bold; margin: 20px 0; color: #333; }
    .patient-info-box { border: 1px solid #333; padding: 10px; margin: 15px 0; background: #f9f9f9; display: flex; flex-wrap: wrap; gap: 15px; }
    .patient-info-item { font-size: 10pt; min-width: 150px; }
    .patient-label { font-weight: bold; }
    .dept-date-row { display: flex; justify-content: space-between; margin: 15px 0; font-size: 10pt; }
    .section { margin: 15px 0; }
    .section-title { font-size: 12pt; font-weight: bold; margin-bottom: 8px; color: #2c5aa0; }
    .section-content { text-align: justify; }
    .signature-section { margin-top: 40px; display: flex; justify-content: space-between; }
    .signature-block { text-align: center; width: 45%; }
    .signature-line { border-top: 1px solid #333; margin-top: 40px; padding-top: 5px; }
    @media print { .page { margin: 0; box-shadow: none; } }
  </style>
</head>
<body>
<!-- English Page -->
<div class="page">
  <div class="hospital-header">
    <div class="logo-section">
      <img src="data:image/png;base64,${hospitalLogoBase64}" alt="Hospital Logo" class="hospital-logo" />
    </div>
    <div class="hospital-info">
      <div class="hospital-name">Gravity Hospital & Research Centre</div>
      <div class="hospital-address">123 Medical Drive, Healthcare District<br>City, State - 400001</div>
      <div class="hospital-contact">Phone: +91 22 1234 5678 | Email: info@gravityhospital.com</div>
    </div>
  </div>
  <div class="form-title">Physician Fitness Certificate Consent</div>
  <div class="patient-info-box">
    <span class="patient-info-item"><span class="patient-label">Patient Name:</span> ${patientName}</span>
    <span class="patient-info-item"><span class="patient-label">UHID:</span> ${patientUhid}</span>
    <span class="patient-info-item"><span class="patient-label">Gender:</span> ${patientGender}</span>
    <span class="patient-info-item"><span class="patient-label">Age:</span> ${patientAge} years</span>
  </div>
  <div class="dept-date-row">
    <span>Department: ______________________</span>
    <span>Date: ____ / ____ / ______</span>
  </div>
  <div class="section">
    <div class="section-title">Fitness Certificate Request</div>
    <div class="section-content">
      I request a fitness certificate for employment/travel/sports purposes. I confirm that all medical information provided is accurate and I authorize the hospital to issue the certificate based on the examination conducted.
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">Patient Signature</div></div>
    <div class="signature-block"><div class="signature-line">Physician Signature</div></div>
  </div>
</div>
<!-- Marathi Page -->
<div class="page">
  <div class="section">
    <div class="section-title">à¤«à¤¿à¤Ÿà¤¨à¥‡à¤¸ à¤ªà¥à¤°à¤®à¤¾à¤£à¤ªà¤¤à¥à¤° à¤µà¤¿à¤¨à¤‚à¤¤à¥€</div>
    <div class="section-content">
      à¤®à¥€ à¤°à¥‹à¤œà¤—à¤¾à¤°/à¤ªà¥à¤°à¤µà¤¾à¤¸/à¤–à¥‡à¤³ à¤‰à¤¦à¥à¤¦à¥‡à¤¶à¤¾à¤‚à¤¸à¤¾à¤ à¥€ à¤«à¤¿à¤Ÿà¤¨à¥‡à¤¸ à¤ªà¥à¤°à¤®à¤¾à¤£à¤ªà¤¤à¥à¤°à¤¾à¤šà¥€ à¤µà¤¿à¤¨à¤‚à¤¤à¥€ à¤•à¤°à¤¤à¥‹. à¤®à¥€ à¤ªà¥à¤·à¥à¤Ÿà¥€ à¤•à¤°à¤¤à¥‹ à¤•à¥€ à¤¦à¤¿à¤²à¥‡à¤²à¥€ à¤¸à¤°à¥à¤µ à¤µà¥ˆà¤¦à¥à¤¯à¤•à¥€à¤¯ à¤®à¤¾à¤¹à¤¿à¤¤à¥€ à¤…à¤šà¥‚à¤• à¤†à¤¹à¥‡.
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">à¤°à¥à¤—à¥à¤£ à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div></div>
    <div class="signature-block"><div class="signature-line">à¤µà¥ˆà¤¦à¥à¤¯ à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div></div>
  </div>
</div>
<!-- Hindi Page -->
<div class="page">
  <div class="section">
    <div class="section-title">à¤«à¤¿à¤Ÿà¤¨à¥‡à¤¸ à¤ªà¥à¤°à¤®à¤¾à¤£à¤ªà¤¤à¥à¤° à¤…à¤¨à¥à¤°à¥‹à¤§</div>
    <div class="section-content">
      à¤®à¥ˆà¤‚ à¤°à¥‹à¤œà¤—à¤¾à¤°/à¤¯à¤¾à¤¤à¥à¤°à¤¾/à¤–à¥‡à¤² à¤‰à¤¦à¥à¤¦à¥‡à¤¶à¥à¤¯à¥‹à¤‚ à¤•à¥‡ à¤²à¤¿à¤ à¤«à¤¿à¤Ÿà¤¨à¥‡à¤¸ à¤ªà¥à¤°à¤®à¤¾à¤£à¤ªà¤¤à¥à¤° à¤•à¤¾ à¤…à¤¨à¥à¤°à¥‹à¤§ à¤•à¤°à¤¤à¤¾/à¤•à¤°à¤¤à¥€ à¤¹à¥‚à¤‚à¥¤ à¤®à¥ˆà¤‚ à¤ªà¥à¤·à¥à¤Ÿà¤¿ à¤•à¤°à¤¤à¤¾/à¤•à¤°à¤¤à¥€ à¤¹à¥‚à¤‚ à¤•à¤¿ à¤ªà¥à¤°à¤¦à¤¾à¤¨ à¤•à¥€ à¤—à¤ˆ à¤¸à¤­à¥€ à¤šà¤¿à¤•à¤¿à¤¤à¥à¤¸à¤¾ à¤œà¤¾à¤¨à¤•à¤¾à¤°à¥€ à¤¸à¤Ÿà¥€à¤• à¤¹à¥ˆà¥¤
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">à¤°à¥‹à¤—à¥€ à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div></div>
    <div class="signature-block"><div class="signature-line">à¤šà¤¿à¤•à¤¿à¤¤à¥à¤¸à¤• à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div></div>
  </div>
</div>
</body>
</html>`;
          res.setHeader('Content-Type', 'text/html; charset=utf-8');
          return res.send(htmlContent);
        }

        // ========== General Procedure ==========
        if (consentType === 'GENERAL_PROCEDURE') {
          const patientName = patient ? `${patient.firstName} ${patient.lastName}` : '__________';
          const patientAge = patient?.dateOfBirth ? calculateAge(patient.dateOfBirth) : '__________';
          const patientGender = patient?.gender || '__________';
          const patientUhid = patient?.uhidNumber || patient?.id?.substring(0, 8).toUpperCase() || '__________';
          
          const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>General Procedure Consent</title>
  <style>
    @page { size: A4; margin: 15mm; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Arial, sans-serif; font-size: 11pt; line-height: 1.6; color: #333; }
    .page { width: 210mm; min-height: 297mm; padding: 15mm; margin: 10mm auto; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); page-break-after: always; }
    .page:last-child { page-break-after: auto; }
    .hospital-header { display: flex; align-items: center; gap: 20px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid #4a2683; }
    .logo-section { display: flex; align-items: center; }
    .hospital-logo { height: 50px; width: auto; }
    .hospital-info { flex: 1; }
    .hospital-name { font-size: 16pt; font-weight: bold; color: #2c5aa0; margin-bottom: 2px; }
    .hospital-address { font-size: 9pt; color: #666; }
    .hospital-contact { font-size: 9pt; color: #333; font-weight: bold; }
    .form-title { text-align: center; font-size: 16pt; font-weight: bold; margin: 20px 0; color: #333; }
    .patient-info-box { border: 1px solid #333; padding: 10px; margin: 15px 0; background: #f9f9f9; display: flex; flex-wrap: wrap; gap: 15px; }
    .patient-info-item { font-size: 10pt; min-width: 150px; }
    .patient-label { font-weight: bold; }
    .dept-date-row { display: flex; justify-content: space-between; margin: 15px 0; font-size: 10pt; }
    .section { margin: 15px 0; }
    .section-title { font-size: 12pt; font-weight: bold; margin-bottom: 8px; color: #2c5aa0; }
    .section-content { text-align: justify; }
    .signature-section { margin-top: 40px; display: flex; justify-content: space-between; }
    .signature-block { text-align: center; width: 45%; }
    .signature-line { border-top: 1px solid #333; margin-top: 40px; padding-top: 5px; }
    @media print { .page { margin: 0; box-shadow: none; } }
  </style>
</head>
<body>
<!-- English Page -->
<div class="page">
  <div class="hospital-header">
    <div class="logo-section">
      <img src="data:image/png;base64,${hospitalLogoBase64}" alt="Hospital Logo" class="hospital-logo" />
    </div>
    <div class="hospital-info">
      <div class="hospital-name">Gravity Hospital & Research Centre</div>
      <div class="hospital-address">123 Medical Drive, Healthcare District<br>City, State - 400001</div>
      <div class="hospital-contact">Phone: +91 22 1234 5678 | Email: info@gravityhospital.com</div>
    </div>
  </div>
  <div class="form-title">General Procedure Consent</div>
  <div class="patient-info-box">
    <span class="patient-info-item"><span class="patient-label">Patient Name:</span> ${patientName}</span>
    <span class="patient-info-item"><span class="patient-label">UHID:</span> ${patientUhid}</span>
    <span class="patient-info-item"><span class="patient-label">Gender:</span> ${patientGender}</span>
    <span class="patient-info-item"><span class="patient-label">Age:</span> ${patientAge} years</span>
  </div>
  <div class="dept-date-row">
    <span>Procedure: ______________________</span>
    <span>Date: ____ / ____ / ______</span>
  </div>
  <div class="section">
    <div class="section-title">Consent for General Procedure</div>
    <div class="section-content">
      I consent to the proposed procedure. The nature, purpose, risks, benefits, and alternatives have been explained to me. I understand that complications may occur and I authorize the medical team to perform additional procedures if necessary.
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">Patient/Guardian Signature</div></div>
    <div class="signature-block"><div class="signature-line">Physician Signature</div></div>
  </div>
</div>
<!-- Marathi Page -->
<div class="page">
  <div class="section">
    <div class="section-title">à¤¸à¤¾à¤®à¤¾à¤¨à¥à¤¯ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¥‡à¤¸à¤¾à¤ à¥€ à¤¸à¤‚à¤®à¤¤à¥€</div>
    <div class="section-content">
      à¤®à¥€ à¤ªà¥à¤°à¤¸à¥à¤¤à¤¾à¤µà¤¿à¤¤ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¥‡à¤¸à¤¾à¤ à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¦à¥‡à¤¤à¥‹. à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¥‡à¤šà¥‡ à¤¸à¥à¤µà¤°à¥‚à¤ª, à¤‰à¤¦à¥à¤¦à¥‡à¤¶, à¤œà¥‹à¤–à¥€à¤®, à¤«à¤¾à¤¯à¤¦à¥‡ à¤†à¤£à¤¿ à¤ªà¤°à¥à¤¯à¤¾à¤¯ à¤®à¤²à¤¾ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤£à¥à¤¯à¤¾à¤¤ à¤†à¤²à¥‡ à¤†à¤¹à¥‡à¤¤.
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">à¤°à¥à¤—à¥à¤£/à¤ªà¤¾à¤²à¤• à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div></div>
    <div class="signature-block"><div class="signature-line">à¤µà¥ˆà¤¦à¥à¤¯ à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div></div>
  </div>
</div>
<!-- Hindi Page -->
<div class="page">
  <div class="section">
    <div class="section-title">à¤¸à¤¾à¤®à¤¾à¤¨à¥à¤¯ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¤¹à¤®à¤¤à¤¿</div>
    <div class="section-content">
      à¤®à¥ˆà¤‚ à¤ªà¥à¤°à¤¸à¥à¤¤à¤¾à¤µà¤¿à¤¤ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¤¹à¤®à¤¤à¤¿ à¤¦à¥‡à¤¤à¤¾/à¤¦à¥‡à¤¤à¥€ à¤¹à¥‚à¤‚à¥¤ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤•à¥€ à¤ªà¥à¤°à¤•à¥ƒà¤¤à¤¿, à¤‰à¤¦à¥à¤¦à¥‡à¤¶à¥à¤¯, à¤œà¥‹à¤–à¤¿à¤®, à¤²à¤¾à¤­ à¤”à¤° à¤µà¤¿à¤•à¤²à¥à¤ª à¤®à¥à¤à¥‡ à¤¸à¤®à¤à¤¾à¤ à¤—à¤ à¤¹à¥ˆà¤‚à¥¤
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">à¤°à¥‹à¤—à¥€/à¤…à¤­à¤¿à¤­à¤¾à¤µà¤• à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div></div>
    <div class="signature-block"><div class="signature-line">à¤šà¤¿à¤•à¤¿à¤¤à¥à¤¸à¤• à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div></div>
  </div>
</div>
</body>
</html>`;
          res.setHeader('Content-Type', 'text/html; charset=utf-8');
          return res.send(htmlContent);
        }

        // ========== Minor Procedure ==========
        if (consentType === 'MINOR_PROCEDURE') {
          const patientName = patient ? `${patient.firstName} ${patient.lastName}` : '__________';
          const patientAge = patient?.dateOfBirth ? calculateAge(patient.dateOfBirth) : '__________';
          const patientGender = patient?.gender || '__________';
          const patientUhid = patient?.uhidNumber || patient?.id?.substring(0, 8).toUpperCase() || '__________';
          
          const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Minor/Intermediate Procedure Consent</title>
  <style>
    @page { size: A4; margin: 15mm; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Arial, sans-serif; font-size: 11pt; line-height: 1.6; color: #333; }
    .page { width: 210mm; min-height: 297mm; padding: 15mm; margin: 10mm auto; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); page-break-after: always; }
    .page:last-child { page-break-after: auto; }
    .hospital-header { display: flex; align-items: center; gap: 20px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid #4a2683; }
    .logo-section { display: flex; align-items: center; }
    .hospital-logo { height: 50px; width: auto; }
    .hospital-info { flex: 1; }
    .hospital-name { font-size: 16pt; font-weight: bold; color: #2c5aa0; margin-bottom: 2px; }
    .hospital-address { font-size: 9pt; color: #666; }
    .hospital-contact { font-size: 9pt; color: #333; font-weight: bold; }
    .form-title { text-align: center; font-size: 16pt; font-weight: bold; margin: 20px 0; color: #333; }
    .patient-info-box { border: 1px solid #333; padding: 10px; margin: 15px 0; background: #f9f9f9; display: flex; flex-wrap: wrap; gap: 15px; }
    .patient-info-item { font-size: 10pt; min-width: 150px; }
    .patient-label { font-weight: bold; }
    .dept-date-row { display: flex; justify-content: space-between; margin: 15px 0; font-size: 10pt; }
    .section { margin: 15px 0; }
    .section-title { font-size: 12pt; font-weight: bold; margin-bottom: 8px; color: #2c5aa0; }
    .section-content { text-align: justify; }
    .signature-section { margin-top: 40px; display: flex; justify-content: space-between; }
    .signature-block { text-align: center; width: 45%; }
    .signature-line { border-top: 1px solid #333; margin-top: 40px; padding-top: 5px; }
    @media print { .page { margin: 0; box-shadow: none; } }
  </style>
</head>
<body>
<!-- English Page -->
<div class="page">
  <div class="hospital-header">
    <div class="logo-section">
      <img src="data:image/png;base64,${hospitalLogoBase64}" alt="Hospital Logo" class="hospital-logo" />
    </div>
    <div class="hospital-info">
      <div class="hospital-name">Gravity Hospital & Research Centre</div>
      <div class="hospital-address">123 Medical Drive, Healthcare District<br>City, State - 400001</div>
      <div class="hospital-contact">Phone: +91 22 1234 5678 | Email: info@gravityhospital.com</div>
    </div>
  </div>
  <div class="form-title">Minor/Intermediate Procedure Consent (Consent 2.5)</div>
  <div class="patient-info-box">
    <span class="patient-info-item"><span class="patient-label">Patient Name:</span> ${patientName}</span>
    <span class="patient-info-item"><span class="patient-label">UHID:</span> ${patientUhid}</span>
    <span class="patient-info-item"><span class="patient-label">Gender:</span> ${patientGender}</span>
    <span class="patient-info-item"><span class="patient-label">Age:</span> ${patientAge} years</span>
  </div>
  <div class="dept-date-row">
    <span>Procedure: ______________________</span>
    <span>Date: ____ / ____ / ______</span>
  </div>
  <div class="section">
    <div class="section-title">Consent for Minor/Intermediate Procedure</div>
    <div class="section-content">
      I consent to the minor/intermediate procedure as explained. I understand this includes procedures like wound dressing, catheterization, injections, and similar interventions that carry minimal risk.
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">Patient/Guardian Signature</div></div>
    <div class="signature-block"><div class="signature-line">Physician Signature</div></div>
  </div>
</div>
<!-- Marathi Page -->
<div class="page">
  <div class="section">
    <div class="section-title">à¤•à¤¿à¤°à¤•à¥‹à¤³/à¤®à¤§à¥à¤¯à¤µà¤°à¥à¤¤à¥€ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¥‡à¤¸à¤¾à¤ à¥€ à¤¸à¤‚à¤®à¤¤à¥€</div>
    <div class="section-content">
      à¤®à¥€ à¤¸à¤®à¤œà¤¾à¤µà¥‚à¤¨ à¤¸à¤¾à¤‚à¤—à¤¿à¤¤à¤²à¥à¤¯à¤¾à¤ªà¥à¤°à¤®à¤¾à¤£à¥‡ à¤•à¤¿à¤°à¤•à¥‹à¤³/à¤®à¤§à¥à¤¯à¤µà¤°à¥à¤¤à¥€ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¥‡à¤¸à¤¾à¤ à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¦à¥‡à¤¤à¥‹. à¤¯à¤¾à¤®à¤§à¥à¤¯à¥‡ à¤œà¤–à¤®à¥‡à¤šà¥€ à¤¡à¥à¤°à¥‡à¤¸à¤¿à¤‚à¤—, à¤•à¥…à¤¥à¥‡à¤Ÿà¤°à¤¾à¤¯à¤à¥‡à¤¶à¤¨, à¤‡à¤‚à¤œà¥‡à¤•à¥à¤¶à¤¨à¥à¤¸ à¤†à¤£à¤¿ à¤¤à¤¤à¥à¤¸à¤® à¤¹à¤¸à¥à¤¤à¤•à¥à¤·à¥‡à¤ª à¤¸à¤®à¤¾à¤µà¤¿à¤·à¥à¤Ÿ à¤†à¤¹à¥‡à¤¤.
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">à¤°à¥à¤—à¥à¤£/à¤ªà¤¾à¤²à¤• à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div></div>
    <div class="signature-block"><div class="signature-line">à¤µà¥ˆà¤¦à¥à¤¯ à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div></div>
  </div>
</div>
<!-- Hindi Page -->
<div class="page">
  <div class="section">
    <div class="section-title">à¤›à¥‹à¤Ÿà¥€/à¤®à¤§à¥à¤¯à¤µà¤°à¥à¤¤à¥€ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¤¹à¤®à¤¤à¤¿</div>
    <div class="section-content">
      à¤®à¥ˆà¤‚ à¤¸à¤®à¤à¤¾à¤ˆ à¤—à¤ˆ à¤›à¥‹à¤Ÿà¥€/à¤®à¤§à¥à¤¯à¤µà¤°à¥à¤¤à¥€ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¤¹à¤®à¤¤à¤¿ à¤¦à¥‡à¤¤à¤¾/à¤¦à¥‡à¤¤à¥€ à¤¹à¥‚à¤‚à¥¤ à¤‡à¤¸à¤®à¥‡à¤‚ à¤˜à¤¾à¤µ à¤¡à¥à¤°à¥‡à¤¸à¤¿à¤‚à¤—, à¤•à¥ˆà¤¥à¥€à¤Ÿà¥‡à¤°à¤¾à¤‡à¤œà¥‡à¤¶à¤¨, à¤‡à¤‚à¤œà¥‡à¤•à¥à¤¶à¤¨ à¤”à¤° à¤‡à¤¸à¥€ à¤¤à¤°à¤¹ à¤•à¥‡ à¤¹à¤¸à¥à¤¤à¤•à¥à¤·à¥‡à¤ª à¤¶à¤¾à¤®à¤¿à¤² à¤¹à¥ˆà¤‚à¥¤
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">à¤°à¥‹à¤—à¥€/à¤…à¤­à¤¿à¤­à¤¾à¤µà¤• à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div></div>
    <div class="signature-block"><div class="signature-line">à¤šà¤¿à¤•à¤¿à¤¤à¥à¤¸à¤• à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div></div>
  </div>
</div>
</body>
</html>`;
          res.setHeader('Content-Type', 'text/html; charset=utf-8');
          return res.send(htmlContent);
        }

        // ========== Physiotherapy ==========
        if (consentType === 'PHYSIOTHERAPY') {
          const patientName = patient ? `${patient.firstName} ${patient.lastName}` : '__________';
          const patientAge = patient?.dateOfBirth ? calculateAge(patient.dateOfBirth) : '__________';
          const patientGender = patient?.gender || '__________';
          const patientUhid = patient?.uhidNumber || patient?.id?.substring(0, 8).toUpperCase() || '__________';
          
          const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Physiotherapy Consent</title>
  <style>
    @page { size: A4; margin: 15mm; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Arial, sans-serif; font-size: 11pt; line-height: 1.6; color: #333; }
    .page { width: 210mm; min-height: 297mm; padding: 15mm; margin: 10mm auto; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); page-break-after: always; }
    .page:last-child { page-break-after: auto; }
    .hospital-header { display: flex; align-items: center; gap: 20px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid #4a2683; }
    .logo-section { display: flex; align-items: center; }
    .hospital-logo { height: 50px; width: auto; }
    .hospital-info { flex: 1; }
    .hospital-name { font-size: 16pt; font-weight: bold; color: #2c5aa0; margin-bottom: 2px; }
    .hospital-address { font-size: 9pt; color: #666; }
    .hospital-contact { font-size: 9pt; color: #333; font-weight: bold; }
    .form-title { text-align: center; font-size: 16pt; font-weight: bold; margin: 20px 0; color: #333; }
    .patient-info-box { border: 1px solid #333; padding: 10px; margin: 15px 0; background: #f9f9f9; display: flex; flex-wrap: wrap; gap: 15px; }
    .patient-info-item { font-size: 10pt; min-width: 150px; }
    .patient-label { font-weight: bold; }
    .dept-date-row { display: flex; justify-content: space-between; margin: 15px 0; font-size: 10pt; }
    .section { margin: 15px 0; }
    .section-title { font-size: 12pt; font-weight: bold; margin-bottom: 8px; color: #2c5aa0; }
    .section-content { text-align: justify; }
    .signature-section { margin-top: 40px; display: flex; justify-content: space-between; }
    .signature-block { text-align: center; width: 45%; }
    .signature-line { border-top: 1px solid #333; margin-top: 40px; padding-top: 5px; }
    @media print { .page { margin: 0; box-shadow: none; } }
  </style>
</head>
<body>
<!-- English Page -->
<div class="page">
  <div class="hospital-header">
    <div class="logo-section">
      <img src="data:image/png;base64,${hospitalLogoBase64}" alt="Hospital Logo" class="hospital-logo" />
    </div>
    <div class="hospital-info">
      <div class="hospital-name">Gravity Hospital & Research Centre</div>
      <div class="hospital-address">123 Medical Drive, Healthcare District<br>City, State - 400001</div>
      <div class="hospital-contact">Phone: +91 22 1234 5678 | Email: info@gravityhospital.com</div>
    </div>
  </div>
  <div class="form-title">Physiotherapy Consent</div>
  <div class="patient-info-box">
    <span class="patient-info-item"><span class="patient-label">Patient Name:</span> ${patientName}</span>
    <span class="patient-info-item"><span class="patient-label">UHID:</span> ${patientUhid}</span>
    <span class="patient-info-item"><span class="patient-label">Gender:</span> ${patientGender}</span>
    <span class="patient-info-item"><span class="patient-label">Age:</span> ${patientAge} years</span>
  </div>
  <div class="dept-date-row">
    <span>Department: ______________________</span>
    <span>Date: ____ / ____ / ______</span>
  </div>
  <div class="section">
    <div class="section-title">Consent for Physiotherapy Treatment</div>
    <div class="section-content">
      I consent to physiotherapy treatment including exercises, manual therapy, electrotherapy, and rehabilitation techniques. I understand the treatment plan and potential risks have been explained to me.
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">Patient/Guardian Signature</div></div>
    <div class="signature-block"><div class="signature-line">Physiotherapist Signature</div></div>
  </div>
</div>
<!-- Marathi Page -->
<div class="page">
  <div class="section">
    <div class="section-title">à¤«à¤¿à¤œà¤¿à¤“à¤¥à¥‡à¤°à¤ªà¥€ à¤‰à¤ªà¤šà¤¾à¤°à¤¾à¤¸à¤¾à¤ à¥€ à¤¸à¤‚à¤®à¤¤à¥€</div>
    <div class="section-content">
      à¤®à¥€ à¤µà¥à¤¯à¤¾à¤¯à¤¾à¤®, à¤®à¥…à¤¨à¥à¤¯à¥à¤…à¤² à¤¥à¥‡à¤°à¤ªà¥€, à¤‡à¤²à¥‡à¤•à¥à¤Ÿà¥à¤°à¥‹à¤¥à¥‡à¤°à¤ªà¥€ à¤†à¤£à¤¿ à¤ªà¥à¤¨à¤°à¥à¤µà¤¸à¤¨ à¤¤à¤‚à¤¤à¥à¤°à¤¾à¤‚à¤¸à¤¹ à¤«à¤¿à¤œà¤¿à¤“à¤¥à¥‡à¤°à¤ªà¥€ à¤‰à¤ªà¤šà¤¾à¤°à¤¾à¤¸à¤¾à¤ à¥€ à¤¸à¤‚à¤®à¤¤à¥€ à¤¦à¥‡à¤¤à¥‹.
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">à¤°à¥à¤—à¥à¤£/à¤ªà¤¾à¤²à¤• à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div></div>
    <div class="signature-block"><div class="signature-line">à¤«à¤¿à¤œà¤¿à¤“à¤¥à¥‡à¤°à¤ªà¤¿à¤¸à¥à¤Ÿ à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div></div>
  </div>
</div>
<!-- Hindi Page -->
<div class="page">
  <div class="section">
    <div class="section-title">à¤«à¤¿à¤œà¤¿à¤¯à¥‹à¤¥à¥‡à¤°à¥‡à¤ªà¥€ à¤‰à¤ªà¤šà¤¾à¤° à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¤¹à¤®à¤¤à¤¿</div>
    <div class="section-content">
      à¤®à¥ˆà¤‚ à¤µà¥à¤¯à¤¾à¤¯à¤¾à¤®, à¤®à¥ˆà¤¨à¥à¤…à¤² à¤¥à¥‡à¤°à¥‡à¤ªà¥€, à¤‡à¤²à¥‡à¤•à¥à¤Ÿà¥à¤°à¥‹à¤¥à¥‡à¤°à¥‡à¤ªà¥€ à¤”à¤° à¤ªà¥à¤¨à¤°à¥à¤µà¤¾à¤¸ à¤¤à¤•à¤¨à¥€à¤•à¥‹à¤‚ à¤¸à¤¹à¤¿à¤¤ à¤«à¤¿à¤œà¤¿à¤¯à¥‹à¤¥à¥‡à¤°à¥‡à¤ªà¥€ à¤‰à¤ªà¤šà¤¾à¤° à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¤¹à¤®à¤¤à¤¿ à¤¦à¥‡à¤¤à¤¾/à¤¦à¥‡à¤¤à¥€ à¤¹à¥‚à¤‚à¥¤
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">à¤°à¥‹à¤—à¥€/à¤…à¤­à¤¿à¤­à¤¾à¤µà¤• à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div></div>
    <div class="signature-block"><div class="signature-line">à¤«à¤¿à¤œà¤¿à¤¯à¥‹à¤¥à¥‡à¤°à¥‡à¤ªà¤¿à¤¸à¥à¤Ÿ à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div></div>
  </div>
</div>
</body>
</html>`;
          res.setHeader('Content-Type', 'text/html; charset=utf-8');
          return res.send(htmlContent);
        }

        // ========== Recovery Sheet ==========
        if (consentType === 'RECOVERY_SHEET') {
          const patientName = patient ? `${patient.firstName} ${patient.lastName}` : '__________';
          const patientAge = patient?.dateOfBirth ? calculateAge(patient.dateOfBirth) : '__________';
          const patientGender = patient?.gender || '__________';
          const patientUhid = patient?.uhidNumber || patient?.id?.substring(0, 8).toUpperCase() || '__________';
          
          const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Recovery Sheet Acknowledgement</title>
  <style>
    @page { size: A4; margin: 15mm; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Arial, sans-serif; font-size: 11pt; line-height: 1.6; color: #333; }
    .page { width: 210mm; min-height: 297mm; padding: 15mm; margin: 10mm auto; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); page-break-after: always; }
    .page:last-child { page-break-after: auto; }
    .hospital-header { display: flex; align-items: center; gap: 20px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid #4a2683; }
    .logo-section { display: flex; align-items: center; }
    .hospital-logo { height: 50px; width: auto; }
    .hospital-info { flex: 1; }
    .hospital-name { font-size: 16pt; font-weight: bold; color: #2c5aa0; margin-bottom: 2px; }
    .hospital-address { font-size: 9pt; color: #666; }
    .hospital-contact { font-size: 9pt; color: #333; font-weight: bold; }
    .form-title { text-align: center; font-size: 16pt; font-weight: bold; margin: 20px 0; color: #333; }
    .patient-info-box { border: 1px solid #333; padding: 10px; margin: 15px 0; background: #f9f9f9; display: flex; flex-wrap: wrap; gap: 15px; }
    .patient-info-item { font-size: 10pt; min-width: 150px; }
    .patient-label { font-weight: bold; }
    .dept-date-row { display: flex; justify-content: space-between; margin: 15px 0; font-size: 10pt; }
    .section { margin: 15px 0; }
    .section-title { font-size: 12pt; font-weight: bold; margin-bottom: 8px; color: #2c5aa0; }
    .section-content { text-align: justify; }
    .signature-section { margin-top: 40px; display: flex; justify-content: space-between; }
    .signature-block { text-align: center; width: 45%; }
    .signature-line { border-top: 1px solid #333; margin-top: 40px; padding-top: 5px; }
    @media print { .page { margin: 0; box-shadow: none; } }
  </style>
</head>
<body>
<!-- English Page -->
<div class="page">
  <div class="hospital-header">
    <div class="logo-section">
      <img src="data:image/png;base64,${hospitalLogoBase64}" alt="Hospital Logo" class="hospital-logo" />
    </div>
    <div class="hospital-info">
      <div class="hospital-name">Gravity Hospital & Research Centre</div>
      <div class="hospital-address">123 Medical Drive, Healthcare District<br>City, State - 400001</div>
      <div class="hospital-contact">Phone: +91 22 1234 5678 | Email: info@gravityhospital.com</div>
    </div>
  </div>
  <div class="form-title">Recovery Sheet Acknowledgement</div>
  <div class="patient-info-box">
    <span class="patient-info-item"><span class="patient-label">Patient Name:</span> ${patientName}</span>
    <span class="patient-info-item"><span class="patient-label">UHID:</span> ${patientUhid}</span>
    <span class="patient-info-item"><span class="patient-label">Gender:</span> ${patientGender}</span>
    <span class="patient-info-item"><span class="patient-label">Age:</span> ${patientAge} years</span>
  </div>
  <div class="dept-date-row">
    <span>Department: ______________________</span>
    <span>Date: ____ / ____ / ______</span>
  </div>
  <div class="section">
    <div class="section-title">Post-Procedure Recovery Acknowledgement</div>
    <div class="section-content">
      I acknowledge receiving post-procedure recovery instructions including medication schedule, wound care, activity restrictions, follow-up appointments, and warning signs to watch for. I understand when to seek emergency care.
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">Patient/Guardian Signature</div></div>
    <div class="signature-block"><div class="signature-line">Nurse/Physician Signature</div></div>
  </div>
</div>
<!-- Marathi Page -->
<div class="page">
  <div class="section">
    <div class="section-title">à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¥‡à¤¨à¤‚à¤¤à¤° à¤ªà¥à¤¨à¤°à¥à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤à¥€ à¤ªà¥‹à¤šà¤ªà¤¾à¤µà¤¤à¥€</div>
    <div class="section-content">
      à¤®à¥€ à¤”à¤·à¤§ à¤µà¥‡à¤³à¤¾à¤ªà¤¤à¥à¤°à¤•, à¤œà¤–à¤®à¥‡à¤šà¥€ à¤•à¤¾à¤³à¤œà¥€, à¤•à¥à¤°à¤¿à¤¯à¤¾à¤•à¤²à¤¾à¤ª à¤¨à¤¿à¤°à¥à¤¬à¤‚à¤§, à¤«à¥‰à¤²à¥‹-à¤…à¤ª à¤­à¥‡à¤Ÿà¥€ à¤†à¤£à¤¿ à¤²à¤•à¥à¤·à¤£à¥‡ à¤¯à¤¾à¤‚à¤¸à¤¹ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¥‡à¤¨à¤‚à¤¤à¤° à¤ªà¥à¤¨à¤°à¥à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤à¥€ à¤¸à¥‚à¤šà¤¨à¤¾ à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤ à¤•à¥‡à¤²à¥à¤¯à¤¾à¤šà¥€ à¤ªà¥‹à¤šà¤ªà¤¾à¤µà¤¤à¥€ à¤¦à¥‡à¤¤à¥‹.
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">à¤°à¥à¤—à¥à¤£/à¤ªà¤¾à¤²à¤• à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div></div>
    <div class="signature-block"><div class="signature-line">à¤¨à¤°à¥à¤¸/à¤µà¥ˆà¤¦à¥à¤¯ à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div></div>
  </div>
</div>
<!-- Hindi Page -->
<div class="page">
  <div class="section">
    <div class="section-title">à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤•à¥‡ à¤¬à¤¾à¤¦ à¤°à¤¿à¤•à¤µà¤°à¥€ à¤ªà¤¾à¤µà¤¤à¥€</div>
    <div class="section-content">
      à¤®à¥ˆà¤‚ à¤¦à¤µà¤¾ à¤…à¤¨à¥à¤¸à¥‚à¤šà¥€, à¤˜à¤¾à¤µ à¤¦à¥‡à¤–à¤­à¤¾à¤², à¤—à¤¤à¤¿à¤µà¤¿à¤§à¤¿ à¤ªà¥à¤°à¤¤à¤¿à¤¬à¤‚à¤§, à¤«à¥‰à¤²à¥‹-à¤…à¤ª à¤…à¤ªà¥‰à¤‡à¤‚à¤Ÿà¤®à¥‡à¤‚à¤Ÿ à¤”à¤° à¤šà¥‡à¤¤à¤¾à¤µà¤¨à¥€ à¤¸à¤‚à¤•à¥‡à¤¤à¥‹à¤‚ à¤¸à¤¹à¤¿à¤¤ à¤ªà¥à¤°à¤•à¥à¤°à¤¿à¤¯à¤¾ à¤•à¥‡ à¤¬à¤¾à¤¦ à¤°à¤¿à¤•à¤µà¤°à¥€ à¤¨à¤¿à¤°à¥à¤¦à¥‡à¤¶ à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤ à¤•à¤°à¤¨à¥‡ à¤•à¥€ à¤ªà¤¾à¤µà¤¤à¥€ à¤¦à¥‡à¤¤à¤¾/à¤¦à¥‡à¤¤à¥€ à¤¹à¥‚à¤‚à¥¤
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">à¤°à¥‹à¤—à¥€/à¤…à¤­à¤¿à¤­à¤¾à¤µà¤• à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div></div>
    <div class="signature-block"><div class="signature-line">à¤¨à¤°à¥à¤¸/à¤šà¤¿à¤•à¤¿à¤¤à¥à¤¸à¤• à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div></div>
  </div>
</div>
</body>
</html>`;
          res.setHeader('Content-Type', 'text/html; charset=utf-8');
          return res.send(htmlContent);
        }

        // ========== Anaesthesia Type ==========
        if (consentType === 'ANAESTHESIA_TYPE') {
          const patientName = patient ? `${patient.firstName} ${patient.lastName}` : '__________';
          const patientAge = patient?.dateOfBirth ? calculateAge(patient.dateOfBirth) : '__________';
          const patientGender = patient?.gender || '__________';
          const patientUhid = patient?.uhidNumber || patient?.id?.substring(0, 8).toUpperCase() || '__________';
          
          const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Anaesthesia Type-Wise Consent</title>
  <style>
    @page { size: A4; margin: 15mm; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Arial, sans-serif; font-size: 11pt; line-height: 1.6; color: #333; }
    .page { width: 210mm; min-height: 297mm; padding: 15mm; margin: 10mm auto; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); page-break-after: always; }
    .page:last-child { page-break-after: auto; }
    .hospital-header { display: flex; align-items: center; gap: 20px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid #4a2683; }
    .logo-section { display: flex; align-items: center; }
    .hospital-logo { height: 50px; width: auto; }
    .hospital-info { flex: 1; }
    .hospital-name { font-size: 16pt; font-weight: bold; color: #2c5aa0; margin-bottom: 2px; }
    .hospital-address { font-size: 9pt; color: #666; }
    .hospital-contact { font-size: 9pt; color: #333; font-weight: bold; }
    .form-title { text-align: center; font-size: 16pt; font-weight: bold; margin: 20px 0; color: #333; }
    .patient-info-box { border: 1px solid #333; padding: 10px; margin: 15px 0; background: #f9f9f9; display: flex; flex-wrap: wrap; gap: 15px; }
    .patient-info-item { font-size: 10pt; min-width: 150px; }
    .patient-label { font-weight: bold; }
    .dept-date-row { display: flex; justify-content: space-between; margin: 15px 0; font-size: 10pt; }
    .section { margin: 15px 0; }
    .section-title { font-size: 12pt; font-weight: bold; margin-bottom: 8px; color: #2c5aa0; }
    .section-content { text-align: justify; }
    .checkbox-item { display: flex; align-items: flex-start; gap: 8px; margin: 8px 0; }
    .checkbox { width: 14px; height: 14px; border: 1px solid #333; display: inline-block; flex-shrink: 0; margin-top: 3px; }
    .signature-section { margin-top: 40px; display: flex; justify-content: space-between; }
    .signature-block { text-align: center; width: 45%; }
    .signature-line { border-top: 1px solid #333; margin-top: 40px; padding-top: 5px; }
    @media print { .page { margin: 0; box-shadow: none; } }
  </style>
</head>
<body>
<!-- English Page -->
<div class="page">
  <div class="hospital-header">
    <div class="logo-section">
      <img src="data:image/png;base64,${hospitalLogoBase64}" alt="Hospital Logo" class="hospital-logo" />
    </div>
    <div class="hospital-info">
      <div class="hospital-name">Gravity Hospital & Research Centre</div>
      <div class="hospital-address">123 Medical Drive, Healthcare District<br>City, State - 400001</div>
      <div class="hospital-contact">Phone: +91 22 1234 5678 | Email: info@gravityhospital.com</div>
    </div>
  </div>
  <div class="form-title">Anaesthesia Type-Wise Consent</div>
  <div class="patient-info-box">
    <span class="patient-info-item"><span class="patient-label">Patient Name:</span> ${patientName}</span>
    <span class="patient-info-item"><span class="patient-label">UHID:</span> ${patientUhid}</span>
    <span class="patient-info-item"><span class="patient-label">Gender:</span> ${patientGender}</span>
    <span class="patient-info-item"><span class="patient-label">Age:</span> ${patientAge} years</span>
  </div>
  <div class="dept-date-row">
    <span>Procedure: ______________________</span>
    <span>Date: ____ / ____ / ______</span>
  </div>
  <div class="section">
    <div class="section-title">Type of Anaesthesia (Select applicable)</div>
    <div class="section-content">
      <div class="checkbox-item"><span class="checkbox"></span> General Anaesthesia</div>
      <div class="checkbox-item"><span class="checkbox"></span> Spinal Anaesthesia</div>
      <div class="checkbox-item"><span class="checkbox"></span> Epidural Anaesthesia</div>
      <div class="checkbox-item"><span class="checkbox"></span> Regional/Local Anaesthesia</div>
      <div class="checkbox-item"><span class="checkbox"></span> Sedation</div>
    </div>
  </div>
  <div class="section">
    <div class="section-title">Consent</div>
    <div class="section-content">
      I consent to the selected type of anaesthesia. The risks including allergic reactions, breathing difficulties, nerve damage, and other complications have been explained to me.
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">Patient/Guardian Signature</div></div>
    <div class="signature-block"><div class="signature-line">Anaesthetist Signature</div></div>
  </div>
</div>
<!-- Marathi Page -->
<div class="page">
  <div class="section">
    <div class="section-title">à¤­à¥‚à¤² à¤ªà¥à¤°à¤•à¤¾à¤° (à¤²à¤¾à¤—à¥‚ à¤…à¤¸à¤²à¥‡à¤²à¥‡ à¤¨à¤¿à¤µà¤¡à¤¾)</div>
    <div class="section-content">
      <div class="checkbox-item"><span class="checkbox"></span> à¤¸à¤¾à¤®à¤¾à¤¨à¥à¤¯ à¤­à¥‚à¤²</div>
      <div class="checkbox-item"><span class="checkbox"></span> à¤¸à¥à¤ªà¤¾à¤¯à¤¨à¤² à¤­à¥‚à¤²</div>
      <div class="checkbox-item"><span class="checkbox"></span> à¤à¤ªà¤¿à¤¡à¥à¤¯à¥à¤°à¤² à¤­à¥‚à¤²</div>
      <div class="checkbox-item"><span class="checkbox"></span> à¤¸à¥à¤¥à¤¾à¤¨à¤¿à¤• à¤­à¥‚à¤²</div>
      <div class="checkbox-item"><span class="checkbox"></span> à¤¶à¤¾à¤®à¤• à¤”à¤·à¤§</div>
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">à¤°à¥à¤—à¥à¤£/à¤ªà¤¾à¤²à¤• à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div></div>
    <div class="signature-block"><div class="signature-line">à¤­à¥‚à¤²à¤¤à¤œà¥à¤ž à¤¸à¥à¤µà¤¾à¤•à¥à¤·à¤°à¥€</div></div>
  </div>
</div>
<!-- Hindi Page -->
<div class="page">
  <div class="section">
    <div class="section-title">à¤à¤¨à¥‡à¤¸à¥à¤¥à¥€à¤¸à¤¿à¤¯à¤¾ à¤ªà¥à¤°à¤•à¤¾à¤° (à¤²à¤¾à¤—à¥‚ à¤•à¤¾ à¤šà¤¯à¤¨ à¤•à¤°à¥‡à¤‚)</div>
    <div class="section-content">
      <div class="checkbox-item"><span class="checkbox"></span> à¤¸à¤¾à¤®à¤¾à¤¨à¥à¤¯ à¤à¤¨à¥‡à¤¸à¥à¤¥à¥€à¤¸à¤¿à¤¯à¤¾</div>
      <div class="checkbox-item"><span class="checkbox"></span> à¤¸à¥à¤ªà¤¾à¤‡à¤¨à¤² à¤à¤¨à¥‡à¤¸à¥à¤¥à¥€à¤¸à¤¿à¤¯à¤¾</div>
      <div class="checkbox-item"><span class="checkbox"></span> à¤à¤ªà¤¿à¤¡à¥à¤¯à¥‚à¤°à¤² à¤à¤¨à¥‡à¤¸à¥à¤¥à¥€à¤¸à¤¿à¤¯à¤¾</div>
      <div class="checkbox-item"><span class="checkbox"></span> à¤¸à¥à¤¥à¤¾à¤¨à¥€à¤¯ à¤à¤¨à¥‡à¤¸à¥à¤¥à¥€à¤¸à¤¿à¤¯à¤¾</div>
      <div class="checkbox-item"><span class="checkbox"></span> à¤¸à¥‡à¤¡à¥‡à¤¶à¤¨</div>
    </div>
  </div>
  <div class="signature-section">
    <div class="signature-block"><div class="signature-line">à¤°à¥‹à¤—à¥€/à¤…à¤­à¤¿à¤­à¤¾à¤µà¤• à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div></div>
    <div class="signature-block"><div class="signature-line">à¤à¤¨à¥‡à¤¸à¥à¤¥à¥‡à¤Ÿà¤¿à¤¸à¥à¤Ÿ à¤¹à¤¸à¥à¤¤à¤¾à¤•à¥à¤·à¤°</div></div>
  </div>
</div>
</body>
</html>`;
          res.setHeader('Content-Type', 'text/html; charset=utf-8');
          return res.send(htmlContent);
        }
        
        return res.status(404).json({ error: "Unknown dynamic consent form type" });
      }

      // Read the original PDF file - files are stored in server/public/consents/
      const pdfPath = path.join(process.cwd(), 'server/public', template.pdfPath);
      if (!fs.existsSync(pdfPath)) {
        console.error(`PDF file not found at: ${pdfPath}`);
        return res.status(404).json({ error: "PDF file not found" });
      }

      const pdfBytes = fs.readFileSync(pdfPath);
      
      // Use pdf-lib to modify the PDF with patient details
      const { PDFDocument, rgb, StandardFonts } = await import('pdf-lib');
      const pdfDoc = await PDFDocument.load(pdfBytes);
      const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
      const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
      
      const pages = pdfDoc.getPages();
      const firstPage = pages[0];
      const { width, height } = firstPage.getSize();
      
      // ============ PROFESSIONAL HOSPITAL HEADER FOR ALL CONSENT FORMS ============
      
      // Embed hospital logo
      const logoPath = path.join(process.cwd(), 'server/public/hospital-logo.png');
      let logoImage = null;
      if (fs.existsSync(logoPath)) {
        const logoBytes = fs.readFileSync(logoPath);
        logoImage = await pdfDoc.embedPng(logoBytes);
      }
      
      // Header dimensions (logo should be 60-80px height as per requirements)
      const headerStartY = height - 15;
      const logoWidth = 180;
      const logoHeight = 70;
      const leftMargin = 30;
      const rightMargin = width - 30;
      
      // Draw hospital logo at top-left
      if (logoImage) {
        const logoDims = logoImage.scale(logoWidth / logoImage.width);
        firstPage.drawImage(logoImage, {
          x: leftMargin,
          y: headerStartY - logoHeight,
          width: logoWidth,
          height: logoDims.height > logoHeight ? logoHeight : logoDims.height,
        });
      }
      
      // Hospital details to the right of logo
      const textStartX = leftMargin + logoWidth + 15;
      const hospitalNameColor = rgb(0.29, 0.15, 0.55); // Purple color matching logo
      
      // Hospital Name (Bold, larger font)
      firstPage.drawText('Gravity Hospital & Research Centre', {
        x: textStartX,
        y: headerStartY - 20,
        size: 15,
        font: helveticaBold,
        color: hospitalNameColor,
      });
      
      // Hospital Address
      firstPage.drawText('Gat No. 167, Sahyog Nagar, Triveni Nagar Chowk,', {
        x: textStartX,
        y: headerStartY - 36,
        size: 9,
        font: helveticaFont,
        color: rgb(0.3, 0.3, 0.3),
      });
      
      firstPage.drawText('Pimpri-Chinchwad, Maharashtra - 411062', {
        x: textStartX,
        y: headerStartY - 49,
        size: 9,
        font: helveticaFont,
        color: rgb(0.3, 0.3, 0.3),
      });
      
      // Contact Numbers
      firstPage.drawText('Contact: 7796513130, 7769651310', {
        x: textStartX,
        y: headerStartY - 63,
        size: 9,
        font: helveticaBold,
        color: rgb(0.2, 0.2, 0.2),
      });
      
      // Horizontal divider line below hospital details
      const dividerY = headerStartY - 78;
      firstPage.drawLine({
        start: { x: leftMargin, y: dividerY },
        end: { x: rightMargin, y: dividerY },
        thickness: 1.5,
        color: hospitalNameColor,
      });
      
      // Patient Information Row below divider
      const patientRowY = dividerY - 18;
      const patientName = patient ? `${patient.firstName} ${patient.lastName}` : '____________';
      const patientUHID = patient?.id ? patient.id.substring(0, 8).toUpperCase() : '____________';
      const patientGender = patient?.gender || '____________';
      
      // Calculate age from date of birth
      let patientAge = '____________';
      if (patient?.dateOfBirth) {
        const dob = new Date(patient.dateOfBirth);
        const today = new Date();
        let age = today.getFullYear() - dob.getFullYear();
        const monthDiff = today.getMonth() - dob.getMonth();
        if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < dob.getDate())) {
          age--;
        }
        patientAge = `${age} years`;
      }
      
      // Draw patient info labels and values in a row
      const labelColor = rgb(0.3, 0.3, 0.3);
      const valueColor = rgb(0, 0, 0);
      
      // Patient Name
      firstPage.drawText('Patient Name:', {
        x: leftMargin,
        y: patientRowY,
        size: 9,
        font: helveticaBold,
        color: labelColor,
      });
      firstPage.drawText(patientName, {
        x: leftMargin + 70,
        y: patientRowY,
        size: 10,
        font: helveticaFont,
        color: valueColor,
      });
      
      // UHID No
      firstPage.drawText('UHID No:', {
        x: 200,
        y: patientRowY,
        size: 9,
        font: helveticaBold,
        color: labelColor,
      });
      firstPage.drawText(patientUHID, {
        x: 248,
        y: patientRowY,
        size: 10,
        font: helveticaFont,
        color: valueColor,
      });
      
      // Gender
      firstPage.drawText('Gender:', {
        x: 350,
        y: patientRowY,
        size: 9,
        font: helveticaBold,
        color: labelColor,
      });
      firstPage.drawText(patientGender, {
        x: 392,
        y: patientRowY,
        size: 10,
        font: helveticaFont,
        color: valueColor,
      });
      
      // Age
      firstPage.drawText('Age:', {
        x: 470,
        y: patientRowY,
        size: 9,
        font: helveticaBold,
        color: labelColor,
      });
      firstPage.drawText(patientAge, {
        x: 495,
        y: patientRowY,
        size: 10,
        font: helveticaFont,
        color: valueColor,
      });
      
      // Second divider line below patient info
      const secondDividerY = patientRowY - 10;
      firstPage.drawLine({
        start: { x: leftMargin, y: secondDividerY },
        end: { x: rightMargin, y: secondDividerY },
        thickness: 0.5,
        color: rgb(0.7, 0.7, 0.7),
      });
      
      // Save the modified PDF
      const modifiedPdfBytes = await pdfDoc.save();
      
      // Send the PDF as response
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `inline; filename="${template.title.replace(/\s+/g, '_')}.pdf"`);
      res.send(Buffer.from(modifiedPdfBytes));
      
    } catch (error) {
      console.error("Failed to render consent template:", error);
      res.status(500).json({ error: "Failed to render consent template" });
    }
  });

  // ========== SERVICE PATIENTS API ==========
  
  // Get all service patients (requires authentication)
  app.get("/api/service-patients", async (req, res) => {
    try {
      // Check authentication via headers or session
      const userId = req.headers['x-user-id'] as string;
      const userRole = req.headers['x-user-role'] as string;
      
      // Only allow authenticated users with appropriate roles
      const allowedRoles = ['ADMIN', 'DOCTOR', 'NURSE', 'OPD_MANAGER'];
      if (!userId || !userRole || !allowedRoles.includes(userRole)) {
        return res.status(403).json({ error: "Access denied. Insufficient permissions to view patient data." });
      }
      
      const patients = await db.select().from(servicePatients).orderBy(desc(servicePatients.createdAt));
      res.json(patients);
    } catch (error) {
      console.error("Failed to fetch service patients:", error);
      res.status(500).json({ error: "Failed to fetch service patients" });
    }
  });

  // Get single service patient by ID (requires authentication)
  app.get("/api/service-patients/:id", async (req, res) => {
    try {
      // Check authentication via headers or session
      const userId = req.headers['x-user-id'] as string;
      const userRole = req.headers['x-user-role'] as string;
      
      // Only allow authenticated users with appropriate roles
      const allowedRoles = ['ADMIN', 'DOCTOR', 'NURSE', 'OPD_MANAGER'];
      if (!userId || !userRole || !allowedRoles.includes(userRole)) {
        return res.status(403).json({ error: "Access denied. Insufficient permissions to view patient data." });
      }
      
      const [patient] = await db.select().from(servicePatients).where(eq(servicePatients.id, req.params.id));
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }
      res.json(patient);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patient" });
    }
  });

  // Get complete longitudinal patient profile (all history sections)
  app.get("/api/service-patients/:id/longitudinal-profile", async (req, res) => {
    try {
      const userId = req.headers['x-user-id'] as string;
      const userRole = req.headers['x-user-role'] as string;
      
      const allowedRoles = ['ADMIN', 'DOCTOR', 'NURSE', 'OPD_MANAGER', 'SUPER_ADMIN'];
      if (!userId || !userRole || !allowedRoles.includes(userRole)) {
        return res.status(403).json({ error: "Access denied" });
      }
      
      const patientId = req.params.id;
      
      // Get patient basic info
      const [patient] = await db.select().from(servicePatients).where(eq(servicePatients.id, patientId));
      if (!patient) {
        return res.status(404).json({ error: "Patient not found" });
      }
      
      // Use patient name for lookups in tables that don't have patientId FK
      const patientName = `${patient.firstName} ${patient.lastName}`.trim();
      
      // 1. OPD History - Get appointments by patient name or patient ID
      let opdHistory: any[] = [];
      try {
        opdHistory = await db.select().from(appointments)
          .where(or(
            eq(appointments.patientName, patientName),
            eq(appointments.patientId, patientId)
          ))
          .orderBy(desc(appointments.createdAt));
      } catch (e) { console.log("No OPD history found"); }
      
      // 2. IPD History - Get tracking patient data by patient name
      let ipdHistory: any[] = [];
      try {
        ipdHistory = await db.select().from(trackingPatients)
          .where(eq(trackingPatients.name, patientName))
          .orderBy(desc(trackingPatients.admissionDate));
      } catch (e) { console.log("No IPD history found"); }
      
      // 3. Medication History - Get prescriptions by patientId
      let medicationHistory: any[] = [];
      try {
        medicationHistory = await db.select().from(prescriptions)
          .where(eq(prescriptions.patientId, patientId))
          .orderBy(desc(prescriptions.createdAt));
      } catch (e) { console.log("No medication history found"); }
      
      // 4. Consent Records - Get patient consents
      let consentRecords: any[] = [];
      try {
        consentRecords = await db.select().from(patientConsents)
          .where(eq(patientConsents.patientId, patientId))
          .orderBy(desc(patientConsents.uploadedAt));
      } catch (e) { console.log("No consent records found"); }
      
      // 5. Billing History
      let bills: any[] = [];
      let payments: any[] = [];
      let insurance: any[] = [];
      try {
        bills = await db.select().from(patientBills)
          .where(eq(patientBills.patientId, patientId))
          .orderBy(desc(patientBills.createdAt));
        
        if (bills.length > 0) {
          const billIds = bills.map(b => b.id);
          payments = await db.select().from(billPayments)
            .where(sql`${billPayments.billId} IN (${sql.join(billIds.map(id => sql`${id}`), sql`, `)})`);
        }
        
        insurance = await db.select().from(patientInsurance)
          .where(eq(patientInsurance.patientId, patientId));
      } catch (e) { console.log("No billing history found"); }
      
      // Get medical records
      let records: any[] = [];
      try {
        records = await db.select().from(medicalRecords)
          .where(eq(medicalRecords.patientId, patientId))
          .orderBy(desc(medicalRecords.recordDate));
      } catch (e) { console.log("No medical records found"); }
      
      res.json({
        patient,
        opdHistory,
        ipdHistory,
        medicationHistory,
        consentRecords,
        billingHistory: {
          bills,
          payments,
          insurance
        },
        medicalRecords: records
      });
    } catch (error) {
      console.error("Failed to fetch longitudinal profile:", error);
      res.status(500).json({ error: "Failed to fetch patient profile" });
    }
  });

  // ========== MEDICINES DATABASE API ==========
  
  // Get all medicines with optional search
  app.get("/api/medicines", async (req, res) => {
    try {
      const { search, category } = req.query;
      
      let medicineList;
      if (search && typeof search === 'string' && search.trim()) {
        medicineList = await databaseStorage.searchMedicines(search.trim());
      } else if (category && typeof category === 'string') {
        medicineList = await databaseStorage.getMedicinesByCategory(category);
      } else {
        medicineList = await databaseStorage.getAllMedicines();
      }
      
      res.json(medicineList);
    } catch (error) {
      console.error("Failed to fetch medicines:", error);
      res.status(500).json({ error: "Failed to fetch medicines" });
    }
  });

  // Get single medicine by ID
  app.get("/api/medicines/:id", async (req, res) => {
    try {
      const medicine = await databaseStorage.getMedicine(req.params.id);
      if (!medicine) {
        return res.status(404).json({ error: "Medicine not found" });
      }
      res.json(medicine);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch medicine" });
    }
  });

  // Import medicines from CSV (bulk import)
  app.post("/api/medicines/import", async (req, res) => {
    try {
      const { medicines: medicineData } = req.body;
      
      if (!Array.isArray(medicineData) || medicineData.length === 0) {
        return res.status(400).json({ error: "No medicine data provided" });
      }

      // Process in batches of 100 to avoid memory issues
      const batchSize = 100;
      let imported = 0;
      
      for (let i = 0; i < medicineData.length; i += batchSize) {
        const batch = medicineData.slice(i, i + batchSize);
        await databaseStorage.createMedicinesBulk(batch);
        imported += batch.length;
      }

      res.status(201).json({ 
        success: true, 
        imported,
        message: `Successfully imported ${imported} medicines`
      });
    } catch (error) {
      console.error("Failed to import medicines:", error);
      res.status(500).json({ error: "Failed to import medicines" });
    }
  });

  // Delete all medicines (for re-import)
  app.delete("/api/medicines/all", async (req, res) => {
    try {
      await databaseStorage.deleteAllMedicines();
      res.json({ success: true, message: "All medicines deleted" });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete medicines" });
    }
  });

  // Delete single medicine
  app.delete("/api/medicines/:id", async (req, res) => {
    try {
      const deleted = await databaseStorage.deleteMedicine(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Medicine not found" });
      }
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete medicine" });
    }
  });

  // ========== OXYGEN TRACKING API ==========

  // Get all oxygen cylinders
  app.get("/api/oxygen/cylinders", async (req, res) => {
    try {
      const { status } = req.query;
      let cylinders;
      if (status && typeof status === 'string') {
        cylinders = await databaseStorage.getOxygenCylindersByStatus(status);
      } else {
        cylinders = await databaseStorage.getOxygenCylinders();
      }
      res.json(cylinders);
    } catch (error) {
      console.error("Failed to fetch oxygen cylinders:", error);
      res.status(500).json({ error: "Failed to fetch oxygen cylinders" });
    }
  });

  // Get single cylinder by ID
  app.get("/api/oxygen/cylinders/:id", async (req, res) => {
    try {
      const cylinder = await databaseStorage.getOxygenCylinder(req.params.id);
      if (!cylinder) {
        return res.status(404).json({ error: "Cylinder not found" });
      }
      res.json(cylinder);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch cylinder" });
    }
  });

  // Create new cylinder
  app.post("/api/oxygen/cylinders", async (req, res) => {
    try {
      const cylinder = await databaseStorage.createOxygenCylinder(req.body);
      res.status(201).json(cylinder);
    } catch (error) {
      console.error("Failed to create cylinder:", error);
      res.status(500).json({ error: "Failed to create cylinder" });
    }
  });

  // Update cylinder
  app.patch("/api/oxygen/cylinders/:id", async (req, res) => {
    try {
      const cylinder = await databaseStorage.updateOxygenCylinder(req.params.id, req.body);
      if (!cylinder) {
        return res.status(404).json({ error: "Cylinder not found" });
      }
      res.json(cylinder);
    } catch (error) {
      res.status(500).json({ error: "Failed to update cylinder" });
    }
  });

  // Delete cylinder
  app.delete("/api/oxygen/cylinders/:id", async (req, res) => {
    try {
      const deleted = await databaseStorage.deleteOxygenCylinder(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Cylinder not found" });
      }
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete cylinder" });
    }
  });

  // Get cylinder movements
  app.get("/api/oxygen/movements", async (req, res) => {
    try {
      const { cylinderId } = req.query;
      let movements;
      if (cylinderId && typeof cylinderId === 'string') {
        movements = await databaseStorage.getCylinderMovementsByCylinder(cylinderId);
      } else {
        movements = await databaseStorage.getCylinderMovements();
      }
      res.json(movements);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch movements" });
    }
  });

  // Create cylinder movement (issue/return)
  app.post("/api/oxygen/movements", async (req, res) => {
    try {
      const movement = await databaseStorage.createCylinderMovement(req.body);
      // Update cylinder status based on movement type
      if (req.body.movementType === 'ISSUE') {
        await databaseStorage.updateOxygenCylinder(req.body.cylinderId, { 
          status: 'in_use', 
          location: req.body.department,
          currentPressure: req.body.startPressure 
        });
      } else if (req.body.movementType === 'RETURN') {
        const remainingPressure = parseFloat(req.body.endPressure || '0');
        const status = remainingPressure < 50 ? 'empty' : 'full';
        await databaseStorage.updateOxygenCylinder(req.body.cylinderId, { 
          status, 
          location: 'Storage',
          currentPressure: req.body.endPressure 
        });
      }
      res.status(201).json(movement);
    } catch (error) {
      console.error("Failed to create movement:", error);
      res.status(500).json({ error: "Failed to create movement" });
    }
  });

  // Get oxygen consumption records
  app.get("/api/oxygen/consumption", async (req, res) => {
    try {
      const { patientId, department } = req.query;
      let records;
      if (patientId && typeof patientId === 'string') {
        records = await databaseStorage.getOxygenConsumptionByPatient(patientId);
      } else if (department && typeof department === 'string') {
        records = await databaseStorage.getOxygenConsumptionByDepartment(department);
      } else {
        records = await databaseStorage.getOxygenConsumptionRecords();
      }
      res.json(records);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch consumption records" });
    }
  });

  // Create consumption record
  app.post("/api/oxygen/consumption", async (req, res) => {
    try {
      const data = {
        ...req.body,
        startTime: req.body.startTime ? new Date(req.body.startTime) : new Date(),
        endTime: req.body.endTime ? new Date(req.body.endTime) : undefined,
      };
      const record = await databaseStorage.createOxygenConsumption(data);
      res.status(201).json(record);
    } catch (error) {
      console.error("Failed to create consumption record:", error);
      res.status(500).json({ error: "Failed to create consumption record" });
    }
  });

  // Update consumption record (end session)
  app.patch("/api/oxygen/consumption/:id", async (req, res) => {
    try {
      const record = await databaseStorage.updateOxygenConsumption(req.params.id, req.body);
      if (!record) {
        return res.status(404).json({ error: "Record not found" });
      }
      res.json(record);
    } catch (error) {
      res.status(500).json({ error: "Failed to update consumption record" });
    }
  });

  // Get LMO readings
  app.get("/api/oxygen/lmo", async (req, res) => {
    try {
      const { date } = req.query;
      let readings;
      if (date && typeof date === 'string') {
        readings = await databaseStorage.getLmoReadingsByDate(date);
      } else {
        readings = await databaseStorage.getLmoReadings();
      }
      res.json(readings);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch LMO readings" });
    }
  });

  // Create LMO reading
  app.post("/api/oxygen/lmo", async (req, res) => {
    try {
      const reading = await databaseStorage.createLmoReading(req.body);
      // Check for low level alert
      const levelPercentage = parseFloat(req.body.levelPercentage || '100');
      if (levelPercentage < 20) {
        await databaseStorage.createOxygenAlert({
          alertType: 'LOW_STOCK',
          severity: levelPercentage < 10 ? 'critical' : 'warning',
          title: 'Low LMO Tank Level',
          message: `LMO tank level is at ${levelPercentage}%. Please arrange for refill.`,
          isResolved: false
        });
      }
      res.status(201).json(reading);
    } catch (error) {
      console.error("Failed to create LMO reading:", error);
      res.status(500).json({ error: "Failed to create LMO reading" });
    }
  });

  // Get oxygen alerts
  app.get("/api/oxygen/alerts", async (req, res) => {
    try {
      const { active } = req.query;
      let alerts;
      if (active === 'true') {
        alerts = await databaseStorage.getActiveOxygenAlerts();
      } else {
        alerts = await databaseStorage.getOxygenAlerts();
      }
      res.json(alerts);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch alerts" });
    }
  });

  // Create oxygen alert
  app.post("/api/oxygen/alerts", async (req, res) => {
    try {
      const alert = await databaseStorage.createOxygenAlert(req.body);
      res.status(201).json(alert);
    } catch (error) {
      res.status(500).json({ error: "Failed to create alert" });
    }
  });

  // Resolve oxygen alert
  app.patch("/api/oxygen/alerts/:id/resolve", async (req, res) => {
    try {
      const { resolvedBy } = req.body;
      const alert = await databaseStorage.resolveOxygenAlert(req.params.id, resolvedBy || 'System');
      if (!alert) {
        return res.status(404).json({ error: "Alert not found" });
      }
      res.json(alert);
    } catch (error) {
      res.status(500).json({ error: "Failed to resolve alert" });
    }
  });

  // ========== BIOMEDICAL WASTE MANAGEMENT (BMW) ROUTES ==========

  // Generate unique barcode for BMW bag
  const generateBMWBarcode = () => {
    const prefix = "BMW";
    const timestamp = Date.now().toString(36).toUpperCase();
    const random = Math.random().toString(36).substring(2, 6).toUpperCase();
    return `${prefix}-${timestamp}-${random}`;
  };

  // Generate pickup ID
  const generatePickupId = () => {
    const prefix = "PU";
    const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
    const random = Math.random().toString(36).substring(2, 6).toUpperCase();
    return `${prefix}-${date}-${random}`;
  };

  // Get all BMW bags
  app.get("/api/bmw/bags", async (req, res) => {
    try {
      const { status, category, department } = req.query;
      const bags = await databaseStorage.getBmwBags({ 
        status: status as string, 
        category: category as string, 
        department: department as string 
      });
      res.json(bags);
    } catch (error) {
      console.error("Failed to fetch BMW bags:", error);
      res.status(500).json({ error: "Failed to fetch BMW bags" });
    }
  });

  // Create BMW bag with auto-generated barcode
  app.post("/api/bmw/bags", async (req, res) => {
    try {
      const barcode = generateBMWBarcode();
      const now = new Date();
      const storageDeadline = new Date(now.getTime() + 48 * 60 * 60 * 1000); // 48 hours from now
      
      const bag = await databaseStorage.createBmwBag({
        barcode,
        category: req.body.category,
        department: req.body.department,
        approxWeight: req.body.approxWeight,
        status: "GENERATED",
        generatedBy: req.body.generatedBy || "System",
        generatedByRole: req.body.generatedByRole || "ADMIN",
        storageDeadline,
        notes: req.body.notes
      });

      // Create movement record
      await databaseStorage.createBmwMovement({
        bagId: bag.id,
        action: "CREATED",
        performedBy: req.body.generatedBy || "System",
        performedByRole: req.body.generatedByRole || "ADMIN",
        location: req.body.department,
        weight: req.body.approxWeight,
        notes: "Bag generated"
      });

      res.status(201).json(bag);
    } catch (error) {
      console.error("Failed to create BMW bag:", error);
      res.status(500).json({ error: "Failed to create BMW bag" });
    }
  });

  // Update BMW bag status
  app.patch("/api/bmw/bags/:id", async (req, res) => {
    try {
      const bag = await databaseStorage.updateBmwBag(req.params.id, req.body);
      if (!bag) {
        return res.status(404).json({ error: "Bag not found" });
      }
      res.json(bag);
    } catch (error) {
      console.error("Failed to update BMW bag:", error);
      res.status(500).json({ error: "Failed to update BMW bag" });
    }
  });

  // Get BMW statistics
  app.get("/api/bmw/stats", async (req, res) => {
    try {
      const stats = await databaseStorage.getBmwStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to fetch BMW stats:", error);
      res.status(500).json({ error: "Failed to fetch BMW stats" });
    }
  });

  // Get BMW movements
  app.get("/api/bmw/movements", async (req, res) => {
    try {
      const { bagId } = req.query;
      const movements = await databaseStorage.getBmwMovements(bagId as string);
      res.json(movements);
    } catch (error) {
      console.error("Failed to fetch BMW movements:", error);
      res.status(500).json({ error: "Failed to fetch BMW movements" });
    }
  });

  // Create BMW movement
  app.post("/api/bmw/movements", async (req, res) => {
    try {
      const movement = await databaseStorage.createBmwMovement(req.body);
      res.status(201).json(movement);
    } catch (error) {
      console.error("Failed to create BMW movement:", error);
      res.status(500).json({ error: "Failed to create BMW movement" });
    }
  });

  // Get all storage rooms
  app.get("/api/bmw/storage-rooms", async (req, res) => {
    try {
      const rooms = await databaseStorage.getBmwStorageRooms();
      res.json(rooms);
    } catch (error) {
      console.error("Failed to fetch storage rooms:", error);
      res.status(500).json({ error: "Failed to fetch storage rooms" });
    }
  });

  // Create storage room
  app.post("/api/bmw/storage-rooms", async (req, res) => {
    try {
      const room = await databaseStorage.createBmwStorageRoom(req.body);
      res.status(201).json(room);
    } catch (error) {
      console.error("Failed to create storage room:", error);
      res.status(500).json({ error: "Failed to create storage room" });
    }
  });

  // Get all vendors
  app.get("/api/bmw/vendors", async (req, res) => {
    try {
      const vendors = await databaseStorage.getBmwVendors();
      res.json(vendors);
    } catch (error) {
      console.error("Failed to fetch vendors:", error);
      res.status(500).json({ error: "Failed to fetch vendors" });
    }
  });

  // Create vendor
  app.post("/api/bmw/vendors", async (req, res) => {
    try {
      const vendorId = `VND-${Date.now().toString(36).toUpperCase()}`;
      const vendor = await databaseStorage.createBmwVendor({
        ...req.body,
        vendorId
      });
      res.status(201).json(vendor);
    } catch (error) {
      console.error("Failed to create vendor:", error);
      res.status(500).json({ error: "Failed to create vendor" });
    }
  });

  // Get all pickups
  app.get("/api/bmw/pickups", async (req, res) => {
    try {
      const pickups = await databaseStorage.getBmwPickups();
      res.json(pickups);
    } catch (error) {
      console.error("Failed to fetch pickups:", error);
      res.status(500).json({ error: "Failed to fetch pickups" });
    }
  });

  // Create pickup
  app.post("/api/bmw/pickups", async (req, res) => {
    try {
      const pickupId = generatePickupId();
      const pickup = await databaseStorage.createBmwPickup({
        ...req.body,
        pickupId
      });
      res.status(201).json(pickup);
    } catch (error) {
      console.error("Failed to create pickup:", error);
      res.status(500).json({ error: "Failed to create pickup" });
    }
  });

  // Get all disposals
  app.get("/api/bmw/disposals", async (req, res) => {
    try {
      const disposals = await databaseStorage.getBmwDisposals();
      res.json(disposals);
    } catch (error) {
      console.error("Failed to fetch disposals:", error);
      res.status(500).json({ error: "Failed to fetch disposals" });
    }
  });

  // Create disposal
  app.post("/api/bmw/disposals", async (req, res) => {
    try {
      const disposal = await databaseStorage.createBmwDisposal(req.body);
      // Update bag status to DISPOSED
      if (req.body.bagId) {
        await databaseStorage.updateBmwBag(req.body.bagId, { 
          status: "DISPOSED",
          disposedAt: new Date()
        });
      }
      res.status(201).json(disposal);
    } catch (error) {
      console.error("Failed to create disposal:", error);
      res.status(500).json({ error: "Failed to create disposal" });
    }
  });

  // Get all incidents
  app.get("/api/bmw/incidents", async (req, res) => {
    try {
      const incidents = await databaseStorage.getBmwIncidents();
      res.json(incidents);
    } catch (error) {
      console.error("Failed to fetch incidents:", error);
      res.status(500).json({ error: "Failed to fetch incidents" });
    }
  });

  // Create incident
  app.post("/api/bmw/incidents", async (req, res) => {
    try {
      const incident = await databaseStorage.createBmwIncident(req.body);
      res.status(201).json(incident);
    } catch (error) {
      console.error("Failed to create incident:", error);
      res.status(500).json({ error: "Failed to create incident" });
    }
  });

  // Get all reports
  app.get("/api/bmw/reports", async (req, res) => {
    try {
      const reports = await databaseStorage.getBmwReports();
      res.json(reports);
    } catch (error) {
      console.error("Failed to fetch reports:", error);
      res.status(500).json({ error: "Failed to fetch reports" });
    }
  });

  // Generate report
  app.post("/api/bmw/reports", async (req, res) => {
    try {
      const report = await databaseStorage.createBmwReport(req.body);
      res.status(201).json(report);
    } catch (error) {
      console.error("Failed to create report:", error);
      res.status(500).json({ error: "Failed to create report" });
    }
  });

  // ========== AI INTELLIGENCE LAYER ROUTES ==========

  // Get Doctor Efficiency metrics
  app.get("/api/ai/doctor-efficiency", async (req, res) => {
    try {
      const { doctorId } = req.query;
      const metrics = await aiEngines.calculateDoctorEfficiency(doctorId as string | undefined);
      res.json(metrics);
    } catch (error) {
      console.error("Failed to calculate doctor efficiency:", error);
      res.status(500).json({ error: "Failed to calculate doctor efficiency metrics" });
    }
  });

  // Get Nurse Efficiency metrics
  app.get("/api/ai/nurse-efficiency", async (req, res) => {
    try {
      const { nurseId } = req.query;
      const metrics = await aiEngines.calculateNurseEfficiency(nurseId as string | undefined);
      res.json(metrics);
    } catch (error) {
      console.error("Failed to calculate nurse efficiency:", error);
      res.status(500).json({ error: "Failed to calculate nurse efficiency metrics" });
    }
  });

  // Get OPD Intelligence metrics
  app.get("/api/ai/opd-intelligence", async (req, res) => {
    try {
      const metrics = await aiEngines.calculateOPDIntelligence();
      res.json(metrics);
    } catch (error) {
      console.error("Failed to calculate OPD intelligence:", error);
      res.status(500).json({ error: "Failed to calculate OPD intelligence metrics" });
    }
  });

  // Get Hospital Health Index
  app.get("/api/ai/hospital-health", async (req, res) => {
    try {
      const metrics = await aiEngines.calculateHospitalHealthIndex();
      res.json(metrics);
    } catch (error) {
      console.error("Failed to calculate hospital health index:", error);
      res.status(500).json({ error: "Failed to calculate hospital health index" });
    }
  });

  // Get Predictions
  app.get("/api/ai/predictions", async (req, res) => {
    try {
      const predictions = await aiEngines.generatePredictions();
      res.json(predictions);
    } catch (error) {
      console.error("Failed to generate predictions:", error);
      res.status(500).json({ error: "Failed to generate predictions" });
    }
  });

  // Get Inpatient Analytics
  app.get("/api/ai/inpatient-analytics", async (req, res) => {
    try {
      const metrics = await aiEngines.calculateInpatientAnalytics();
      res.json(metrics);
    } catch (error) {
      console.error("Failed to calculate inpatient analytics:", error);
      res.status(500).json({ error: "Failed to calculate inpatient analytics" });
    }
  });

  // Get Resolved Alerts
  app.get("/api/resolved-alerts", async (req, res) => {
    try {
      const alerts = await storage.getResolvedAlerts();
      res.json(alerts);
    } catch (error) {
      console.error("Failed to fetch resolved alerts:", error);
      res.status(500).json({ error: "Failed to fetch resolved alerts" });
    }
  });

  // Add Resolved Alert
  app.post("/api/resolved-alerts", async (req, res) => {
    try {
      const { alertType, alertSeverity, alertMessage, patientId } = req.body;
      if (!alertType || !alertSeverity || !alertMessage) {
        return res.status(400).json({ error: "Missing required fields: alertType, alertSeverity, alertMessage" });
      }
      const userId = (req as any).session?.userId;
      const alertData = {
        alertType,
        alertSeverity,
        alertMessage,
        patientId: patientId || null,
        resolvedBy: userId || null
      };
      const alert = await storage.createResolvedAlert(alertData);
      res.status(201).json(alert);
    } catch (error) {
      console.error("Failed to create resolved alert:", error);
      res.status(500).json({ error: "Failed to create resolved alert" });
    }
  });

  // Delete Resolved Alert (unresolve)
  app.delete("/api/resolved-alerts/:id", async (req, res) => {
    try {
      await storage.deleteResolvedAlert(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Failed to delete resolved alert:", error);
      res.status(500).json({ error: "Failed to delete resolved alert" });
    }
  });

  // ========== PATIENT BILLING ROUTES ==========

  // Get all patient bills (with patient data isolation for PATIENT role)
  app.get("/api/patient-bills", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      let bills = await storage.getAllPatientBills();
      
      // CRITICAL: Patient data isolation - PATIENT role only sees their own bills
      if (user && user.role === 'PATIENT') {
        const patientId = user.id;
        const userName = user.name?.toLowerCase().replace(/\s+/g, ' ').trim();
        const userUsername = user.username?.toLowerCase();
        bills = bills.filter(bill => {
          const billPatientName = bill.patientName?.toLowerCase().replace(/\s+/g, ' ').trim();
          return bill.patientId === patientId ||
            billPatientName === userName ||
            billPatientName === userUsername;
        });
      }
      
      res.json(bills);
    } catch (error) {
      console.error("Failed to fetch bills:", error);
      res.status(500).json({ error: "Failed to fetch bills" });
    }
  });

  // Get pending bill requests (for admin)
  app.get("/api/patient-bills/pending", async (req, res) => {
    try {
      const bills = await storage.getPendingBillRequests();
      res.json(bills);
    } catch (error) {
      console.error("Failed to fetch pending bills:", error);
      res.status(500).json({ error: "Failed to fetch pending bills" });
    }
  });

  // Get bill by ID (with patient data isolation for PATIENT role)
  app.get("/api/patient-bills/:id", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const bill = await storage.getPatientBill(req.params.id);
      if (!bill) {
        return res.status(404).json({ error: "Bill not found" });
      }
      
      // CRITICAL: Patient data isolation - PATIENT role can only access their own bills
      if (user && user.role === 'PATIENT') {
        if (bill.patientId !== user.id) {
          return res.status(403).json({ error: "Access denied. You can only view your own billing records." });
        }
      }
      
      res.json(bill);
    } catch (error) {
      console.error("Failed to fetch bill:", error);
      res.status(500).json({ error: "Failed to fetch bill" });
    }
  });

  // Get bill by patient ID (with patient data isolation for PATIENT role)
  app.get("/api/patient-bills/patient/:patientId", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      
      // CRITICAL: Patient data isolation - PATIENT role can only access their own bills
      if (user && user.role === 'PATIENT') {
        if (req.params.patientId !== user.id && req.params.patientId !== user.username) {
          return res.status(403).json({ error: "Access denied. You can only view your own billing records." });
        }
      }
      
      const bill = await storage.getPatientBillByPatientId(req.params.patientId);
      res.json(bill || null);
    } catch (error) {
      console.error("Failed to fetch patient bill:", error);
      res.status(500).json({ error: "Failed to fetch patient bill" });
    }
  });

  // Create new bill (patient requests bill generation)
  app.post("/api/patient-bills", async (req, res) => {
    try {
      const { patientId, patientName, admissionId } = req.body;
      if (!patientId || !patientName) {
        return res.status(400).json({ error: "Patient ID and name are required" });
      }

      // Check if bill already exists for this patient
      const existingBill = await storage.getPatientBillByPatientId(patientId);
      if (existingBill) {
        return res.json(existingBill);
      }

      const bill = await storage.createPatientBill({
        patientId,
        patientName,
        admissionId,
        billRequestedAt: new Date(),
        status: "pending",
        roomCharges: "0",
        doctorConsultation: "0",
        labTests: "0",
        medicines: "0",
        inventoryCharges: "0",
        otherFees: "0",
        paidAmount: "0",
      });

      // Log activity
      await storage.createActivityLog({
        action: `Bill generation requested by ${patientName}`,
        entityType: "patient_bill",
        entityId: bill.id,
        performedBy: patientName,
        performedByRole: "PATIENT",
        activityType: "info"
      });

      // Send real-time notification to admin
      notificationService.notifyBillRequested(bill.id, patientId, patientName);

      res.status(201).json(bill);
    } catch (error) {
      console.error("Failed to create bill:", error);
      res.status(500).json({ error: "Failed to create bill" });
    }
  });

  // Update bill charges (admin updates)
  app.patch("/api/patient-bills/:id", async (req, res) => {
    try {
      const updates = req.body;
      const bill = await storage.updatePatientBill(req.params.id, updates);
      if (!bill) {
        return res.status(404).json({ error: "Bill not found" });
      }

      // Send real-time notification to patient
      notificationService.notifyBillUpdated(bill.id, bill.patientId, bill.totalAmount?.toString() || "0", bill.status);

      res.json(bill);
    } catch (error) {
      console.error("Failed to update bill:", error);
      res.status(500).json({ error: "Failed to update bill" });
    }
  });

  // Delete bill
  app.delete("/api/patient-bills/:id", async (req, res) => {
    try {
      await storage.deletePatientBill(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Failed to delete bill:", error);
      res.status(500).json({ error: "Failed to delete bill" });
    }
  });

  // Get bill payments
  app.get("/api/patient-bills/:id/payments", async (req, res) => {
    try {
      const payments = await storage.getBillPayments(req.params.id);
      res.json(payments);
    } catch (error) {
      console.error("Failed to fetch payments:", error);
      res.status(500).json({ error: "Failed to fetch payments" });
    }
  });

  // Add payment to bill
  app.post("/api/patient-bills/:id/payments", async (req, res) => {
    try {
      const { amount, paymentMethod, transactionId, notes } = req.body;
      if (!amount || !paymentMethod) {
        return res.status(400).json({ error: "Amount and payment method are required" });
      }

      const bill = await storage.getPatientBill(req.params.id);
      if (!bill) {
        return res.status(404).json({ error: "Bill not found" });
      }

      const payment = await storage.createBillPayment({
        billId: req.params.id,
        amount: amount.toString(),
        paymentMethod,
        transactionId,
        notes,
        receivedBy: (req as any).session?.userId || null
      });

      // Get updated bill
      const updatedBill = await storage.getPatientBill(req.params.id);
      
      // Notify patient of payment received
      if (updatedBill) {
        notificationService.notifyBillUpdated(
          updatedBill.id, 
          updatedBill.patientId, 
          updatedBill.totalAmount?.toString() || "0", 
          updatedBill.status
        );
      }

      res.status(201).json({ payment, bill: updatedBill });
    } catch (error) {
      console.error("Failed to add payment:", error);
      res.status(500).json({ error: "Failed to add payment" });
    }
  });

  // ========== HEALTH TIPS ROUTES ==========
  
  // Get all health tips
  app.get("/api/health-tips", async (req, res) => {
    try {
      const tips = await storage.getAllHealthTips();
      res.json(tips);
    } catch (error) {
      console.error("Failed to fetch health tips:", error);
      res.status(500).json({ error: "Failed to fetch health tips" });
    }
  });

  // Get active health tips
  app.get("/api/health-tips/active", async (req, res) => {
    try {
      const tips = await storage.getActiveHealthTips();
      res.json(tips);
    } catch (error) {
      console.error("Failed to fetch active health tips:", error);
      res.status(500).json({ error: "Failed to fetch active health tips" });
    }
  });

  // Get latest health tip
  app.get("/api/health-tips/latest", async (req, res) => {
    try {
      const tip = await storage.getLatestHealthTip();
      res.json(tip || null);
    } catch (error) {
      console.error("Failed to fetch latest health tip:", error);
      res.status(500).json({ error: "Failed to fetch latest health tip" });
    }
  });

  // Manually generate a health tip (Admin only)
  app.post("/api/health-tips/generate", async (req, res) => {
    try {
      const { scheduledFor = "9AM" } = req.body;
      const tip = await notificationService.generateHealthTipNow(scheduledFor);
      
      if (tip) {
        res.json(tip);
      } else {
        res.status(500).json({ error: "Failed to generate health tip" });
      }
    } catch (error) {
      console.error("Failed to generate health tip:", error);
      res.status(500).json({ error: "Failed to generate health tip" });
    }
  });

  // Get All AI Metrics (combined dashboard data)
  app.get("/api/ai/dashboard", async (req, res) => {
    try {
      const [doctorMetrics, nurseMetrics, opdMetrics, healthIndex, predictions] = await Promise.all([
        aiEngines.calculateDoctorEfficiency(),
        aiEngines.calculateNurseEfficiency(),
        aiEngines.calculateOPDIntelligence(),
        aiEngines.calculateHospitalHealthIndex(),
        aiEngines.generatePredictions()
      ]);

      res.json({
        doctorEfficiency: doctorMetrics,
        nurseEfficiency: nurseMetrics,
        opdIntelligence: opdMetrics,
        hospitalHealth: healthIndex,
        predictions
      });
    } catch (error) {
      console.error("Failed to fetch AI dashboard:", error);
      res.status(500).json({ error: "Failed to fetch AI dashboard data" });
    }
  });

  // ========== SWAB MONITORING ROUTES ==========
  
  // Swab Areas
  app.get("/api/swab-monitoring/areas", async (req, res) => {
    try {
      const areas = await storage.getAllSwabAreas();
      res.json(areas);
    } catch (error) {
      console.error("Failed to fetch swab areas:", error);
      res.status(500).json({ error: "Failed to fetch swab areas" });
    }
  });

  app.post("/api/swab-monitoring/areas", async (req, res) => {
    try {
      const area = await storage.createSwabArea(req.body);
      res.json(area);
    } catch (error) {
      console.error("Failed to create swab area:", error);
      res.status(500).json({ error: "Failed to create swab area" });
    }
  });

  // Sampling Sites
  app.get("/api/swab-monitoring/sampling-sites", async (req, res) => {
    try {
      const sites = await storage.getAllSwabSamplingSites();
      res.json(sites);
    } catch (error) {
      console.error("Failed to fetch sampling sites:", error);
      res.status(500).json({ error: "Failed to fetch sampling sites" });
    }
  });

  app.post("/api/swab-monitoring/sampling-sites", async (req, res) => {
    try {
      const site = await storage.createSwabSamplingSite(req.body);
      res.json(site);
    } catch (error) {
      console.error("Failed to create sampling site:", error);
      res.status(500).json({ error: "Failed to create sampling site" });
    }
  });

  // Organisms
  app.get("/api/swab-monitoring/organisms", async (req, res) => {
    try {
      const organisms = await storage.getAllSwabOrganisms();
      res.json(organisms);
    } catch (error) {
      console.error("Failed to fetch organisms:", error);
      res.status(500).json({ error: "Failed to fetch organisms" });
    }
  });

  app.post("/api/swab-monitoring/organisms", async (req, res) => {
    try {
      const organism = await storage.createSwabOrganism(req.body);
      res.json(organism);
    } catch (error) {
      console.error("Failed to create organism:", error);
      res.status(500).json({ error: "Failed to create organism" });
    }
  });

  // Swab Collections
  app.get("/api/swab-monitoring/collections", async (req, res) => {
    try {
      const collections = await storage.getAllSwabCollections();
      res.json(collections);
    } catch (error) {
      console.error("Failed to fetch swab collections:", error);
      res.status(500).json({ error: "Failed to fetch swab collections" });
    }
  });

  app.post("/api/swab-monitoring/collections", async (req, res) => {
    try {
      // Convert date strings to Date objects
      const collectionData = {
        ...req.body,
        collectionDate: req.body.collectionDate ? new Date(req.body.collectionDate) : new Date()
      };
      
      const collection = await storage.createSwabCollection(collectionData);
      
      // Create audit log
      await storage.createSwabAuditLog({
        entityType: "swab_collection",
        entityId: collection.id,
        action: "create",
        newValue: JSON.stringify(collection),
        performedBy: req.body.collectedBy,
        performedByName: req.body.collectedByName,
        performedByRole: "ICN",
      });
      
      res.json(collection);
    } catch (error) {
      console.error("Failed to create swab collection:", error);
      res.status(500).json({ error: "Failed to create swab collection" });
    }
  });

  // Lab Results with auto-interpretation logic
  app.get("/api/swab-monitoring/lab-results", async (req, res) => {
    try {
      const results = await storage.getAllSwabLabResults();
      res.json(results);
    } catch (error) {
      console.error("Failed to fetch lab results:", error);
      res.status(500).json({ error: "Failed to fetch lab results" });
    }
  });

  app.post("/api/swab-monitoring/lab-results", async (req, res) => {
    try {
      // Convert date strings to Date objects
      const labResultData = {
        ...req.body,
        resultDate: req.body.resultDate ? new Date(req.body.resultDate) : new Date()
      };
      
      const labResult = await storage.createSwabLabResult(labResultData);
      
      // Get the organism to determine result status
      const organism = await storage.getSwabOrganism(req.body.organismId);
      const collection = await storage.getSwabCollection(req.body.swabCollectionId);
      
      let resultStatus = "PASS";
      
      // Auto-interpretation logic
      if (organism) {
        if (organism.organismName === "No Growth" || organism.category === "none") {
          resultStatus = "PASS";
        } else if (organism.category === "flora" && req.body.growthLevel === "Low") {
          resultStatus = "ACCEPTABLE";
        } else if (organism.category === "pathogen" || req.body.growthLevel === "Moderate" || req.body.growthLevel === "Heavy") {
          resultStatus = "FAIL";
        }
      }
      
      // Update the swab collection with result status
      await storage.updateSwabCollection(req.body.swabCollectionId, {
        status: "completed",
        resultStatus,
      });
      
      // If FAIL, auto-generate CAPA
      if (resultStatus === "FAIL" && collection) {
        const area = await storage.getSwabArea(collection.areaId);
        const site = await storage.getSwabSamplingSite(collection.samplingSiteId);
        
        const issueSummary = `Contamination detected at ${area?.areaName || 'Unknown Area'} - ${site?.siteName || 'Unknown Site'}. Organism: ${organism?.organismName || 'Unknown'}. Growth Level: ${req.body.growthLevel}`;
        
        const capaAction = await storage.createSwabCapaAction({
          swabCollectionId: collection.id,
          issueSummary,
          immediateAction: "Deep cleaning",
          responsibleDepartment: "Housekeeping",
          targetClosureDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days from now
          verificationSwabRequired: true,
        });
        
        // Audit log for CAPA creation
        await storage.createSwabAuditLog({
          entityType: "capa_action",
          entityId: capaAction.id,
          action: "create",
          newValue: JSON.stringify(capaAction),
          performedBy: "SYSTEM",
          performedByName: "Auto-generated",
          performedByRole: "SYSTEM",
        });
        
        // Create notification for admin
        await storage.createUserNotification({
          userId: "admin",
          userRole: "ADMIN",
          title: "Swab Contamination Alert",
          message: issueSummary,
          type: "swab_alert",
          metadata: JSON.stringify({
            swabId: collection.swabId,
            areaType: collection.areaType,
            resultStatus: "FAIL",
          }),
        });
      }
      
      // Create audit log
      await storage.createSwabAuditLog({
        entityType: "lab_result",
        entityId: labResult.id,
        action: "create",
        newValue: JSON.stringify({ ...labResult, resultStatus }),
        performedBy: req.body.processedBy,
        performedByName: req.body.processedByName,
        performedByRole: "LAB_STAFF",
      });
      
      res.json({ ...labResult, resultStatus });
    } catch (error) {
      console.error("Failed to create lab result:", error);
      res.status(500).json({ error: "Failed to create lab result" });
    }
  });

  // CAPA Actions
  app.get("/api/swab-monitoring/capa-actions", async (req, res) => {
    try {
      const capas = await storage.getAllSwabCapaActions();
      res.json(capas);
    } catch (error) {
      console.error("Failed to fetch CAPA actions:", error);
      res.status(500).json({ error: "Failed to fetch CAPA actions" });
    }
  });

  app.post("/api/swab-monitoring/capa-actions/:id/close", async (req, res) => {
    try {
      const { closedBy, closedByName, closureRemarks } = req.body;
      const capa = await storage.closeSwabCapaAction(req.params.id, closedBy, closedByName, closureRemarks);
      
      if (capa) {
        await storage.createSwabAuditLog({
          entityType: "capa_action",
          entityId: capa.id,
          action: "close",
          newValue: JSON.stringify(capa),
          performedBy: closedBy,
          performedByName: closedByName,
          performedByRole: "ADMIN",
        });
        res.json(capa);
      } else {
        res.status(404).json({ error: "CAPA not found" });
      }
    } catch (error) {
      console.error("Failed to close CAPA:", error);
      res.status(500).json({ error: "Failed to close CAPA" });
    }
  });

  app.patch("/api/swab-monitoring/capa-actions/:id", async (req, res) => {
    try {
      const capa = await storage.updateSwabCapaAction(req.params.id, req.body);
      if (capa) {
        res.json(capa);
      } else {
        res.status(404).json({ error: "CAPA not found" });
      }
    } catch (error) {
      console.error("Failed to update CAPA:", error);
      res.status(500).json({ error: "Failed to update CAPA" });
    }
  });

  // Audit Logs
  app.get("/api/swab-monitoring/audit-logs", async (req, res) => {
    try {
      const logs = await storage.getAllSwabAuditLogs();
      res.json(logs);
    } catch (error) {
      console.error("Failed to fetch audit logs:", error);
      res.status(500).json({ error: "Failed to fetch audit logs" });
    }
  });

  // Seed Demo Data for Swab Monitoring
  app.post("/api/swab-monitoring/seed-demo", async (req, res) => {
    try {
      // Get existing master data
      const areas = await storage.getAllSwabAreas();
      const sites = await storage.getAllSwabSamplingSites();
      const organisms = await storage.getAllSwabOrganisms();

      if (areas.length === 0 || sites.length === 0 || organisms.length === 0) {
        return res.status(400).json({ error: "Please seed master data first" });
      }

      // Find specific organisms for demo
      const noGrowth = organisms.find(o => o.organismName === "No Growth");
      const staphEpidermidis = organisms.find(o => o.organismName === "Staphylococcus epidermidis");
      const mrsa = organisms.find(o => o.organismName === "MRSA");
      const pseudomonas = organisms.find(o => o.organismName === "Pseudomonas aeruginosa");
      const bacillus = organisms.find(o => o.organismName === "Bacillus species");

      const demoCollections = [];

      // Create demo swab collections with various results
      const demoData = [
        { areaIdx: 0, siteIdx: 0, organism: noGrowth, growthLevel: "None", reason: "Routine", status: "PASS", dayOffset: -7 },
        { areaIdx: 0, siteIdx: 1, organism: noGrowth, growthLevel: "None", reason: "Post-fumigation", status: "PASS", dayOffset: -6 },
        { areaIdx: 1, siteIdx: 2, organism: staphEpidermidis, growthLevel: "Low", reason: "Routine", status: "ACCEPTABLE", dayOffset: -5 },
        { areaIdx: 1, siteIdx: 0, organism: bacillus, growthLevel: "Low", reason: "Routine", status: "ACCEPTABLE", dayOffset: -4 },
        { areaIdx: 2, siteIdx: 3, organism: mrsa, growthLevel: "Moderate", reason: "Outbreak suspicion", status: "FAIL", dayOffset: -3 },
        { areaIdx: 3, siteIdx: 4, organism: pseudomonas, growthLevel: "Heavy", reason: "Routine", status: "FAIL", dayOffset: -2 },
        { areaIdx: 0, siteIdx: 5, organism: noGrowth, growthLevel: "None", reason: "Post-fumigation", status: "PASS", dayOffset: -1 },
        { areaIdx: 4, siteIdx: 6, organism: staphEpidermidis, growthLevel: "Low", reason: "Routine", status: "ACCEPTABLE", dayOffset: 0 },
      ];

      for (const demo of demoData) {
        const area = areas[demo.areaIdx % areas.length];
        const site = sites[demo.siteIdx % sites.length];
        const collectionDate = new Date(Date.now() + demo.dayOffset * 24 * 60 * 60 * 1000);

        // Create collection
        const collection = await storage.createSwabCollection({
          collectionDate,
          areaType: area.areaType,
          areaId: area.id,
          samplingSiteId: site.id,
          reason: demo.reason,
          collectedBy: "ICN001",
          collectedByName: "Sr. Nurse Priya Sharma",
          remarks: `Demo ${demo.status} sample - ${demo.reason}`,
        });

        // Create lab result
        if (demo.organism) {
          const labResult = await storage.createSwabLabResult({
            swabCollectionId: collection.id,
            cultureMedia: demo.growthLevel === "None" ? "Blood Agar" : "MacConkey Agar",
            organismId: demo.organism.id,
            cfuCount: demo.growthLevel === "None" ? 0 : demo.growthLevel === "Low" ? 5 : demo.growthLevel === "Moderate" ? 25 : 100,
            growthLevel: demo.growthLevel,
            sensitivityTest: demo.status === "FAIL",
            sensitivityDetails: demo.status === "FAIL" ? "Resistant to Ampicillin, Sensitive to Vancomycin" : null,
            resultDate: new Date(collectionDate.getTime() + 48 * 60 * 60 * 1000),
            processedBy: "LAB001",
            processedByName: "Lab Tech Rahul Verma",
            remarks: `${demo.organism.organismName} detected with ${demo.growthLevel} growth`,
          });

          // Update collection with result status
          await storage.updateSwabCollection(collection.id, {
            status: "completed",
            resultStatus: demo.status,
          });

          // Create CAPA for FAIL results
          if (demo.status === "FAIL") {
            const issueSummary = `Contamination detected at ${area.areaName} - ${site.siteName}. Organism: ${demo.organism.organismName}. Growth Level: ${demo.growthLevel}`;
            
            const capaAction = await storage.createSwabCapaAction({
              swabCollectionId: collection.id,
              issueSummary,
              rootCause: "Inadequate surface disinfection during routine cleaning",
              immediateAction: "Deep cleaning and re-fumigation scheduled",
              responsibleDepartment: "Housekeeping",
              responsiblePerson: "HK001",
              responsiblePersonName: "Mr. Suresh Kumar",
              targetClosureDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
              verificationSwabRequired: true,
            });
            
            // Update CAPA status for older entries
            if (demo.dayOffset < -2) {
              await storage.updateSwabCapaAction(capaAction.id, { status: "in_progress" });
            }

            // Audit log for CAPA creation
            await storage.createSwabAuditLog({
              entityType: "capa_action",
              entityId: capaAction.id,
              action: "create",
              newValue: JSON.stringify(capaAction),
              performedBy: "SYSTEM",
              performedByName: "Auto-generated",
              performedByRole: "SYSTEM",
            });
          }
        }

        // Create audit log for collection
        await storage.createSwabAuditLog({
          entityType: "swab_collection",
          entityId: collection.id,
          action: "create",
          newValue: JSON.stringify(collection),
          performedBy: "ICN001",
          performedByName: "Sr. Nurse Priya Sharma",
          performedByRole: "ICN",
        });

        demoCollections.push(collection);
      }

      res.json({ 
        message: "Demo data seeded successfully", 
        collections: demoCollections.length,
        summary: {
          pass: demoData.filter(d => d.status === "PASS").length,
          acceptable: demoData.filter(d => d.status === "ACCEPTABLE").length,
          fail: demoData.filter(d => d.status === "FAIL").length
        }
      });
    } catch (error) {
      console.error("Failed to seed demo data:", error);
      res.status(500).json({ error: "Failed to seed demo data" });
    }
  });

  // Seed Master Data for Swab Monitoring
  app.post("/api/swab-monitoring/seed", async (req, res) => {
    try {
      // Check if already seeded
      const existingAreas = await storage.getAllSwabAreas();
      if (existingAreas.length > 0) {
        return res.json({ message: "Master data already seeded" });
      }

      // Seed Areas
      const areas = [
        { block: "Main Building", floor: "1st Floor", areaType: "OT", areaName: "OT-1 (General Surgery)", equipment: "OT Table, Anesthesia Machine", isActive: true },
        { block: "Main Building", floor: "1st Floor", areaType: "OT", areaName: "OT-2 (Cardiac)", equipment: "OT Table, Heart-Lung Machine", isActive: true },
        { block: "Main Building", floor: "1st Floor", areaType: "OT", areaName: "OT-3 (Orthopedics)", equipment: "OT Table, C-Arm", isActive: true },
        { block: "Main Building", floor: "2nd Floor", areaType: "ICU", areaName: "ICU-1 (Medical)", equipment: "Ventilators, Monitors", isActive: true },
        { block: "Main Building", floor: "2nd Floor", areaType: "ICU", areaName: "ICU-2 (Surgical)", equipment: "Ventilators, Monitors", isActive: true },
        { block: "Main Building", floor: "2nd Floor", areaType: "ICU", areaName: "NICU", equipment: "Incubators, Phototherapy", isActive: true },
      ];
      for (const area of areas) {
        await storage.createSwabArea(area);
      }

      // Seed Sampling Sites
      const sites = [
        { siteName: "OT Table Surface", description: "Main operating table surface", isActive: true },
        { siteName: "OT Light Handle", description: "Surgical light handles", isActive: true },
        { siteName: "Anesthesia Machine Panel", description: "Control panel of anesthesia machine", isActive: true },
        { siteName: "Ventilator Control Panel", description: "ICU ventilator controls", isActive: true },
        { siteName: "Bed Rail", description: "Patient bed rails", isActive: true },
        { siteName: "Monitor Screen", description: "Patient monitor touch screen", isActive: true },
        { siteName: "IV Pole", description: "IV stand and pole", isActive: true },
        { siteName: "Door Handle", description: "Entry/exit door handles", isActive: true },
        { siteName: "Nurse Station Counter", description: "Nurse station work surface", isActive: true },
        { siteName: "Medical Trolley", description: "Medication and instrument trolley", isActive: true },
      ];
      for (const site of sites) {
        await storage.createSwabSamplingSite(site);
      }

      // Seed Organisms
      const organisms = [
        { organismName: "No Growth", category: "none", riskLevel: "low", description: "No bacterial growth detected", isActive: true },
        { organismName: "Staphylococcus epidermidis", category: "flora", riskLevel: "low", description: "Common skin flora", isActive: true },
        { organismName: "Bacillus species", category: "flora", riskLevel: "low", description: "Environmental contaminant", isActive: true },
        { organismName: "Coagulase-negative Staphylococci", category: "flora", riskLevel: "medium", description: "Skin flora, potential opportunistic pathogen", isActive: true },
        { organismName: "Staphylococcus aureus", category: "pathogen", riskLevel: "high", description: "Common pathogen causing HAI", isActive: true },
        { organismName: "MRSA", category: "pathogen", riskLevel: "critical", description: "Methicillin-resistant S. aureus", isActive: true },
        { organismName: "Pseudomonas aeruginosa", category: "pathogen", riskLevel: "high", description: "Opportunistic pathogen", isActive: true },
        { organismName: "Acinetobacter baumannii", category: "pathogen", riskLevel: "critical", description: "MDR pathogen", isActive: true },
        { organismName: "Escherichia coli", category: "pathogen", riskLevel: "high", description: "Gram-negative pathogen", isActive: true },
        { organismName: "Klebsiella pneumoniae", category: "pathogen", riskLevel: "high", description: "Gram-negative pathogen", isActive: true },
        { organismName: "Candida species", category: "pathogen", riskLevel: "medium", description: "Fungal pathogen", isActive: true },
        { organismName: "Aspergillus species", category: "pathogen", riskLevel: "high", description: "Environmental fungus, dangerous in immunocompromised", isActive: true },
      ];
      for (const organism of organisms) {
        await storage.createSwabOrganism(organism);
      }

      res.json({ message: "Master data seeded successfully", areas: areas.length, sites: sites.length, organisms: organisms.length });
    } catch (error) {
      console.error("Failed to seed master data:", error);
      res.status(500).json({ error: "Failed to seed master data" });
    }
  });

  // ========== DISEASE KNOWLEDGE ROUTES ==========

  // Helper to verify disease knowledge access (Admin, Doctor, Nurse, OPD Manager)
  const verifyDiseaseKnowledgeAccess = (req: express.Request, res: express.Response): boolean => {
    const userRole = req.headers['x-user-role'] as string;
    const allowedRoles = ['ADMIN', 'DOCTOR', 'NURSE', 'OPD_MANAGER'];
    if (!userRole || !allowedRoles.includes(userRole)) {
      res.status(403).json({ error: "Access denied. Disease knowledge requires staff access." });
      return false;
    }
    return true;
  };

  // Disease Catalog - Read access for all logged-in users (educational content)
  app.get("/api/diseases", async (req, res) => {
    try {
      const { category } = req.query;
      let diseases;
      if (category && typeof category === "string") {
        diseases = await storage.getDiseasesByCategory(category);
      } else {
        diseases = await storage.getAllDiseases();
      }
      res.json(diseases);
    } catch (error) {
      console.error("Failed to fetch diseases:", error);
      res.status(500).json({ error: "Failed to fetch diseases" });
    }
  });

  app.get("/api/diseases/:id", async (req, res) => {
    try {
      const disease = await storage.getDisease(req.params.id);
      if (disease) {
        res.json(disease);
      } else {
        res.status(404).json({ error: "Disease not found" });
      }
    } catch (error) {
      console.error("Failed to fetch disease:", error);
      res.status(500).json({ error: "Failed to fetch disease" });
    }
  });

  app.post("/api/diseases", async (req, res) => {
    try {
      const userRole = req.headers['x-user-role'] as string;
      if (userRole !== 'ADMIN') {
        return res.status(403).json({ error: "Only admins can create diseases" });
      }
      const disease = await storage.createDisease(req.body);
      res.json(disease);
    } catch (error) {
      console.error("Failed to create disease:", error);
      res.status(500).json({ error: "Failed to create disease" });
    }
  });

  // Diet Templates - Read access for all logged-in users
  app.get("/api/diet-templates", async (req, res) => {
    try {
      const { diseaseId } = req.query;
      let templates;
      if (diseaseId && typeof diseaseId === "string") {
        templates = await storage.getDietTemplatesByDisease(diseaseId);
      } else {
        templates = await storage.getAllDietTemplates();
      }
      res.json(templates);
    } catch (error) {
      console.error("Failed to fetch diet templates:", error);
      res.status(500).json({ error: "Failed to fetch diet templates" });
    }
  });

  app.post("/api/diet-templates", async (req, res) => {
    try {
      const userRole = req.headers['x-user-role'] as string;
      if (userRole !== 'ADMIN') {
        return res.status(403).json({ error: "Only admins can create diet templates" });
      }
      const template = await storage.createDietTemplate(req.body);
      res.json(template);
    } catch (error) {
      console.error("Failed to create diet template:", error);
      res.status(500).json({ error: "Failed to create diet template" });
    }
  });

  // Medication Schedule Templates - Read access for all logged-in users
  app.get("/api/medication-schedules", async (req, res) => {
    try {
      const { diseaseId } = req.query;
      let templates;
      if (diseaseId && typeof diseaseId === "string") {
        templates = await storage.getMedicationScheduleTemplatesByDisease(diseaseId);
      } else {
        templates = await storage.getAllMedicationScheduleTemplates();
      }
      res.json(templates);
    } catch (error) {
      console.error("Failed to fetch medication schedules:", error);
      res.status(500).json({ error: "Failed to fetch medication schedules" });
    }
  });

  app.post("/api/medication-schedules", async (req, res) => {
    try {
      const userRole = req.headers['x-user-role'] as string;
      if (userRole !== 'ADMIN') {
        return res.status(403).json({ error: "Only admins can create medication schedules" });
      }
      const template = await storage.createMedicationScheduleTemplate(req.body);
      res.json(template);
    } catch (error) {
      console.error("Failed to create medication schedule:", error);
      res.status(500).json({ error: "Failed to create medication schedule" });
    }
  });

  // Patient Disease Assignments - Staff access only
  app.get("/api/patient-disease-assignments", async (req, res) => {
    try {
      if (!verifyDiseaseKnowledgeAccess(req, res)) return;
      const { patientId } = req.query;
      let assignments;
      if (patientId && typeof patientId === "string") {
        assignments = await storage.getPatientDiseaseAssignmentsByPatient(patientId);
      } else {
        assignments = await storage.getAllPatientDiseaseAssignments();
      }
      res.json(assignments);
    } catch (error) {
      console.error("Failed to fetch assignments:", error);
      res.status(500).json({ error: "Failed to fetch assignments" });
    }
  });

  app.post("/api/patient-disease-assignments", async (req, res) => {
    try {
      const userRole = req.headers['x-user-role'] as string;
      if (userRole !== 'ADMIN' && userRole !== 'DOCTOR') {
        return res.status(403).json({ error: "Only doctors and admins can assign diseases" });
      }
      const assignment = await storage.createPatientDiseaseAssignment(req.body);
      res.json(assignment);
    } catch (error) {
      console.error("Failed to create assignment:", error);
      res.status(500).json({ error: "Failed to create assignment" });
    }
  });

  // Personalized Care Plans - Staff access only
  app.get("/api/care-plans", async (req, res) => {
    try {
      if (!verifyDiseaseKnowledgeAccess(req, res)) return;
      const { patientId, assignmentId } = req.query;
      if (assignmentId && typeof assignmentId === "string") {
        const plan = await storage.getPersonalizedCarePlanByAssignment(assignmentId);
        res.json(plan || null);
      } else if (patientId && typeof patientId === "string") {
        const plans = await storage.getPersonalizedCarePlansByPatient(patientId);
        res.json(plans);
      } else {
        res.status(400).json({ error: "patientId or assignmentId required" });
      }
    } catch (error) {
      console.error("Failed to fetch care plans:", error);
      res.status(500).json({ error: "Failed to fetch care plans" });
    }
  });

  app.post("/api/care-plans", async (req, res) => {
    try {
      const userRole = req.headers['x-user-role'] as string;
      if (userRole !== 'ADMIN' && userRole !== 'DOCTOR') {
        return res.status(403).json({ error: "Only doctors and admins can create care plans" });
      }
      const plan = await storage.createPersonalizedCarePlan(req.body);
      res.json(plan);
    } catch (error) {
      console.error("Failed to create care plan:", error);
      res.status(500).json({ error: "Failed to create care plan" });
    }
  });

  // AI Personalization - Generate personalized care plan using OpenAI
  app.post("/api/care-plans/generate", async (req, res) => {
    try {
      const userRole = req.headers['x-user-role'] as string;
      if (userRole !== 'ADMIN' && userRole !== 'DOCTOR') {
        return res.status(403).json({ error: "Only doctors and admins can generate AI care plans" });
      }
      
      const { assignmentId, patientInfo, generatedBy, generatedByName } = req.body;
      
      if (!assignmentId) {
        return res.status(400).json({ error: "Assignment ID is required" });
      }
      
      const assignment = await storage.getPatientDiseaseAssignment(assignmentId);
      if (!assignment) {
        return res.status(404).json({ error: "Assignment not found" });
      }
      
      const disease = await storage.getDisease(assignment.diseaseId);
      if (!disease) {
        return res.status(404).json({ error: "Disease not found" });
      }

      const dietTemplates = await storage.getDietTemplatesByDisease(assignment.diseaseId);
      const medSchedules = await storage.getMedicationScheduleTemplatesByDisease(assignment.diseaseId);

      // Build AI prompt for personalization
      const prompt = `You are an AI Clinical Care & Nutrition Intelligence System for an Indian hospital. Generate a personalized care plan in JSON format.

PATIENT PROFILE:
- Age: ${patientInfo.age || "Not specified"}
- Gender: ${patientInfo.gender || "Not specified"}
- Weight: ${patientInfo.weight || "Not specified"} kg
- BMI: ${patientInfo.bmi || "Not specified"}
- Activity Level: ${patientInfo.activityLevel || "Moderate"}
- Diet Preference: ${patientInfo.dietPreference || "Both (Veg/Non-veg)"}
- OPD/IPD Status: ${assignment.opdIpdStatus}
- Disease Severity: ${assignment.severity}

DISEASE: ${disease.diseaseName}
CATEGORY: ${disease.category}
DESCRIPTION: ${disease.shortDescription}

BASE DIET TEMPLATES: ${JSON.stringify(dietTemplates.map(d => ({ name: d.templateName, type: d.dietType, plan: d.mealPlan })))}

MEDICATION SCHEDULE TEMPLATES: ${JSON.stringify(medSchedules.map(m => ({ category: m.medicineCategory, timing: m.typicalTiming, foodRelation: m.beforeAfterFood })))}

Generate a personalized JSON response with:
1. personalizedDiet: Customized Indian diet plan with early_morning, breakfast, mid_morning, lunch, evening_snack, dinner, bedtime
2. personalizedSchedule: Medicine timing guidance (NOT prescriptions)
3. personalizedLifestyle: Activity recommendations, yoga, stress management
4. personalizedMonitoring: Daily/weekly/monthly check recommendations

IMPORTANT: Follow ICMR/MoHFW guidelines. Include disclaimer that this is for educational purposes only.`;

      let aiResponse;
      try {
        const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
        const completion = await openai.chat.completions.create({
          model: "gpt-4o",
          messages: [{ role: "user", content: prompt }],
          response_format: { type: "json_object" },
          max_tokens: 2000,
        });
        aiResponse = JSON.parse(completion.choices[0].message.content || "{}");
      } catch (aiError) {
        console.error("OpenAI error, using template-based plan:", aiError);
        // Fallback to template-based plan
        aiResponse = {
          personalizedDiet: dietTemplates[0]?.mealPlan || "{}",
          personalizedSchedule: JSON.stringify(medSchedules),
          personalizedLifestyle: disease.activityRecommendations || "{}",
          personalizedMonitoring: disease.monitoringGuidelines || "{}",
        };
      }

      const carePlan = await storage.createPersonalizedCarePlan({
        patientId: assignment.patientId,
        assignmentId,
        personalizedDiet: typeof aiResponse.personalizedDiet === "string" ? aiResponse.personalizedDiet : JSON.stringify(aiResponse.personalizedDiet),
        personalizedSchedule: typeof aiResponse.personalizedSchedule === "string" ? aiResponse.personalizedSchedule : JSON.stringify(aiResponse.personalizedSchedule),
        personalizedLifestyle: typeof aiResponse.personalizedLifestyle === "string" ? aiResponse.personalizedLifestyle : JSON.stringify(aiResponse.personalizedLifestyle),
        personalizedMonitoring: typeof aiResponse.personalizedMonitoring === "string" ? aiResponse.personalizedMonitoring : JSON.stringify(aiResponse.personalizedMonitoring),
        aiInputParameters: JSON.stringify(patientInfo),
        generatedBy,
        generatedByName,
      });

      res.json(carePlan);
    } catch (error) {
      console.error("Failed to generate care plan:", error);
      res.status(500).json({ error: "Failed to generate care plan" });
    }
  });

  // Seed Disease Knowledge Data (Admin only, idempotent)
  app.post("/api/diseases/seed", async (req, res) => {
    try {
      const userRole = req.headers['x-user-role'] as string;
      if (userRole !== 'ADMIN') {
        return res.status(403).json({ error: "Only admins can seed disease data" });
      }
      
      const existingDiseases = await storage.getAllDiseases();
      if (existingDiseases.length > 0) {
        return res.json({ message: "Disease data already seeded", count: existingDiseases.length });
      }

      // Seed common Indian diseases
      const diseases = [
        {
          diseaseName: "Diabetes Type 2",
          alternateNames: "Type 2 DM, Adult-onset Diabetes, NIDDM",
          category: "metabolic",
          affectedSystem: "Endocrine System",
          shortDescription: "A condition where the body doesn't use insulin properly, leading to high blood sugar levels.",
          causes: JSON.stringify(["Insulin resistance", "Obesity", "Sedentary lifestyle", "Genetic factors", "Poor diet high in refined carbs"]),
          riskFactors: JSON.stringify(["Family history", "Obesity", "Age > 45", "PCOD in women", "High BP", "High cholesterol"]),
          symptoms: JSON.stringify(["Frequent urination", "Excessive thirst", "Unexplained weight loss", "Fatigue", "Blurred vision", "Slow healing wounds"]),
          emergencySigns: JSON.stringify(["Blood sugar > 400 mg/dL", "Confusion", "Rapid breathing", "Fruity breath odor", "Unconsciousness"]),
          clinicalParameters: JSON.stringify({ fasting_glucose: { normal: "<100", target: "<126", danger: ">200" }, hba1c: { normal: "<5.7%", target: "<7%", danger: ">9%" }, postprandial: { normal: "<140", target: "<180", danger: ">250" } }),
          dosList: JSON.stringify(["Walk 30 mins daily", "Monitor blood sugar regularly", "Take medicines on time", "Eat at fixed times", "Include fiber in diet"]),
          dontsList: JSON.stringify(["Skip meals", "Eat sweets/mithai", "Drink sugary drinks", "Skip medicines", "Ignore foot injuries"]),
          activityRecommendations: JSON.stringify({ walking: "30 mins morning/evening", yoga: "Pranayama, Mandukasana", stress: "Deep breathing, meditation" }),
          monitoringGuidelines: JSON.stringify({ daily: ["Fasting glucose", "Post-meal glucose"], weekly: ["Weight check", "Foot inspection"], monthly: ["HbA1c if needed", "BP check"] }),
          isActive: true,
        },
        {
          diseaseName: "Hypertension",
          alternateNames: "High Blood Pressure, BP, Essential Hypertension",
          category: "cardiovascular",
          affectedSystem: "Cardiovascular System",
          shortDescription: "A condition where blood pressure in arteries is persistently elevated, increasing heart disease risk.",
          causes: JSON.stringify(["Excessive salt intake", "Obesity", "Stress", "Smoking", "Alcohol", "Genetic factors"]),
          riskFactors: JSON.stringify(["Age > 40", "Family history", "Obesity", "High salt diet", "Sedentary lifestyle", "Diabetes"]),
          symptoms: JSON.stringify(["Headache (especially morning)", "Dizziness", "Nosebleeds", "Shortness of breath", "Chest pain", "Often no symptoms"]),
          emergencySigns: JSON.stringify(["BP > 180/120", "Severe headache", "Chest pain", "Vision problems", "Difficulty speaking", "Numbness"]),
          clinicalParameters: JSON.stringify({ systolic: { normal: "<120", target: "<130", danger: ">180" }, diastolic: { normal: "<80", target: "<85", danger: ">120" } }),
          dosList: JSON.stringify(["Reduce salt intake", "Exercise regularly", "Maintain healthy weight", "Take medicines daily", "Manage stress"]),
          dontsList: JSON.stringify(["Eat pickle, papad excessively", "Skip BP medicines", "Smoke or use tobacco", "Drink alcohol", "Eat processed foods"]),
          activityRecommendations: JSON.stringify({ walking: "45 mins brisk walk daily", yoga: "Shavasana, Pranayama", stress: "Meditation, music therapy" }),
          monitoringGuidelines: JSON.stringify({ daily: ["BP morning and evening"], weekly: ["Weight check"], monthly: ["Doctor visit if uncontrolled"] }),
          isActive: true,
        },
        {
          diseaseName: "Tuberculosis",
          alternateNames: "TB, Pulmonary TB, Koch's Disease",
          category: "respiratory",
          affectedSystem: "Respiratory System",
          shortDescription: "A bacterial infection that primarily affects the lungs but can spread to other organs.",
          causes: JSON.stringify(["Mycobacterium tuberculosis bacteria", "Airborne transmission", "Close contact with infected person"]),
          riskFactors: JSON.stringify(["Weakened immune system", "HIV infection", "Malnutrition", "Crowded living", "Diabetes", "Smoking"]),
          symptoms: JSON.stringify(["Persistent cough > 2 weeks", "Blood in sputum", "Night sweats", "Weight loss", "Evening fever", "Loss of appetite"]),
          emergencySigns: JSON.stringify(["Coughing blood", "Severe breathing difficulty", "High fever", "Extreme weakness"]),
          clinicalParameters: JSON.stringify({ sputum_test: "AFB positive/negative", chest_xray: "Cavity/infiltrates", weight: "Monitor weekly" }),
          dosList: JSON.stringify(["Complete full DOTS course", "Eat protein-rich diet", "Cover mouth while coughing", "Ensure good ventilation", "Take medicines under supervision"]),
          dontsList: JSON.stringify(["Stop medicines early", "Spit in open", "Share utensils", "Skip doses", "Smoke or drink alcohol"]),
          activityRecommendations: JSON.stringify({ rest: "Adequate rest during treatment", walking: "Light walking as tolerated", breathing: "Deep breathing exercises after recovery" }),
          monitoringGuidelines: JSON.stringify({ weekly: ["Weight check", "Medicine adherence"], monthly: ["Sputum test", "Doctor visit"], end_of_treatment: ["Chest X-ray"] }),
          isActive: true,
        },
        {
          diseaseName: "Dengue",
          alternateNames: "Dengue Fever, Break-bone Fever",
          category: "infectious",
          affectedSystem: "Blood/Immune System",
          shortDescription: "A mosquito-borne viral infection causing high fever and severe body pain.",
          causes: JSON.stringify(["Dengue virus", "Aedes mosquito bite", "Stagnant water breeding"]),
          riskFactors: JSON.stringify(["Monsoon season", "Stagnant water around home", "Previous dengue infection", "Urban areas"]),
          symptoms: JSON.stringify(["High fever (104Â°F)", "Severe headache", "Pain behind eyes", "Muscle and joint pain", "Skin rash", "Nausea"]),
          emergencySigns: JSON.stringify(["Platelet count < 50,000", "Bleeding from gums/nose", "Blood in vomit/stool", "Severe abdominal pain", "Persistent vomiting"]),
          clinicalParameters: JSON.stringify({ platelets: { normal: ">150,000", caution: "100,000-150,000", danger: "<50,000" }, hematocrit: "Monitor for hemoconcentration" }),
          dosList: JSON.stringify(["Drink plenty of fluids", "Eat papaya leaf extract", "Complete bed rest", "Monitor platelet count", "Use mosquito nets"]),
          dontsList: JSON.stringify(["Take aspirin/ibuprofen", "Ignore warning signs", "Delay hospital visit", "Self-medicate"]),
          activityRecommendations: JSON.stringify({ rest: "Complete bed rest during fever", hydration: "3-4 liters fluids daily", recovery: "Gradual return to activity" }),
          monitoringGuidelines: JSON.stringify({ daily: ["Temperature", "Platelet count", "Fluid intake"], warning: ["Watch for bleeding", "Monitor BP"] }),
          isActive: true,
        },
        {
          diseaseName: "Asthma",
          alternateNames: "Bronchial Asthma, Dama",
          category: "respiratory",
          affectedSystem: "Respiratory System",
          shortDescription: "A chronic condition causing inflammation and narrowing of airways, leading to breathing difficulty.",
          causes: JSON.stringify(["Allergies", "Air pollution", "Dust mites", "Cold air", "Exercise", "Stress"]),
          riskFactors: JSON.stringify(["Family history", "Allergies", "Childhood respiratory infections", "Smoking exposure", "Obesity"]),
          symptoms: JSON.stringify(["Wheezing", "Shortness of breath", "Chest tightness", "Coughing (especially at night)", "Difficulty speaking"]),
          emergencySigns: JSON.stringify(["Severe breathlessness", "Blue lips/fingernails", "Inhaler not helping", "Cannot speak in sentences", "Confusion"]),
          clinicalParameters: JSON.stringify({ peak_flow: "Monitor daily", oxygen: { normal: ">95%", danger: "<90%" } }),
          dosList: JSON.stringify(["Keep inhaler always", "Identify triggers", "Take preventive medicines", "Keep home dust-free", "Practice breathing exercises"]),
          dontsList: JSON.stringify(["Ignore early symptoms", "Stop preventer medicines", "Smoke or be near smokers", "Exercise in polluted air", "Keep pets in bedroom"]),
          activityRecommendations: JSON.stringify({ breathing: "Pranayama daily", swimming: "Good for lung capacity", avoid: "High pollution areas" }),
          monitoringGuidelines: JSON.stringify({ daily: ["Peak flow reading", "Symptom diary"], monthly: ["Inhaler technique check"], yearly: ["Lung function test"] }),
          isActive: true,
        },
      ];

      for (const disease of diseases) {
        const created = await storage.createDisease(disease);
        
        // Create diet template for each disease
        await storage.createDietTemplate({
          diseaseId: created.id,
          templateName: `Standard ${disease.diseaseName} Diet`,
          dietType: "both",
          mealPlan: JSON.stringify({
            early_morning: "Warm water with lemon/methi seeds water",
            breakfast: "Oats upma/poha with vegetables, 1 cup tea without sugar",
            mid_morning: "1 fruit (apple/guava) or handful of nuts",
            lunch: "2 roti, dal, sabzi, salad, curd",
            evening_snack: "Green tea with roasted chana/makhana",
            dinner: "1-2 roti, light sabzi, dal soup",
            bedtime: "Warm turmeric milk (if applicable)"
          }),
          foodsToAvoid: JSON.stringify(["White sugar", "Maida products", "Fried foods", "Packaged snacks", "Sugary drinks"]),
          foodsToLimit: JSON.stringify(["Rice", "Potatoes", "Mangoes", "Grapes", "Bananas"]),
          safeInModeration: JSON.stringify(["Brown rice", "Sweet potato", "Dark chocolate", "Dry fruits"]),
          portionGuidance: "Use small plates, fill half with vegetables",
          hydrationGuidance: "8-10 glasses water daily, more in summer",
          isActive: true,
        });

        // Create medication schedule template
        await storage.createMedicationScheduleTemplate({
          diseaseId: created.id,
          medicineCategory: disease.category === "metabolic" ? "Antidiabetic" : disease.category === "cardiovascular" ? "Antihypertensive" : "As prescribed",
          typicalTiming: "Morning",
          beforeAfterFood: disease.diseaseName.includes("Diabetes") ? "before" : "after",
          missedDoseInstructions: "Take as soon as remembered. Skip if close to next dose.",
          storageGuidelines: "Store in cool, dry place away from sunlight",
          interactionWarnings: JSON.stringify(["Avoid alcohol", "Inform doctor about all medicines"]),
          generalNotes: "This is timing guidance only, NOT a prescription. Consult your doctor.",
          isActive: true,
        });
      }

      res.json({ message: "Disease knowledge data seeded successfully", count: diseases.length });
    } catch (error) {
      console.error("Failed to seed disease data:", error);
      res.status(500).json({ error: "Failed to seed disease data" });
    }
  });

  // ========== PATIENT MONITORING MODULE ROUTES ==========
  // Medical-Grade, ICU Chart & Nursing Workflow (NABH-Compliant)

  // Get all monitoring sessions
  app.get("/api/patient-monitoring/sessions", async (_req, res) => {
    try {
      const sessions = await db.select().from(patientMonitoringSessions).orderBy(desc(patientMonitoringSessions.createdAt));
      res.json(sessions);
    } catch (error) {
      console.error("Failed to fetch monitoring sessions:", error);
      res.status(500).json({ error: "Failed to fetch monitoring sessions" });
    }
  });

  // Get sessions by patient
  app.get("/api/patient-monitoring/sessions/patient/:patientId", async (req, res) => {
    try {
      const sessions = await db.select().from(patientMonitoringSessions)
        .where(eq(patientMonitoringSessions.patientId, req.params.patientId))
        .orderBy(desc(patientMonitoringSessions.sessionDate));
      res.json(sessions);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patient sessions" });
    }
  });

  // Get single session with all data
  app.get("/api/patient-monitoring/sessions/:id", async (req, res) => {
    try {
      const session = await db.select().from(patientMonitoringSessions)
        .where(eq(patientMonitoringSessions.id, req.params.id));
      if (!session.length) {
        return res.status(404).json({ error: "Session not found" });
      }
      res.json(session[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch session" });
    }
  });

  // Create new monitoring session
  app.post("/api/patient-monitoring/sessions", async (req, res) => {
    try {
      console.log("Session create request body:", JSON.stringify(req.body, null, 2));
      // Convert admissionDateTime string to Date object and handle empty strings for numeric fields
      const dataToValidate = {
        ...req.body,
        admissionDateTime: req.body.admissionDateTime 
          ? new Date(req.body.admissionDateTime) 
          : new Date(),
        weightKg: req.body.weightKg && req.body.weightKg !== "" ? req.body.weightKg : null,
        bloodGroup: req.body.bloodGroup && req.body.bloodGroup !== "" ? req.body.bloodGroup : null
      };
      const parsed = insertPatientMonitoringSessionSchema.safeParse(dataToValidate);
      if (!parsed.success) {
        console.log("Validation errors:", JSON.stringify(parsed.error.errors, null, 2));
        return res.status(400).json({ error: "Invalid session data", details: parsed.error.errors });
      }
      const result = await db.insert(patientMonitoringSessions).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      console.error("Failed to create monitoring session:", error);
      res.status(500).json({ error: "Failed to create monitoring session" });
    }
  });

  // Update session (lock patient info after first save)
  app.patch("/api/patient-monitoring/sessions/:id", async (req, res) => {
    try {
      const result = await db.update(patientMonitoringSessions)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(patientMonitoringSessions.id, req.params.id))
        .returning();
      res.json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to update session" });
    }
  });

  // ========== VITALS HOURLY (24 slots) ==========
  app.get("/api/patient-monitoring/vitals/:sessionId", async (req, res) => {
    try {
      const vitals = await db.select().from(vitalsHourly)
        .where(eq(vitalsHourly.sessionId, req.params.sessionId))
        .orderBy(vitalsHourly.hourSlot);
      res.json(vitals);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch vitals" });
    }
  });

  app.post("/api/patient-monitoring/vitals", async (req, res) => {
    try {
      const parsed = insertVitalsHourlySchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid vitals data", details: parsed.error });
      }
      const result = await db.insert(vitalsHourly).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to save vitals" });
    }
  });

  // ========== INOTROPES & SEDATION ==========
  app.get("/api/patient-monitoring/inotropes/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(inotropesSedation)
        .where(eq(inotropesSedation.sessionId, req.params.sessionId))
        .orderBy(desc(inotropesSedation.createdAt));
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch inotropes data" });
    }
  });

  app.post("/api/patient-monitoring/inotropes", async (req, res) => {
    try {
      const data = {
        ...req.body,
        startTime: req.body.startTime ? new Date(req.body.startTime) : undefined,
        endTime: req.body.endTime ? new Date(req.body.endTime) : undefined
      };
      const parsed = insertInotropesSedationSchema.safeParse(data);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(inotropesSedation).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to save inotropes data" });
    }
  });

  // ========== VENTILATOR SETTINGS (Conditional) ==========
  app.get("/api/patient-monitoring/ventilator/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(ventilatorSettings)
        .where(eq(ventilatorSettings.sessionId, req.params.sessionId))
        .orderBy(desc(ventilatorSettings.recordedAt));
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch ventilator settings" });
    }
  });

  app.post("/api/patient-monitoring/ventilator", async (req, res) => {
    try {
      const parsed = insertVentilatorSettingsSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(ventilatorSettings).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to save ventilator settings" });
    }
  });

  // ========== ABG & LAB RESULTS ==========
  app.get("/api/patient-monitoring/abg-lab/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(abgLabResults)
        .where(eq(abgLabResults.sessionId, req.params.sessionId))
        .orderBy(desc(abgLabResults.recordedAt));
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch ABG/Lab results" });
    }
  });

  app.post("/api/patient-monitoring/abg-lab", async (req, res) => {
    try {
      const parsed = insertAbgLabResultsSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(abgLabResults).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to save ABG/Lab results" });
    }
  });

  // ========== INTAKE CHART (Hourly with auto-sums) ==========
  app.get("/api/patient-monitoring/intake/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(intakeHourly)
        .where(eq(intakeHourly.sessionId, req.params.sessionId))
        .orderBy(intakeHourly.hourSlot);
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch intake data" });
    }
  });

  app.post("/api/patient-monitoring/intake", async (req, res) => {
    try {
      // Calculate hourly total
      const data = req.body;
      data.hourlyTotal = (data.ivLine1 || 0) + (data.ivLine2 || 0) + (data.ivLine3 || 0) + 
                         (data.ivLine4 || 0) + (data.ivLine5 || 0) + (data.ivLine6 || 0) +
                         (data.oral || 0) + (data.ngTube || 0) + (data.bloodProducts || 0) + 
                         (data.medications || 0);
      
      const parsed = insertIntakeHourlySchema.safeParse(data);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(intakeHourly).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to save intake data" });
    }
  });

  // ========== OUTPUT CHART (Hourly with auto-sums) ==========
  app.get("/api/patient-monitoring/output/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(outputHourly)
        .where(eq(outputHourly.sessionId, req.params.sessionId))
        .orderBy(outputHourly.hourSlot);
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch output data" });
    }
  });

  app.post("/api/patient-monitoring/output", async (req, res) => {
    try {
      // Calculate hourly total
      const data = req.body;
      data.hourlyTotal = (data.urineOutput || 0) + (data.drainOutput || 0) + 
                         (data.vomitus || 0) + (data.stool || 0) + (data.otherLosses || 0);
      
      const parsed = insertOutputHourlySchema.safeParse(data);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(outputHourly).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to save output data" });
    }
  });

  // Get 24-hour fluid balance summary
  app.get("/api/patient-monitoring/fluid-balance/:sessionId", async (req, res) => {
    try {
      const intakeData = await db.select().from(intakeHourly)
        .where(eq(intakeHourly.sessionId, req.params.sessionId));
      const outputData = await db.select().from(outputHourly)
        .where(eq(outputHourly.sessionId, req.params.sessionId));
      
      const totalIntake = intakeData.reduce((sum, i) => sum + (i.hourlyTotal || 0), 0);
      const totalOutput = outputData.reduce((sum, o) => sum + (o.hourlyTotal || 0), 0);
      const netBalance = totalIntake - totalOutput;
      
      res.json({ totalIntake, totalOutput, netBalance, intakeEntries: intakeData.length, outputEntries: outputData.length });
    } catch (error) {
      res.status(500).json({ error: "Failed to calculate fluid balance" });
    }
  });

  // ========== DIABETIC FLOW CHART ==========
  app.get("/api/patient-monitoring/diabetic/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(diabeticFlow)
        .where(eq(diabeticFlow.sessionId, req.params.sessionId))
        .orderBy(desc(diabeticFlow.createdAt));
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch diabetic flow data" });
    }
  });

  app.post("/api/patient-monitoring/diabetic", async (req, res) => {
    try {
      const data = {
        ...req.body,
        recordedTime: req.body.recordedTime ? new Date(req.body.recordedTime) : new Date()
      };
      // Auto-generate alerts
      if (data.bloodSugarLevel < 70) {
        data.alertType = "HYPOGLYCEMIA";
        data.alertMessage = "Low blood sugar detected. Immediate action required.";
      } else if (data.bloodSugarLevel > 250) {
        data.alertType = "HYPERGLYCEMIA";
        data.alertMessage = "High blood sugar detected. Review insulin dosage.";
      }
      
      const parsed = insertDiabeticFlowSchema.safeParse(data);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(diabeticFlow).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to save diabetic flow data" });
    }
  });

  // ========== MEDICATION ADMINISTRATION RECORD (MAR) ==========
  app.get("/api/patient-monitoring/mar/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(medicationAdminRecords)
        .where(eq(medicationAdminRecords.sessionId, req.params.sessionId))
        .orderBy(medicationAdminRecords.scheduledTime);
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch MAR data" });
    }
  });

  app.post("/api/patient-monitoring/mar", async (req, res) => {
    try {
      const data = {
        ...req.body,
        scheduledTime: req.body.scheduledTime ? new Date(req.body.scheduledTime) : new Date(),
        actualGivenTime: req.body.actualGivenTime ? new Date(req.body.actualGivenTime) : undefined
      };
      const parsed = insertMedicationAdminRecordSchema.safeParse(data);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(medicationAdminRecords).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to save MAR data" });
    }
  });

  // ========== ONCE-ONLY DRUGS ==========
  app.get("/api/patient-monitoring/once-only/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(onceOnlyDrugs)
        .where(eq(onceOnlyDrugs.sessionId, req.params.sessionId))
        .orderBy(desc(onceOnlyDrugs.createdAt));
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch once-only drugs" });
    }
  });

  app.post("/api/patient-monitoring/once-only", async (req, res) => {
    try {
      const data = {
        ...req.body,
        timeOrdered: req.body.timeOrdered ? new Date(req.body.timeOrdered) : new Date(),
        timeGiven: req.body.timeGiven ? new Date(req.body.timeGiven) : undefined
      };
      const parsed = insertOnceOnlyDrugSchema.safeParse(data);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(onceOnlyDrugs).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to save once-only drug" });
    }
  });

  // ========== NURSING SHIFT NOTES ==========
  app.get("/api/patient-monitoring/shift-notes/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(nursingShiftNotes)
        .where(eq(nursingShiftNotes.sessionId, req.params.sessionId))
        .orderBy(desc(nursingShiftNotes.noteTime));
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch shift notes" });
    }
  });

  app.post("/api/patient-monitoring/shift-notes", async (req, res) => {
    try {
      const data = {
        ...req.body,
        noteTime: req.body.noteTime ? new Date(req.body.noteTime) : new Date()
      };
      const parsed = insertNursingShiftNoteSchema.safeParse(data);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(nursingShiftNotes).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to save shift note" });
    }
  });

  // ========== AIRWAY, LINES & TUBES ==========
  app.get("/api/patient-monitoring/airway/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(airwayLinesTubes)
        .where(eq(airwayLinesTubes.sessionId, req.params.sessionId));
      res.json(data[0] || null);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch airway data" });
    }
  });

  app.post("/api/patient-monitoring/airway", async (req, res) => {
    try {
      const parsed = insertAirwayLinesTubesSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(airwayLinesTubes).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to save airway data" });
    }
  });

  app.patch("/api/patient-monitoring/airway/:id", async (req, res) => {
    try {
      const result = await db.update(airwayLinesTubes)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(airwayLinesTubes.id, req.params.id))
        .returning();
      res.json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to update airway data" });
    }
  });

  // ========== DUTY STAFF ASSIGNMENTS ==========
  app.get("/api/patient-monitoring/duty-staff/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(dutyStaffAssignments)
        .where(eq(dutyStaffAssignments.sessionId, req.params.sessionId))
        .orderBy(dutyStaffAssignments.shiftStartTime);
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch duty staff" });
    }
  });

  app.post("/api/patient-monitoring/duty-staff", async (req, res) => {
    try {
      const data = {
        ...req.body,
        shiftStartTime: req.body.shiftStartTime ? new Date(req.body.shiftStartTime) : new Date(),
        shiftEndTime: req.body.shiftEndTime ? new Date(req.body.shiftEndTime) : undefined
      };
      const parsed = insertDutyStaffAssignmentSchema.safeParse(data);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(dutyStaffAssignments).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to save duty staff" });
    }
  });

  // ========== ALLERGIES & PRECAUTIONS ==========
  app.get("/api/patient-monitoring/allergies/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(patientAllergiesPrecautions)
        .where(eq(patientAllergiesPrecautions.sessionId, req.params.sessionId));
      res.json(data[0] || null);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch allergies" });
    }
  });

  app.post("/api/patient-monitoring/allergies", async (req, res) => {
    try {
      const parsed = insertPatientAllergiesPrecautionsSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(patientAllergiesPrecautions).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to save allergies" });
    }
  });

  app.patch("/api/patient-monitoring/allergies/:id", async (req, res) => {
    try {
      const result = await db.update(patientAllergiesPrecautions)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(patientAllergiesPrecautions.id, req.params.id))
        .returning();
      res.json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to update allergies" });
    }
  });

  // ========== IPD INVESTIGATION CHART ==========
  app.get("/api/patient-monitoring/sessions/:sessionId/investigation-chart", async (req, res) => {
    try {
      const data = await db.select().from(ipdInvestigationChart)
        .where(eq(ipdInvestigationChart.sessionId, req.params.sessionId))
        .orderBy(desc(ipdInvestigationChart.investigationDate));
      res.json(data);
    } catch (error) {
      console.error("Error fetching investigation chart:", error);
      res.status(500).json({ error: "Failed to fetch investigation chart" });
    }
  });

  app.post("/api/patient-monitoring/sessions/:sessionId/investigation-chart", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).session?.user?.id;
      const userName = (req as any).session?.user?.fullName || (req as any).session?.user?.name;
      const parsed = insertIpdInvestigationChartSchema.safeParse({
        ...req.body,
        investigationDate: req.body.investigationDate ? new Date(req.body.investigationDate) : new Date(),
        sessionId: req.params.sessionId,
        nurseId: userId,
        nurseName: userName,
      });
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(ipdInvestigationChart).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      console.error("Error creating investigation chart entry:", error);
      res.status(500).json({ error: "Failed to create investigation chart entry" });
    }
  });

  app.patch("/api/patient-monitoring/investigation-chart/:id", requireAuth, async (req, res) => {
    try {
      const result = await db.update(ipdInvestigationChart)
        .set(req.body)
        .where(eq(ipdInvestigationChart.id, req.params.id))
        .returning();
      res.json(result[0]);
    } catch (error) {
      console.error("Error updating investigation chart:", error);
      res.status(500).json({ error: "Failed to update investigation chart" });
    }
  });

  // ========== PATIENT MONITORING TESTS ==========
  app.get("/api/patient-monitoring/sessions/:sessionId/tests", async (req, res) => {
    try {
      const tests = await storage.getDiagnosticTestOrdersBySession(req.params.sessionId);
      res.json(tests);
    } catch (error) {
      console.error("Error fetching session tests:", error);
      res.status(500).json({ error: "Failed to fetch tests" });
    }
  });

  app.post("/api/patient-monitoring/sessions/:sessionId/tests", requireAuth, async (req, res) => {
    try {
      // Use the logged-in user's ID as doctorId if not provided
      const userId = (req as any).session?.user?.id;
      const userName = (req as any).session?.user?.name || req.body.doctorName;
      const doctorId = req.body.doctorId || userId || "SYSTEM";
      const doctorName = req.body.doctorName || userName || "System";
      const testOrder = await storage.createDiagnosticTestOrder({
        ...req.body,
        doctorId,
        doctorName,
        sessionId: req.params.sessionId,
        source: "PATIENT_MONITORING",
        status: "PENDING",
      });

      // Send real-time notifications to all technicians
      await notificationService.notifyTechniciansNewTestOrder({
        id: testOrder.id,
        testName: req.body.testName,
        testType: req.body.testType || "Pathology",
        patientId: req.body.patientId,
        patientName: req.body.patientName,
        doctorId,
        doctorName,
        priority: req.body.priority || "routine",
        sessionId: req.params.sessionId
      });

      res.status(201).json(testOrder);
    } catch (error) {
      console.error("Error creating test order:", error);
      res.status(500).json({ error: "Failed to create test order" });
    }
  });

  // ========== AUDIT LOG ==========
  app.get("/api/patient-monitoring/audit/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(patientMonitoringAuditLog)
        .where(eq(patientMonitoringAuditLog.sessionId, req.params.sessionId))
        .orderBy(desc(patientMonitoringAuditLog.timestamp));
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch audit log" });
    }
  });

  app.post("/api/patient-monitoring/audit", async (req, res) => {
    try {
      const parsed = insertPatientMonitoringAuditLogSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(patientMonitoringAuditLog).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to save audit log" });
    }
  });

  // ========== IPD CARE PLAN ==========
  app.get("/api/patient-monitoring/care-plan/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(ipdCarePlans)
        .where(eq(ipdCarePlans.sessionId, req.params.sessionId))
        .orderBy(desc(ipdCarePlans.createdAt));
      res.json(data);
    } catch (error) {
      console.error("Error fetching care plans:", error);
      res.status(500).json({ error: "Failed to fetch care plans" });
    }
  });

  app.post("/api/patient-monitoring/care-plan", requireAuth, async (req, res) => {
    try {
      const parsed = insertIpdCarePlanSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(ipdCarePlans).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      console.error("Error creating care plan:", error);
      res.status(500).json({ error: "Failed to create care plan" });
    }
  });

  app.patch("/api/patient-monitoring/care-plan/:id", requireAuth, async (req, res) => {
    try {
      const result = await db.update(ipdCarePlans)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(ipdCarePlans.id, req.params.id))
        .returning();
      res.json(result[0]);
    } catch (error) {
      console.error("Error updating care plan:", error);
      res.status(500).json({ error: "Failed to update care plan" });
    }
  });

  app.delete("/api/patient-monitoring/care-plan/:id", requireAuth, async (req, res) => {
    try {
      await db.delete(ipdCarePlans).where(eq(ipdCarePlans.id, req.params.id));
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting care plan:", error);
      res.status(500).json({ error: "Failed to delete care plan" });
    }
  });

  // Care Plan Consultant Notes
  app.get("/api/patient-monitoring/care-plan/:carePlanId/notes", async (req, res) => {
    try {
      const data = await db.select().from(ipdCarePlanNotes)
        .where(eq(ipdCarePlanNotes.carePlanId, req.params.carePlanId))
        .orderBy(desc(ipdCarePlanNotes.noteDate));
      res.json(data);
    } catch (error) {
      console.error("Error fetching care plan notes:", error);
      res.status(500).json({ error: "Failed to fetch care plan notes" });
    }
  });

  app.post("/api/patient-monitoring/care-plan-notes", requireAuth, async (req, res) => {
    try {
      const parsed = insertIpdCarePlanNotesSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid data", details: parsed.error });
      }
      const result = await db.insert(ipdCarePlanNotes).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      console.error("Error creating care plan note:", error);
      res.status(500).json({ error: "Failed to create care plan note" });
    }
  });

  app.delete("/api/patient-monitoring/care-plan-notes/:id", requireAuth, async (req, res) => {
    try {
      await db.delete(ipdCarePlanNotes).where(eq(ipdCarePlanNotes.id, req.params.id));
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting care plan note:", error);
      res.status(500).json({ error: "Failed to delete care plan note" });
    }
  });

  // ========== IPD INITIAL ASSESSMENT FORM ==========
  // Get IPD Initial Assessment by session
  app.get("/api/patient-monitoring/initial-assessment/:sessionId", async (req, res) => {
    try {
      const data = await db.select().from(ipdInitialAssessment)
        .where(eq(ipdInitialAssessment.sessionId, req.params.sessionId))
        .orderBy(desc(ipdInitialAssessment.createdAt));
      res.json(data);
    } catch (error) {
      console.error("Error fetching IPD initial assessment:", error);
      res.status(500).json({ error: "Failed to fetch initial assessment" });
    }
  });

  // Create IPD Initial Assessment
  app.post("/api/patient-monitoring/initial-assessment", requireAuth, async (req, res) => {
    try {
      const data = { ...req.body };
      // Convert date strings to Date objects
      if (data.patientReceivedDate && typeof data.patientReceivedDate === 'string') {
        data.patientReceivedDate = new Date(data.patientReceivedDate);
      }
      if (data.clinicalAssistantDate && typeof data.clinicalAssistantDate === 'string') {
        data.clinicalAssistantDate = new Date(data.clinicalAssistantDate);
      }
      if (data.inchargeConsultantDate && typeof data.inchargeConsultantDate === 'string') {
        data.inchargeConsultantDate = new Date(data.inchargeConsultantDate);
      }
      const result = await db.insert(ipdInitialAssessment).values({
        ...data,
        createdBy: req.session?.user?.id
      }).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      console.error("Error creating IPD initial assessment:", error);
      res.status(500).json({ error: "Failed to create initial assessment" });
    }
  });

  // Update IPD Initial Assessment
  app.patch("/api/patient-monitoring/initial-assessment/:id", requireAuth, async (req, res) => {
    try {
      const data = { ...req.body };
      // Remove fields that shouldn't be updated
      delete data.id;
      delete data.createdAt;
      delete data.updatedAt;
      
      // Convert date strings to Date objects (handle various date formats)
      const parseDate = (val: any) => {
        if (!val) return null;
        if (val instanceof Date) return val;
        if (typeof val === 'string') {
          const d = new Date(val);
          return isNaN(d.getTime()) ? null : d;
        }
        return null;
      };
      
      if (data.patientReceivedDate !== undefined) {
        data.patientReceivedDate = parseDate(data.patientReceivedDate);
      }
      if (data.clinicalAssistantDate !== undefined) {
        data.clinicalAssistantDate = parseDate(data.clinicalAssistantDate);
      }
      if (data.inchargeConsultantDate !== undefined) {
        data.inchargeConsultantDate = parseDate(data.inchargeConsultantDate);
      }
      
      const result = await db.update(ipdInitialAssessment)
        .set({ ...data, updatedAt: new Date() })
        .where(eq(ipdInitialAssessment.id, req.params.id))
        .returning();
      res.json(result[0]);
    } catch (error) {
      console.error("Error updating IPD initial assessment:", error);
      res.status(500).json({ error: "Failed to update initial assessment" });
    }
  });

  // Delete IPD Initial Assessment
  app.delete("/api/patient-monitoring/initial-assessment/:id", requireAuth, async (req, res) => {
    try {
      await db.delete(ipdInitialAssessment).where(eq(ipdInitialAssessment.id, req.params.id));
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting IPD initial assessment:", error);
      res.status(500).json({ error: "Failed to delete initial assessment" });
    }
  });

  // ========== INDOOR CONSULTATION SHEET (Daily Progress Notes) ==========
  
  // Get all entries for a session
  app.get("/api/patient-monitoring/indoor-consultation/:sessionId", async (req, res) => {
    try {
      const entries = await db.select().from(indoorConsultationSheet)
        .where(eq(indoorConsultationSheet.sessionId, req.params.sessionId))
        .orderBy(desc(indoorConsultationSheet.entryDate));
      res.json(entries);
    } catch (error) {
      console.error("Error fetching indoor consultation sheet:", error);
      res.status(500).json({ error: "Failed to fetch indoor consultation entries" });
    }
  });

  // Create new entry
  app.post("/api/patient-monitoring/indoor-consultation", requireAuth, async (req, res) => {
    try {
      const data = { ...req.body };
      if (data.entryDate && typeof data.entryDate === 'string') {
        data.entryDate = new Date(data.entryDate);
      }
      const result = await db.insert(indoorConsultationSheet).values({
        ...data,
        createdBy: req.session?.user?.id
      }).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      console.error("Error creating indoor consultation entry:", error);
      res.status(500).json({ error: "Failed to create indoor consultation entry" });
    }
  });

  // Update entry
  app.patch("/api/patient-monitoring/indoor-consultation/:id", requireAuth, async (req, res) => {
    try {
      const data = { ...req.body };
      delete data.id;
      delete data.createdAt;
      delete data.updatedAt;
      if (data.entryDate && typeof data.entryDate === 'string') {
        data.entryDate = new Date(data.entryDate);
      }
      const result = await db.update(indoorConsultationSheet)
        .set({ ...data, updatedAt: new Date() })
        .where(eq(indoorConsultationSheet.id, req.params.id))
        .returning();
      res.json(result[0]);
    } catch (error) {
      console.error("Error updating indoor consultation entry:", error);
      res.status(500).json({ error: "Failed to update indoor consultation entry" });
    }
  });

  // Delete entry
  app.delete("/api/patient-monitoring/indoor-consultation/:id", requireAuth, async (req, res) => {
    try {
      await db.delete(indoorConsultationSheet).where(eq(indoorConsultationSheet.id, req.params.id));
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting indoor consultation entry:", error);
      res.status(500).json({ error: "Failed to delete indoor consultation entry" });
    }
  });

  // ========== DOCTOR'S PROGRESS SHEET ==========
  // Get entries by session ID
  app.get("/api/patient-monitoring/doctors-progress/:sessionId", requireAuth, async (req, res) => {
    try {
      const entries = await db.select().from(doctorsProgressSheet)
        .where(eq(doctorsProgressSheet.sessionId, req.params.sessionId))
        .orderBy(desc(doctorsProgressSheet.entryDateTime));
      res.json(entries);
    } catch (error) {
      console.error("Error fetching doctor's progress entries:", error);
      res.status(500).json({ error: "Failed to fetch doctor's progress entries" });
    }
  });

  // Create new entry
  app.post("/api/patient-monitoring/doctors-progress", requireAuth, async (req, res) => {
    try {
      const body = req.body;
      // Convert types before validation
      const transformedData = {
        ...body,
        age: body.age != null ? String(body.age) : undefined,
        entryDateTime: body.entryDateTime ? new Date(body.entryDateTime) : new Date()
      };
      const result = await db.insert(doctorsProgressSheet).values({
        ...transformedData,
        createdBy: (req as any).session?.user?.id
      }).returning();
      res.json(result[0]);
    } catch (error) {
      console.error("Error creating doctor's progress entry:", error);
      res.status(500).json({ error: "Failed to create doctor's progress entry" });
    }
  });

  // Update entry
  app.patch("/api/patient-monitoring/doctors-progress/:id", requireAuth, async (req, res) => {
    try {
      const { id, createdAt, updatedAt, ...updateData } = req.body;
      const result = await db.update(doctorsProgressSheet)
        .set({ ...updateData, updatedAt: new Date() })
        .where(eq(doctorsProgressSheet.id, req.params.id))
        .returning();
      res.json(result[0]);
    } catch (error) {
      console.error("Error updating doctor's progress entry:", error);
      res.status(500).json({ error: "Failed to update doctor's progress entry" });
    }
  });

  // Delete entry
  app.delete("/api/patient-monitoring/doctors-progress/:id", requireAuth, async (req, res) => {
    try {
      await db.delete(doctorsProgressSheet).where(eq(doctorsProgressSheet.id, req.params.id));
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting doctor's progress entry:", error);
      res.status(500).json({ error: "Failed to delete doctor's progress entry" });
    }
  });

  // ========== DOCTOR'S VISIT SHEET ==========
  // Get all visit entries for a session
  app.get("/api/patient-monitoring/doctors-visit/:sessionId", requireAuth, async (req, res) => {
    try {
      const entries = await db.select().from(doctorsVisitSheet)
        .where(eq(doctorsVisitSheet.sessionId, req.params.sessionId))
        .orderBy(desc(doctorsVisitSheet.visitDate));
      res.json(entries);
    } catch (error) {
      console.error("Error fetching doctor's visit entries:", error);
      res.status(500).json({ error: "Failed to fetch doctor's visit entries" });
    }
  });

  // Create new visit entry
  app.post("/api/patient-monitoring/doctors-visit", requireAuth, async (req, res) => {
    try {
      const body = req.body;
      const transformedData = {
        ...body,
        age: body.age != null ? String(body.age) : undefined,
        visitDate: body.visitDate ? new Date(body.visitDate) : new Date()
      };
      const result = await db.insert(doctorsVisitSheet).values({
        ...transformedData,
        createdBy: (req as any).session?.user?.id
      }).returning();
      res.json(result[0]);
    } catch (error) {
      console.error("Error creating doctor's visit entry:", error);
      res.status(500).json({ error: "Failed to create doctor's visit entry" });
    }
  });

  // Update visit entry
  app.patch("/api/patient-monitoring/doctors-visit/:id", requireAuth, async (req, res) => {
    try {
      const { id, createdAt, updatedAt, ...updateData } = req.body;
      if (updateData.visitDate) {
        updateData.visitDate = new Date(updateData.visitDate);
      }
      const result = await db.update(doctorsVisitSheet)
        .set({ ...updateData, updatedAt: new Date() })
        .where(eq(doctorsVisitSheet.id, req.params.id))
        .returning();
      res.json(result[0]);
    } catch (error) {
      console.error("Error updating doctor's visit entry:", error);
      res.status(500).json({ error: "Failed to update doctor's visit entry" });
    }
  });

  // Delete visit entry
  app.delete("/api/patient-monitoring/doctors-visit/:id", requireAuth, async (req, res) => {
    try {
      await db.delete(doctorsVisitSheet).where(eq(doctorsVisitSheet.id, req.params.id));
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting doctor's visit entry:", error);
      res.status(500).json({ error: "Failed to delete doctor's visit entry" });
    }
  });

  // ========== SURGERY NOTES ==========
  // Get all surgery notes for a session
  app.get("/api/patient-monitoring/surgery-notes/:sessionId", requireAuth, async (req, res) => {
    try {
      const entries = await db.select().from(surgeryNotes)
        .where(eq(surgeryNotes.sessionId, req.params.sessionId))
        .orderBy(desc(surgeryNotes.surgeryDate));
      res.json(entries);
    } catch (error) {
      console.error("Error fetching surgery notes:", error);
      res.status(500).json({ error: "Failed to fetch surgery notes" });
    }
  });

  // Create new surgery note
  app.post("/api/patient-monitoring/surgery-notes", requireAuth, async (req, res) => {
    try {
      const body = req.body;
      const transformedData = {
        sessionId: body.sessionId,
        patientId: body.patientId,
        patientName: body.patientName,
        prnNo: body.prnNo,
        age: body.age != null ? String(body.age) : undefined,
        sex: body.sex,
        ipdNo: body.ipdNo,
        ward: body.ward,
        bedNo: body.bedNo,
        doctorName: body.doctorName,
        mrn: body.mrn,
        surgeryDate: body.surgeryDate ? new Date(body.surgeryDate) : new Date(),
        nameOfSurgeon: body.nameOfSurgeon,
        preoperativeDiagnosis: body.preoperativeDiagnosis,
        surgeryPlanned: body.surgeryPlanned,
        surgeryPerformed: body.surgeryPerformed,
        surgeonName: body.surgeonName,
        assistant1: body.assistant1,
        assistant2: body.assistant2,
        typeOfAnaesthesia: body.typeOfAnaesthesia,
        anaesthetist1: body.anaesthetist1,
        anaesthetist2: body.anaesthetist2,
        operationStartedAt: body.operationStartedAt,
        operationCompletedAt: body.operationCompletedAt,
        operationNotes: body.operationNotes,
        otherRelevantDetails: body.otherRelevantDetails,
        bloodLoss: body.bloodLoss,
        postopVitalsPulse: body.postopVitalsPulse,
        postopVitalsBp: body.postopVitalsBp,
        postopVitalsSpo2: body.postopVitalsSpo2,
        shiftPatientTo: body.shiftPatientTo,
        bloodTransfusion: body.bloodTransfusion,
        tissueSubjectForHpe: body.tissueSubjectForHpe,
        surgeonSign: body.surgeonSign,
        createdBy: (req as any).session?.user?.id
      };
      const result = await db.insert(surgeryNotes).values(transformedData).returning();
      res.json(result[0]);
    } catch (error) {
      console.error("Error creating surgery note:", error);
      res.status(500).json({ error: "Failed to create surgery note" });
    }
  });

  // Update surgery note
  app.patch("/api/patient-monitoring/surgery-notes/:id", requireAuth, async (req, res) => {
    try {
      const body = req.body;
      const updateData: Record<string, any> = {};
      const allowedFields = [
        'doctorName', 'mrn', 'surgeryDate', 'nameOfSurgeon', 'preoperativeDiagnosis',
        'surgeryPlanned', 'surgeryPerformed', 'surgeonName', 'assistant1', 'assistant2',
        'typeOfAnaesthesia', 'anaesthetist1', 'anaesthetist2', 'operationStartedAt',
        'operationCompletedAt', 'operationNotes', 'otherRelevantDetails', 'bloodLoss',
        'postopVitalsPulse', 'postopVitalsBp', 'postopVitalsSpo2', 'shiftPatientTo',
        'bloodTransfusion', 'tissueSubjectForHpe', 'surgeonSign'
      ];
      for (const field of allowedFields) {
        if (body[field] !== undefined) {
          updateData[field] = body[field];
        }
      }
      if (updateData.surgeryDate) {
        updateData.surgeryDate = new Date(updateData.surgeryDate);
      }
      updateData.updatedAt = new Date();
      const result = await db.update(surgeryNotes)
        .set(updateData)
        .where(eq(surgeryNotes.id, req.params.id))
        .returning();
      res.json(result[0]);
    } catch (error) {
      console.error("Error updating surgery note:", error);
      res.status(500).json({ error: "Failed to update surgery note" });
    }
  });

  // Delete surgery note
  app.delete("/api/patient-monitoring/surgery-notes/:id", requireAuth, async (req, res) => {
    try {
      await db.delete(surgeryNotes).where(eq(surgeryNotes.id, req.params.id));
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting surgery note:", error);
      res.status(500).json({ error: "Failed to delete surgery note" });
    }
  });

  // ========== NURSING PROGRESS SHEET ==========
  // Get all nursing progress entries for a session
  app.get("/api/patient-monitoring/nursing-progress/:sessionId", requireAuth, async (req, res) => {
    try {
      const entries = await db.select().from(nursingProgressSheet)
        .where(eq(nursingProgressSheet.sessionId, req.params.sessionId))
        .orderBy(desc(nursingProgressSheet.entryDateTime));
      res.json(entries);
    } catch (error) {
      console.error("Error fetching nursing progress entries:", error);
      res.status(500).json({ error: "Failed to fetch nursing progress entries" });
    }
  });

  // Create new nursing progress entry
  app.post("/api/patient-monitoring/nursing-progress", requireAuth, async (req, res) => {
    try {
      const body = req.body;
      const transformedData = {
        sessionId: body.sessionId,
        patientId: body.patientId,
        patientName: body.patientName,
        prnNo: body.prnNo,
        age: body.age != null ? String(body.age) : undefined,
        sex: body.sex,
        ipdNo: body.ipdNo,
        ward: body.ward,
        bedNo: body.bedNo,
        allergicTo: body.allergicTo,
        entryDateTime: body.entryDateTime ? new Date(body.entryDateTime) : new Date(),
        progressNotes: body.progressNotes,
        signatureName: body.signatureName,
        createdBy: (req as any).session?.user?.id
      };
      const result = await db.insert(nursingProgressSheet).values(transformedData).returning();
      res.json(result[0]);
    } catch (error) {
      console.error("Error creating nursing progress entry:", error);
      res.status(500).json({ error: "Failed to create nursing progress entry" });
    }
  });

  // Update nursing progress entry
  app.patch("/api/patient-monitoring/nursing-progress/:id", requireAuth, async (req, res) => {
    try {
      const body = req.body;
      const updateData: Record<string, any> = {};
      const allowedFields = ['allergicTo', 'entryDateTime', 'progressNotes', 'signatureName'];
      for (const field of allowedFields) {
        if (body[field] !== undefined) {
          updateData[field] = body[field];
        }
      }
      if (updateData.entryDateTime) {
        updateData.entryDateTime = new Date(updateData.entryDateTime);
      }
      updateData.updatedAt = new Date();
      const result = await db.update(nursingProgressSheet)
        .set(updateData)
        .where(eq(nursingProgressSheet.id, req.params.id))
        .returning();
      res.json(result[0]);
    } catch (error) {
      console.error("Error updating nursing progress entry:", error);
      res.status(500).json({ error: "Failed to update nursing progress entry" });
    }
  });

  // Delete nursing progress entry
  app.delete("/api/patient-monitoring/nursing-progress/:id", requireAuth, async (req, res) => {
    try {
      await db.delete(nursingProgressSheet).where(eq(nursingProgressSheet.id, req.params.id));
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting nursing progress entry:", error);
      res.status(500).json({ error: "Failed to delete nursing progress entry" });
    }
  });

  // ========== NURSING ASSESSMENT & CARE PLAN ==========
  // Get nursing assessment & care plan for a session
  app.get("/api/patient-monitoring/nursing-assessment/:sessionId", requireAuth, async (req, res) => {
    try {
      const entries = await db.select().from(nursingAssessmentCarePlan)
        .where(eq(nursingAssessmentCarePlan.sessionId, req.params.sessionId))
        .orderBy(desc(nursingAssessmentCarePlan.createdAt));
      res.json(entries);
    } catch (error) {
      console.error("Error fetching nursing assessment:", error);
      res.status(500).json({ error: "Failed to fetch nursing assessment" });
    }
  });

  // Create nursing assessment & care plan
  app.post("/api/patient-monitoring/nursing-assessment", requireAuth, async (req, res) => {
    try {
      const body = req.body;
      const transformedData: Record<string, any> = {
        sessionId: body.sessionId,
        patientId: body.patientId,
        patientReceivedDate: body.patientReceivedDate ? new Date(body.patientReceivedDate) : null,
        patientReceivedTime: body.patientReceivedTime,
        provisionalDiagnosis: body.provisionalDiagnosis,
        generalConsentSigned: body.generalConsentSigned,
        modeOfAccess: body.modeOfAccess,
        patientAccompanied: body.patientAccompanied,
        accompaniedName: body.accompaniedName,
        vulnerable: body.vulnerable,
        relation: body.relation,
        contactNo: body.contactNo,
        allergies: body.allergies,
        temperature: body.temperature,
        pulse: body.pulse,
        breathsPerMin: body.breathsPerMin,
        bp: body.bp,
        respiratoryRate: body.respiratoryRate,
        height: body.height,
        weight: body.weight,
        patientHistory: body.patientHistory,
        functionalStatus: body.functionalStatus,
        patientEnvironment: body.patientEnvironment,
        currentMedications: body.currentMedications,
        medicinesBroughtToHospital: body.medicinesBroughtToHospital,
        medicinesDisposition: body.medicinesDisposition,
        morseFallRiskScore: body.morseFallRiskScore,
        historyOfFall: body.historyOfFall,
        secondaryDiagnosis: body.secondaryDiagnosis,
        ambulatoryAid: body.ambulatoryAid,
        peripheryCentralLine: body.peripheryCentralLine,
        gait: body.gait,
        mentalStatus: body.mentalStatus,
        bradenScaleTotal: body.bradenScaleTotal,
        sensoryPerception: body.sensoryPerception,
        degreeOfActivity: body.degreeOfActivity,
        nutrition: body.nutrition,
        moisture: body.moisture,
        mobility: body.mobility,
        shearFriction: body.shearFriction,
        neurologicalReview: body.neurologicalReview,
        cardiovascularReview: body.cardiovascularReview,
        urinaryReview: body.urinaryReview,
        respiratoryReview: body.respiratoryReview,
        gastroIntestinalReview: body.gastroIntestinalReview,
        skinReview: body.skinReview,
        vision: body.vision,
        hearing: body.hearing,
        languages: body.languages,
        speech: body.speech,
        obey: body.obey,
        woundsUlcerBedSore: body.woundsUlcerBedSore,
        woundsLocation: body.woundsLocation,
        woundsStage: body.woundsStage,
        painScore: body.painScore,
        patientDevices: body.patientDevices,
        nutritionalAssessment: body.nutritionalAssessment,
        nutritionalScore: body.nutritionalScore,
        personalHygiene: body.personalHygiene,
        dressingChange: body.dressingChange,
        ivFluide: body.ivFluide,
        injection: body.injection,
        medicine: body.medicine,
        investigation: body.investigation,
        bloodGroup: body.bloodGroup,
        previousBTReceived: body.previousBTReceived,
        btStartTime: body.btStartTime,
        btFinishTime: body.btFinishTime,
        btName: body.btName,
        btStaffNurse: body.btStaffNurse,
        btRmoName: body.btRmoName,
        nursingCareShifts: body.nursingCareShifts,
        nursingObservations: body.nursingObservations,
        nursingIntervention: body.nursingIntervention,
        specificNeedsRemarks: body.specificNeedsRemarks,
        admittingStaffNurse: body.admittingStaffNurse,
        empId: body.empId,
        assessmentCompletingDate: body.assessmentCompletingDate ? new Date(body.assessmentCompletingDate) : null,
        assessmentCompletingTime: body.assessmentCompletingTime,
        signature: body.signature,
        createdBy: (req as any).user?.username || 'system',
      };
      const result = await db.insert(nursingAssessmentCarePlan).values(transformedData).returning();
      res.json(result[0]);
    } catch (error) {
      console.error("Error creating nursing assessment:", error);
      res.status(500).json({ error: "Failed to create nursing assessment" });
    }
  });

  // Update nursing assessment & care plan
  app.patch("/api/patient-monitoring/nursing-assessment/:id", requireAuth, async (req, res) => {
    try {
      const body = req.body;
      const updateData: Record<string, any> = {};
      const allowedFields = [
        'provisionalDiagnosis', 'generalConsentSigned', 'modeOfAccess', 'patientAccompanied',
        'accompaniedName', 'vulnerable', 'relation', 'contactNo', 'allergies', 'temperature',
        'pulse', 'breathsPerMin', 'bp', 'respiratoryRate', 'height', 'weight', 'patientHistory',
        'functionalStatus', 'patientEnvironment', 'currentMedications', 'medicinesBroughtToHospital',
        'medicinesDisposition', 'morseFallRiskScore', 'historyOfFall', 'secondaryDiagnosis',
        'ambulatoryAid', 'peripheryCentralLine', 'gait', 'mentalStatus', 'bradenScaleTotal',
        'sensoryPerception', 'degreeOfActivity', 'nutrition', 'moisture', 'mobility', 'shearFriction',
        'neurologicalReview', 'cardiovascularReview', 'urinaryReview', 'respiratoryReview',
        'gastroIntestinalReview', 'skinReview', 'vision', 'hearing', 'languages', 'speech', 'obey',
        'woundsUlcerBedSore', 'woundsLocation', 'woundsStage', 'painScore', 'patientDevices',
        'nutritionalAssessment', 'nutritionalScore', 'personalHygiene', 'dressingChange', 'ivFluide',
        'injection', 'medicine', 'investigation', 'bloodGroup', 'previousBTReceived', 'btStartTime',
        'btFinishTime', 'btName', 'btStaffNurse', 'btRmoName', 'nursingCareShifts', 'nursingObservations',
        'nursingIntervention', 'specificNeedsRemarks', 'admittingStaffNurse', 'empId', 'signature'
      ];
      for (const field of allowedFields) {
        if (body[field] !== undefined) {
          updateData[field] = body[field];
        }
      }
      updateData.updatedAt = new Date();
      const result = await db.update(nursingAssessmentCarePlan)
        .set(updateData)
        .where(eq(nursingAssessmentCarePlan.id, req.params.id))
        .returning();
      res.json(result[0]);
    } catch (error) {
      console.error("Error updating nursing assessment:", error);
      res.status(500).json({ error: "Failed to update nursing assessment" });
    }
  });

  // Delete nursing assessment & care plan
  app.delete("/api/patient-monitoring/nursing-assessment/:id", requireAuth, async (req, res) => {
    try {
      await db.delete(nursingAssessmentCarePlan).where(eq(nursingAssessmentCarePlan.id, req.params.id));
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting nursing assessment:", error);
      res.status(500).json({ error: "Failed to delete nursing assessment" });
    }
  });

  // ========== BED MANAGEMENT MODULE ==========
  // NABH-Compliant Hospital Bed Management System (ADMIN ONLY)

  // Bed Categories CRUD
  app.get("/api/bed-management/categories", async (req, res) => {
    try {
      const categories = await db.select().from(bedCategories).orderBy(bedCategories.name);
      res.json(categories);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch bed categories" });
    }
  });

  app.get("/api/bed-management/categories/:id", async (req, res) => {
    try {
      const category = await db.select().from(bedCategories)
        .where(eq(bedCategories.id, req.params.id));
      if (!category.length) {
        return res.status(404).json({ error: "Category not found" });
      }
      res.json(category[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch category" });
    }
  });

  app.post("/api/bed-management/categories", async (req, res) => {
    try {
      const parsed = insertBedCategorySchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid category data", details: parsed.error });
      }
      const result = await db.insert(bedCategories).values(parsed.data).returning();
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to create bed category" });
    }
  });

  app.patch("/api/bed-management/categories/:id", async (req, res) => {
    try {
      const result = await db.update(bedCategories)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(bedCategories.id, req.params.id))
        .returning();
      res.json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to update category" });
    }
  });

  app.delete("/api/bed-management/categories/:id", async (req, res) => {
    try {
      await db.delete(bedCategories).where(eq(bedCategories.id, req.params.id));
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete category" });
    }
  });

  // Beds CRUD
  app.get("/api/bed-management/beds", async (req, res) => {
    try {
      const allBeds = await db.select().from(beds).orderBy(beds.wardName, beds.bedNumber);
      res.json(allBeds);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch beds" });
    }
  });

  // Available beds route - must be before :id route to avoid "available" being matched as ID
  app.get("/api/bed-management/beds/available", async (req, res) => {
    try {
      const availableBeds = await db.select().from(beds)
        .where(and(eq(beds.occupancyStatus, "AVAILABLE"), eq(beds.isActive, true)))
        .orderBy(beds.wardName, beds.bedNumber);
      res.json(availableBeds);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch available beds" });
    }
  });

  app.get("/api/bed-management/beds/ward/:wardName", async (req, res) => {
    try {
      const wardBeds = await db.select().from(beds)
        .where(eq(beds.wardName, req.params.wardName))
        .orderBy(beds.bedNumber);
      res.json(wardBeds);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch ward beds" });
    }
  });

  // Get available beds by ward (excludes occupied beds) - for real-time dropdown
  app.get("/api/bed-management/beds/ward/:wardName/available", async (req, res) => {
    try {
      // Fetch all beds for the ward first, then filter for available (case-insensitive)
      const allWardBeds = await db.select().from(beds)
        .where(and(
          eq(beds.wardName, req.params.wardName),
          eq(beds.isActive, true)
        ))
        .orderBy(beds.bedNumber);
      
      // Filter for available beds (case-insensitive check)
      const availableWardBeds = allWardBeds.filter(bed => 
        bed.occupancyStatus?.toLowerCase() === "available"
      );
      
      res.json(availableWardBeds);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch available ward beds" });
    }
  });

  app.get("/api/bed-management/beds/:id", async (req, res) => {
    try {
      const bed = await db.select().from(beds)
        .where(eq(beds.id, req.params.id));
      if (!bed.length) {
        return res.status(404).json({ error: "Bed not found" });
      }
      res.json(bed[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch bed" });
    }
  });

  app.post("/api/bed-management/beds", async (req, res) => {
    try {
      const parsed = insertBedSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid bed data", details: parsed.error });
      }
      const result = await db.insert(beds).values(parsed.data).returning();
      
      // Log bed creation
      await db.insert(bedAuditLog).values({
        bedId: result[0].id,
        bedNumber: result[0].bedNumber,
        action: "CREATE",
        newStatus: result[0].occupancyStatus || "AVAILABLE",
        userId: req.body.createdBy || "system",
        userName: req.body.createdByName || "System",
        userRole: req.body.userRole || "ADMIN",
        details: JSON.stringify({ message: "Bed created" })
      });
      
      res.status(201).json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to create bed" });
    }
  });

  app.patch("/api/bed-management/beds/:id", async (req, res) => {
    try {
      // Get current bed state for audit
      const currentBed = await db.select().from(beds).where(eq(beds.id, req.params.id));
      const previousStatus = currentBed[0]?.occupancyStatus;
      
      const result = await db.update(beds)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(beds.id, req.params.id))
        .returning();
      
      // Log status change if status changed
      if (req.body.occupancyStatus && req.body.occupancyStatus !== previousStatus) {
        await db.insert(bedAuditLog).values({
          bedId: result[0].id,
          bedNumber: result[0].bedNumber,
          action: "STATUS_CHANGE",
          previousStatus: previousStatus,
          newStatus: req.body.occupancyStatus,
          patientId: result[0].currentPatientId,
          userId: req.body.updatedBy || "system",
          userName: req.body.updatedByName || "System",
          userRole: req.body.userRole || "ADMIN",
          details: JSON.stringify({ reason: req.body.statusChangeReason || "Manual update" })
        });
      }
      
      res.json(result[0]);
    } catch (error) {
      res.status(500).json({ error: "Failed to update bed" });
    }
  });

  app.delete("/api/bed-management/beds/:id", async (req, res) => {
    try {
      // Get bed info for audit
      const bed = await db.select().from(beds).where(eq(beds.id, req.params.id));
      if (bed[0]) {
        await db.insert(bedAuditLog).values({
          bedId: bed[0].id,
          bedNumber: bed[0].bedNumber,
          action: "DELETE",
          previousStatus: bed[0].occupancyStatus,
          userId: req.body.deletedBy || "system",
          userName: req.body.deletedByName || "System",
          userRole: req.body.userRole || "ADMIN",
          details: JSON.stringify({ message: "Bed deleted" })
        });
      }
      await db.delete(beds).where(eq(beds.id, req.params.id));
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to delete bed" });
    }
  });

  // Bed Allocation
  app.post("/api/bed-management/allocate", async (req, res) => {
    try {
      const { bedId, patientId, patientName, admissionId, categoryId, categoryName, allocatedBy, allocatedByName, isDayCare, expectedDuration } = req.body;
      
      // Get bed info
      const bed = await db.select().from(beds).where(eq(beds.id, bedId));
      if (!bed.length) {
        return res.status(404).json({ error: "Bed not found" });
      }
      if (bed[0].occupancyStatus !== "AVAILABLE") {
        return res.status(400).json({ error: "Bed is not available for allocation" });
      }
      
      // Update bed status
      await db.update(beds).set({
        occupancyStatus: "OCCUPIED",
        currentPatientId: patientId,
        currentAdmissionId: admissionId,
        bedStartDatetime: new Date(),
        lastOccupiedAt: new Date(),
        updatedAt: new Date()
      }).where(eq(beds.id, bedId));
      
      // Create allocation record
      const allocation = await db.insert(bedAllocations).values({
        patientId,
        patientName,
        admissionId,
        bedId,
        bedNumber: bed[0].bedNumber,
        categoryId,
        categoryName,
        wardName: bed[0].wardName,
        allocationDatetime: new Date(),
        isDayCare: isDayCare || false,
        expectedDuration: expectedDuration || null,
        allocatedBy,
        allocatedByName
      }).returning();
      
      // Log allocation
      await db.insert(bedAuditLog).values({
        bedId,
        bedNumber: bed[0].bedNumber,
        action: "ALLOCATE",
        previousStatus: "AVAILABLE",
        newStatus: "OCCUPIED",
        patientId,
        patientName,
        admissionId,
        userId: allocatedBy,
        userName: allocatedByName,
        userRole: "ADMIN",
        details: JSON.stringify({ allocationId: allocation[0].id })
      });
      
      res.status(201).json(allocation[0]);
    } catch (error) {
      console.error("Allocation error:", error);
      res.status(500).json({ error: "Failed to allocate bed" });
    }
  });

  // Bed Release
  app.post("/api/bed-management/release", async (req, res) => {
    try {
      const { bedId, releaseReason, releasedBy, releasedByName } = req.body;
      
      // Get bed info
      const bed = await db.select().from(beds).where(eq(beds.id, bedId));
      if (!bed.length) {
        return res.status(404).json({ error: "Bed not found" });
      }
      
      // Update active allocation
      const activeAllocation = await db.select().from(bedAllocations)
        .where(and(eq(bedAllocations.bedId, bedId), eq(bedAllocations.releaseDatetime, null as any)));
      
      if (activeAllocation.length) {
        await db.update(bedAllocations).set({
          releaseDatetime: new Date(),
          releaseReason,
          releasedBy,
          releasedByName,
          updatedAt: new Date()
        }).where(eq(bedAllocations.id, activeAllocation[0].id));
      }
      
      // Update bed status to CLEANING
      await db.update(beds).set({
        occupancyStatus: "CLEANING",
        currentPatientId: null,
        currentAdmissionId: null,
        bedStartDatetime: null,
        updatedAt: new Date()
      }).where(eq(beds.id, bedId));
      
      // Log release
      await db.insert(bedAuditLog).values({
        bedId,
        bedNumber: bed[0].bedNumber,
        action: "RELEASE",
        previousStatus: "OCCUPIED",
        newStatus: "CLEANING",
        patientId: bed[0].currentPatientId,
        userId: releasedBy,
        userName: releasedByName,
        userRole: "ADMIN",
        details: JSON.stringify({ releaseReason })
      });
      
      res.json({ success: true, message: "Bed released and marked for cleaning" });
    } catch (error) {
      console.error("Release error:", error);
      res.status(500).json({ error: "Failed to release bed" });
    }
  });

  // Mark bed as cleaned/available
  app.post("/api/bed-management/mark-cleaned", async (req, res) => {
    try {
      const { bedId, cleanedBy, cleanedByName } = req.body;
      
      const bed = await db.select().from(beds).where(eq(beds.id, bedId));
      if (!bed.length) {
        return res.status(404).json({ error: "Bed not found" });
      }
      
      await db.update(beds).set({
        occupancyStatus: "AVAILABLE",
        lastCleanedAt: new Date(),
        updatedAt: new Date()
      }).where(eq(beds.id, bedId));
      
      await db.insert(bedAuditLog).values({
        bedId,
        bedNumber: bed[0].bedNumber,
        action: "CLEANING_COMPLETE",
        previousStatus: "CLEANING",
        newStatus: "AVAILABLE",
        userId: cleanedBy,
        userName: cleanedByName,
        userRole: "ADMIN",
        details: JSON.stringify({ message: "Bed cleaned and available" })
      });
      
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to mark bed as cleaned" });
    }
  });

  // Bed Transfers
  app.get("/api/bed-management/transfers", async (req, res) => {
    try {
      const transfers = await db.select().from(bedTransfers)
        .orderBy(desc(bedTransfers.transferDatetime));
      res.json(transfers);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch transfers" });
    }
  });

  app.get("/api/bed-management/transfers/patient/:patientId", async (req, res) => {
    try {
      const transfers = await db.select().from(bedTransfers)
        .where(eq(bedTransfers.patientId, req.params.patientId))
        .orderBy(bedTransfers.transferSequenceNumber);
      res.json(transfers);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch patient transfers" });
    }
  });

  app.post("/api/bed-management/transfers", async (req, res) => {
    try {
      const parsed = insertBedTransferSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid transfer data", details: parsed.error });
      }
      
      // Validate from bed is occupied by patient
      const fromBed = await db.select().from(beds).where(eq(beds.id, parsed.data.fromBedId));
      if (!fromBed.length || fromBed[0].currentPatientId !== parsed.data.patientId) {
        return res.status(400).json({ error: "Patient is not in the source bed" });
      }
      
      // Validate to bed is available
      const toBed = await db.select().from(beds).where(eq(beds.id, parsed.data.toBedId));
      if (!toBed.length || toBed[0].occupancyStatus !== "AVAILABLE") {
        return res.status(400).json({ error: "Destination bed is not available" });
      }
      
      // Release from bed
      await db.update(beds).set({
        occupancyStatus: "CLEANING",
        currentPatientId: null,
        currentAdmissionId: null,
        bedStartDatetime: null,
        updatedAt: new Date()
      }).where(eq(beds.id, parsed.data.fromBedId));
      
      // Allocate to bed
      await db.update(beds).set({
        occupancyStatus: "OCCUPIED",
        currentPatientId: parsed.data.patientId,
        currentAdmissionId: parsed.data.admissionId,
        bedStartDatetime: new Date(),
        lastOccupiedAt: new Date(),
        updatedAt: new Date()
      }).where(eq(beds.id, parsed.data.toBedId));
      
      // Create transfer record
      const result = await db.insert(bedTransfers).values(parsed.data).returning();
      
      // Log transfer
      await db.insert(bedAuditLog).values({
        bedId: parsed.data.fromBedId,
        bedNumber: parsed.data.fromBedNumber,
        action: "TRANSFER",
        previousStatus: "OCCUPIED",
        newStatus: "CLEANING",
        patientId: parsed.data.patientId,
        patientName: parsed.data.patientName,
        admissionId: parsed.data.admissionId,
        userId: parsed.data.createdBy,
        userName: parsed.data.createdByName || "System",
        userRole: "ADMIN",
        details: JSON.stringify({ 
          transferId: result[0].id,
          toBedId: parsed.data.toBedId,
          toBedNumber: parsed.data.toBedNumber,
          reason: parsed.data.transferReason
        })
      });
      
      res.status(201).json(result[0]);
    } catch (error) {
      console.error("Transfer error:", error);
      res.status(500).json({ error: "Failed to create transfer" });
    }
  });

  // Bed Allocations History
  app.get("/api/bed-management/allocations", async (req, res) => {
    try {
      const allocations = await db.select().from(bedAllocations)
        .orderBy(desc(bedAllocations.allocationDatetime));
      res.json(allocations);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch allocations" });
    }
  });

  app.get("/api/bed-management/allocations/bed/:bedId", async (req, res) => {
    try {
      const allocations = await db.select().from(bedAllocations)
        .where(eq(bedAllocations.bedId, req.params.bedId))
        .orderBy(desc(bedAllocations.allocationDatetime));
      res.json(allocations);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch bed allocations" });
    }
  });

  // Bed Audit Log (Read-only, no deletion allowed for NABH compliance)
  app.get("/api/bed-management/audit-log", async (req, res) => {
    try {
      const logs = await db.select().from(bedAuditLog)
        .orderBy(desc(bedAuditLog.timestamp))
        .limit(500);
      res.json(logs);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch audit log" });
    }
  });

  app.get("/api/bed-management/audit-log/bed/:bedId", async (req, res) => {
    try {
      const logs = await db.select().from(bedAuditLog)
        .where(eq(bedAuditLog.bedId, req.params.bedId))
        .orderBy(desc(bedAuditLog.timestamp));
      res.json(logs);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch bed audit log" });
    }
  });

  // Bed Statistics/Analytics
  app.get("/api/bed-management/stats", async (req, res) => {
    try {
      const allBeds = await db.select().from(beds).where(eq(beds.isActive, true));
      const categories = await db.select().from(bedCategories).where(eq(bedCategories.isActive, true));
      
      const stats = {
        totalBeds: allBeds.length,
        availableBeds: allBeds.filter(b => b.occupancyStatus === "AVAILABLE").length,
        occupiedBeds: allBeds.filter(b => b.occupancyStatus === "OCCUPIED").length,
        cleaningBeds: allBeds.filter(b => b.occupancyStatus === "CLEANING").length,
        blockedBeds: allBeds.filter(b => b.occupancyStatus === "BLOCKED").length,
        maintenanceBeds: allBeds.filter(b => b.occupancyStatus === "MAINTENANCE").length,
        occupancyRate: allBeds.length > 0 
          ? Math.round((allBeds.filter(b => b.occupancyStatus === "OCCUPIED").length / allBeds.length) * 100) 
          : 0,
        isolationBeds: allBeds.filter(b => b.isIsolationBed).length,
        icuBeds: allBeds.filter(b => b.department === "ICU").length,
        ventilatorCapable: allBeds.filter(b => b.hasVentilatorCapability).length,
        oxygenCapable: allBeds.filter(b => b.hasOxygenCapability).length,
        totalCategories: categories.length,
        byWard: {} as Record<string, { total: number; occupied: number; available: number }>,
        byDepartment: {} as Record<string, { total: number; occupied: number; available: number }>
      };
      
      // Group by ward
      allBeds.forEach(bed => {
        if (!stats.byWard[bed.wardName]) {
          stats.byWard[bed.wardName] = { total: 0, occupied: 0, available: 0 };
        }
        stats.byWard[bed.wardName].total++;
        if (bed.occupancyStatus === "OCCUPIED") stats.byWard[bed.wardName].occupied++;
        if (bed.occupancyStatus === "AVAILABLE") stats.byWard[bed.wardName].available++;
      });
      
      // Group by department
      allBeds.forEach(bed => {
        if (!stats.byDepartment[bed.department]) {
          stats.byDepartment[bed.department] = { total: 0, occupied: 0, available: 0 };
        }
        stats.byDepartment[bed.department].total++;
        if (bed.occupancyStatus === "OCCUPIED") stats.byDepartment[bed.department].occupied++;
        if (bed.occupancyStatus === "AVAILABLE") stats.byDepartment[bed.department].available++;
      });
      
      res.json(stats);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch bed statistics" });
    }
  });

  // ========== BLOOD BANK MODULE ROUTES ==========

  // Blood Bank authentication middleware - ADMIN only
  const bloodBankAuthMiddleware = async (req: any, res: any, next: any) => {
    if (!req.session?.user) {
      return res.status(401).json({ error: "Authentication required" });
    }
    if (req.session.user.role !== "ADMIN") {
      return res.status(403).json({ error: "Blood Bank access restricted to administrators only" });
    }
    next();
  };

  // Blood Service Groups
  app.get("/api/blood-bank/service-groups", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const groups = await db.select().from(bloodServiceGroups).orderBy(bloodServiceGroups.displayOrder);
      res.json(groups);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch service groups" });
    }
  });

  // Blood Services
  app.get("/api/blood-bank/services", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const services = await db.select().from(bloodServices).orderBy(bloodServices.displayOrder);
      res.json(services);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch blood services" });
    }
  });

  // Blood Units
  app.get("/api/blood-bank/units", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const units = await db.select().from(bloodUnits).orderBy(desc(bloodUnits.createdAt));
      res.json(units);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch blood units" });
    }
  });

  app.post("/api/blood-bank/units", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const data = insertBloodUnitSchema.parse(req.body);
      const [unit] = await db.insert(bloodUnits).values(data).returning();
      
      // Create audit log
      await db.insert(bloodBankAuditLog).values({
        entityType: "BLOOD_UNIT",
        entityId: unit.id,
        action: "CREATE",
        newValue: JSON.stringify(data),
        userId: req.body.createdBy || "system",
        userName: req.body.createdByName || "System",
        userRole: "ADMIN",
        details: `Blood unit ${unit.unitId} created`
      });
      
      res.json(unit);
    } catch (error) {
      res.status(500).json({ error: "Failed to create blood unit" });
    }
  });

  app.patch("/api/blood-bank/units/:id", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const [existing] = await db.select().from(bloodUnits).where(eq(bloodUnits.id, req.params.id));
      if (!existing) {
        return res.status(404).json({ error: "Blood unit not found" });
      }
      
      const [updated] = await db.update(bloodUnits)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(bloodUnits.id, req.params.id))
        .returning();
      
      // Create audit log for status changes
      if (req.body.status && req.body.status !== existing.status) {
        await db.insert(bloodBankAuditLog).values({
          entityType: "BLOOD_UNIT",
          entityId: updated.id,
          action: "STATUS_CHANGE",
          previousValue: JSON.stringify({ status: existing.status }),
          newValue: JSON.stringify({ status: updated.status }),
          userId: req.body.updatedBy || "system",
          userName: req.body.updatedByName || "System",
          userRole: "ADMIN",
          details: `Blood unit ${updated.unitId} status changed from ${existing.status} to ${updated.status}`
        });
      }
      
      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to update blood unit" });
    }
  });

  // Blood Donors
  app.get("/api/blood-bank/donors", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const donorList = await db.select().from(bloodDonors).orderBy(desc(bloodDonors.createdAt));
      res.json(donorList);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch donors" });
    }
  });

  app.post("/api/blood-bank/donors", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const data = insertBloodDonorSchema.parse(req.body);
      const [donor] = await db.insert(bloodDonors).values(data).returning();
      
      // Create audit log
      await db.insert(bloodBankAuditLog).values({
        entityType: "DONOR",
        entityId: donor.id,
        action: "CREATE",
        newValue: JSON.stringify({ donorId: donor.donorId, name: donor.name, bloodGroup: donor.bloodGroup }),
        userId: req.body.registeredBy || "system",
        userName: req.body.registeredByName || "System",
        userRole: "ADMIN",
        details: `Donor ${donor.donorId} registered`
      });
      
      res.json(donor);
    } catch (error) {
      res.status(500).json({ error: "Failed to register donor" });
    }
  });

  app.patch("/api/blood-bank/donors/:id", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const [existing] = await db.select().from(bloodDonors).where(eq(bloodDonors.id, req.params.id));
      if (!existing) {
        return res.status(404).json({ error: "Donor not found" });
      }
      
      const [updated] = await db.update(bloodDonors)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(bloodDonors.id, req.params.id))
        .returning();
      
      // Audit log for donor updates
      await db.insert(bloodBankAuditLog).values({
        entityType: "DONOR",
        entityId: updated.id,
        action: "UPDATE",
        previousValue: JSON.stringify({ eligibilityStatus: existing.eligibilityStatus }),
        newValue: JSON.stringify({ eligibilityStatus: updated.eligibilityStatus }),
        userId: (req as any).session?.user?.id || "system",
        userName: (req as any).session?.user?.fullName || "System",
        userRole: "ADMIN",
        details: `Donor ${updated.donorId} updated`
      });
      
      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to update donor" });
    }
  });

  // Blood Storage Facilities
  app.get("/api/blood-bank/storage", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const facilities = await db.select().from(bloodStorageFacilities).orderBy(bloodStorageFacilities.name);
      res.json(facilities);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch storage facilities" });
    }
  });

  app.post("/api/blood-bank/storage", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const data = insertBloodStorageFacilitySchema.parse(req.body);
      const [facility] = await db.insert(bloodStorageFacilities).values(data).returning();
      res.json(facility);
    } catch (error) {
      res.status(500).json({ error: "Failed to create storage facility" });
    }
  });

  // Temperature Logs
  app.post("/api/blood-bank/storage/:facilityId/temperature", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const data = insertBloodTemperatureLogSchema.parse({
        ...req.body,
        facilityId: req.params.facilityId
      });
      const [log] = await db.insert(bloodTemperatureLogs).values(data).returning();
      
      // Update facility current temperature and check for breach
      const [facility] = await db.select().from(bloodStorageFacilities)
        .where(eq(bloodStorageFacilities.id, req.params.facilityId));
      
      if (facility) {
        const temp = parseFloat(req.body.temperature);
        const minTemp = parseFloat(facility.minTemperature?.toString() || "0");
        const maxTemp = parseFloat(facility.maxTemperature?.toString() || "0");
        const isBreach = temp < minTemp || temp > maxTemp;
        
        await db.update(bloodStorageFacilities)
          .set({
            currentTemperature: req.body.temperature,
            lastTemperatureReading: new Date(),
            hasTemperatureBreach: isBreach,
            updatedAt: new Date()
          })
          .where(eq(bloodStorageFacilities.id, req.params.facilityId));
        
        // Audit log for all temperature readings
        await db.insert(bloodBankAuditLog).values({
          entityType: "STORAGE",
          entityId: facility.id,
          action: isBreach ? "TEMP_BREACH" : "TEMP_LOG",
          newValue: JSON.stringify({ temperature: temp, facilityId: facility.id }),
          details: isBreach 
            ? `Temperature breach detected: ${temp}Â°C (allowed: ${minTemp}-${maxTemp}Â°C)` 
            : `Temperature logged: ${temp}Â°C for ${facility.name}`,
          userId: (req as any).session?.user?.id || "system",
          userName: (req as any).session?.user?.fullName || "System",
          userRole: "ADMIN"
        });
      }
      
      res.json(log);
    } catch (error) {
      res.status(500).json({ error: "Failed to log temperature" });
    }
  });

  // Transfusion Orders
  app.get("/api/blood-bank/orders", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const orders = await db.select().from(bloodTransfusionOrders).orderBy(desc(bloodTransfusionOrders.createdAt));
      res.json(orders);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch transfusion orders" });
    }
  });

  app.post("/api/blood-bank/orders", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const data = insertBloodTransfusionOrderSchema.parse(req.body);
      const [order] = await db.insert(bloodTransfusionOrders).values(data).returning();
      
      await db.insert(bloodBankAuditLog).values({
        entityType: "TRANSFUSION_ORDER",
        entityId: order.id,
        action: "CREATE",
        newValue: JSON.stringify({ orderId: order.orderId, patientName: order.patientName, urgency: order.urgency }),
        userId: req.body.createdBy || "system",
        userName: req.body.createdByName || "System",
        userRole: "ADMIN",
        details: `Transfusion order ${order.orderId} created for ${order.patientName}`
      });
      
      res.json(order);
    } catch (error) {
      res.status(500).json({ error: "Failed to create transfusion order" });
    }
  });

  app.patch("/api/blood-bank/orders/:id", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const [existing] = await db.select().from(bloodTransfusionOrders).where(eq(bloodTransfusionOrders.id, req.params.id));
      if (!existing) {
        return res.status(404).json({ error: "Transfusion order not found" });
      }
      
      const [updated] = await db.update(bloodTransfusionOrders)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(bloodTransfusionOrders.id, req.params.id))
        .returning();
      
      // Audit log for order status changes
      if (req.body.status && req.body.status !== existing.status) {
        await db.insert(bloodBankAuditLog).values({
          entityType: "TRANSFUSION_ORDER",
          entityId: updated.id,
          action: "STATUS_CHANGE",
          previousValue: JSON.stringify({ status: existing.status }),
          newValue: JSON.stringify({ status: updated.status }),
          userId: (req as any).session?.user?.id || "system",
          userName: (req as any).session?.user?.fullName || "System",
          userRole: "ADMIN",
          details: `Transfusion order ${updated.orderId} status changed from ${existing.status} to ${updated.status}`
        });
      }
      
      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to update transfusion order" });
    }
  });

  // Transfusion Reactions
  app.get("/api/blood-bank/reactions", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const reactions = await db.select().from(bloodTransfusionReactions).orderBy(desc(bloodTransfusionReactions.createdAt));
      res.json(reactions);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch transfusion reactions" });
    }
  });

  app.post("/api/blood-bank/reactions", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const data = insertBloodTransfusionReactionSchema.parse(req.body);
      const [reaction] = await db.insert(bloodTransfusionReactions).values(data).returning();
      
      await db.insert(bloodBankAuditLog).values({
        entityType: "TRANSFUSION_ORDER",
        entityId: reaction.bloodUnitId,
        action: "REACTION",
        details: `Transfusion reaction reported: ${reaction.reactionType} - ${reaction.severity}`,
        userId: reaction.reportedBy,
        userName: reaction.reportedByName,
        userRole: "ADMIN"
      });
      
      res.json(reaction);
    } catch (error) {
      res.status(500).json({ error: "Failed to report transfusion reaction" });
    }
  });

  // Blood Bank Audit Log (Read-only)
  app.get("/api/blood-bank/audit-log", bloodBankAuthMiddleware, async (req, res) => {
    try {
      const logs = await db.select().from(bloodBankAuditLog)
        .orderBy(desc(bloodBankAuditLog.timestamp))
        .limit(500);
      res.json(logs);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch audit log" });
    }
  });

  // Seed Blood Bank initial data
  const seedBloodBankData = async () => {
    try {
      // Check if service groups already exist
      const existingGroups = await db.select().from(bloodServiceGroups);
      if (existingGroups.length === 0) {
        // Seed 10 NABH-compliant service groups
        const groups = [
          { code: "DONOR", name: "Donor Services", description: "Donor registration, screening, and consent management", displayOrder: 1 },
          { code: "COLLECTION", name: "Blood Collection Services", description: "Whole blood and apheresis collection", displayOrder: 2 },
          { code: "COMPONENT", name: "Component Preparation", description: "Blood component separation and preparation", displayOrder: 3 },
          { code: "TESTING", name: "Testing & Screening", description: "Blood grouping, cross-matching, and disease screening", displayOrder: 4 },
          { code: "STORAGE", name: "Storage & Inventory", description: "Blood unit storage and temperature monitoring", displayOrder: 5 },
          { code: "ISSUE", name: "Issue & Transfusion", description: "Blood issue and transfusion documentation", displayOrder: 6 },
          { code: "REACTION", name: "Transfusion Reaction", description: "Adverse reaction identification and management", displayOrder: 7 },
          { code: "RETURN", name: "Return & Disposal", description: "Unused blood return and disposal management", displayOrder: 8 },
          { code: "EMERGENCY", name: "Emergency Services", description: "Emergency blood issue and massive transfusion protocols", displayOrder: 9 },
          { code: "AUDIT", name: "Audit & Compliance", description: "NABH/FDA compliance and reporting", displayOrder: 10 }
        ];
        await db.insert(bloodServiceGroups).values(groups);
        console.log("Blood Bank service groups seeded");
      }

      // Check if storage facilities exist
      let storageFacilityIds: string[] = [];
      const existingFacilities = await db.select().from(bloodStorageFacilities);
      if (existingFacilities.length === 0) {
        // Seed storage facilities
        const facilities = [
          { facilityCode: "REF-001", name: "Blood Refrigerator 1", type: "REFRIGERATOR", location: "Blood Bank Room A", capacity: 100, minTemperature: "2", maxTemperature: "6", currentTemperature: "4", componentTypes: "WHOLE_BLOOD,PRBC" },
          { facilityCode: "REF-002", name: "Blood Refrigerator 2", type: "REFRIGERATOR", location: "Blood Bank Room A", capacity: 80, minTemperature: "2", maxTemperature: "6", currentTemperature: "4.5", componentTypes: "WHOLE_BLOOD,PRBC" },
          { facilityCode: "FRZ-001", name: "Plasma Freezer", type: "FREEZER", location: "Blood Bank Room B", capacity: 50, minTemperature: "-30", maxTemperature: "-18", currentTemperature: "-25", componentTypes: "FFP,CRYOPRECIPITATE" },
          { facilityCode: "PLT-001", name: "Platelet Agitator", type: "PLATELET_AGITATOR", location: "Blood Bank Room B", capacity: 20, minTemperature: "20", maxTemperature: "24", currentTemperature: "22", componentTypes: "PLATELET" }
        ];
        const insertedFacilities = await db.insert(bloodStorageFacilities).values(facilities).returning();
        storageFacilityIds = insertedFacilities.map(f => f.id);
        console.log("Blood Bank storage facilities seeded");
      } else {
        storageFacilityIds = existingFacilities.map(f => f.id);
      }

      // Check if donors already exist
      const existingDonors = await db.select().from(bloodDonors);
      let donorData: any[] = [];
      if (existingDonors.length === 0) {
        // Seed test donors with realistic Indian names
        const testDonors = [
          { donorId: "DN-20241215-0001", name: "Rajesh Kumar Sharma", bloodGroup: "O+", rhFactor: "Positive", age: 32, gender: "Male", phone: "9876543210", email: "rajesh.sharma@email.com", address: "123 MG Road, Pune", weight: "72", hemoglobinLevel: "14.5", bloodPressure: "120/80", pulseRate: 72, totalDonations: 5, eligibilityStatus: "ELIGIBLE", consentGiven: true },
          { donorId: "DN-20241215-0002", name: "Priya Patel", bloodGroup: "A+", rhFactor: "Positive", age: 28, gender: "Female", phone: "9876543211", email: "priya.patel@email.com", address: "456 FC Road, Pune", weight: "58", hemoglobinLevel: "12.8", bloodPressure: "110/70", pulseRate: 68, totalDonations: 3, eligibilityStatus: "ELIGIBLE", consentGiven: true },
          { donorId: "DN-20241215-0003", name: "Amit Singh Rajput", bloodGroup: "B+", rhFactor: "Positive", age: 35, gender: "Male", phone: "9876543212", email: "amit.rajput@email.com", address: "789 JM Road, Pune", weight: "80", hemoglobinLevel: "15.2", bloodPressure: "125/82", pulseRate: 75, totalDonations: 8, eligibilityStatus: "ELIGIBLE", consentGiven: true },
          { donorId: "DN-20241215-0004", name: "Sunita Devi Verma", bloodGroup: "AB+", rhFactor: "Positive", age: 30, gender: "Female", phone: "9876543213", email: "sunita.verma@email.com", address: "101 Aundh Road, Pune", weight: "62", hemoglobinLevel: "13.0", bloodPressure: "118/78", pulseRate: 70, totalDonations: 2, eligibilityStatus: "ELIGIBLE", consentGiven: true },
          { donorId: "DN-20241215-0005", name: "Mohammad Iqbal Khan", bloodGroup: "O-", rhFactor: "Negative", age: 40, gender: "Male", phone: "9876543214", email: "iqbal.khan@email.com", address: "202 Koregaon Park, Pune", weight: "75", hemoglobinLevel: "14.8", bloodPressure: "122/80", pulseRate: 74, totalDonations: 12, eligibilityStatus: "ELIGIBLE", consentGiven: true },
          { donorId: "DN-20241215-0006", name: "Kavita Joshi", bloodGroup: "A-", rhFactor: "Negative", age: 26, gender: "Female", phone: "9876543215", email: "kavita.joshi@email.com", address: "303 Baner Road, Pune", weight: "55", hemoglobinLevel: "12.5", bloodPressure: "108/72", pulseRate: 66, totalDonations: 1, eligibilityStatus: "ELIGIBLE", consentGiven: true },
          { donorId: "DN-20241215-0007", name: "Vikram Deshmukh", bloodGroup: "B-", rhFactor: "Negative", age: 38, gender: "Male", phone: "9876543216", email: "vikram.deshmukh@email.com", address: "404 Viman Nagar, Pune", weight: "78", hemoglobinLevel: "15.0", bloodPressure: "130/85", pulseRate: 78, totalDonations: 6, eligibilityStatus: "ELIGIBLE", consentGiven: true },
          { donorId: "DN-20241215-0008", name: "Anita Rao", bloodGroup: "AB-", rhFactor: "Negative", age: 33, gender: "Female", phone: "9876543217", email: "anita.rao@email.com", address: "505 Kothrud, Pune", weight: "60", hemoglobinLevel: "13.2", bloodPressure: "115/75", pulseRate: 69, totalDonations: 4, eligibilityStatus: "ELIGIBLE", consentGiven: true }
        ];
        donorData = await db.insert(bloodDonors).values(testDonors).returning();
        console.log("Blood Bank donors seeded: " + donorData.length + " donors");
      } else {
        donorData = existingDonors;
      }

      // Check if blood units already exist
      const existingUnits = await db.select().from(bloodUnits);
      if (existingUnits.length === 0 && donorData.length > 0) {
        // Calculate expiry dates
        const today = new Date();
        const getExpiryDate = (daysFromNow: number) => {
          const date = new Date(today);
          date.setDate(date.getDate() + daysFromNow);
          return date.toISOString().split('T')[0];
        };
        const getCollectionDate = (daysAgo: number) => {
          const date = new Date(today);
          date.setDate(date.getDate() - daysAgo);
          return date.toISOString().split('T')[0];
        };

        // Seed blood units with various statuses
        const testUnits = [
          { unitId: "BU-20241210-0001", componentType: "WHOLE_BLOOD", bloodGroup: "O+", rhFactor: "Positive", volume: 450, donorId: donorData[0]?.id || "donor-1", donorName: "Rajesh Kumar Sharma", collectionDate: getCollectionDate(5), status: "AVAILABLE", expiryDate: getExpiryDate(30), storageFacilityId: storageFacilityIds[0] },
          { unitId: "BU-20241210-0002", componentType: "PRBC", bloodGroup: "O+", rhFactor: "Positive", volume: 280, donorId: donorData[0]?.id || "donor-1", donorName: "Rajesh Kumar Sharma", collectionDate: getCollectionDate(5), status: "AVAILABLE", expiryDate: getExpiryDate(35), storageFacilityId: storageFacilityIds[0] },
          { unitId: "BU-20241211-0001", componentType: "WHOLE_BLOOD", bloodGroup: "A+", rhFactor: "Positive", volume: 450, donorId: donorData[1]?.id || "donor-2", donorName: "Priya Patel", collectionDate: getCollectionDate(4), status: "AVAILABLE", expiryDate: getExpiryDate(31), storageFacilityId: storageFacilityIds[0] },
          { unitId: "BU-20241211-0002", componentType: "FFP", bloodGroup: "A+", rhFactor: "Positive", volume: 200, donorId: donorData[1]?.id || "donor-2", donorName: "Priya Patel", collectionDate: getCollectionDate(4), status: "AVAILABLE", expiryDate: getExpiryDate(365), storageFacilityId: storageFacilityIds[2] },
          { unitId: "BU-20241212-0001", componentType: "WHOLE_BLOOD", bloodGroup: "B+", rhFactor: "Positive", volume: 450, donorId: donorData[2]?.id || "donor-3", donorName: "Amit Singh Rajput", collectionDate: getCollectionDate(3), status: "TESTING", expiryDate: getExpiryDate(32), storageFacilityId: storageFacilityIds[1] },
          { unitId: "BU-20241212-0002", componentType: "PLATELET", bloodGroup: "B+", rhFactor: "Positive", volume: 50, donorId: donorData[2]?.id || "donor-3", donorName: "Amit Singh Rajput", collectionDate: getCollectionDate(3), status: "AVAILABLE", expiryDate: getExpiryDate(2), storageFacilityId: storageFacilityIds[3] },
          { unitId: "BU-20241213-0001", componentType: "PRBC", bloodGroup: "AB+", rhFactor: "Positive", volume: 280, donorId: donorData[3]?.id || "donor-4", donorName: "Sunita Devi Verma", collectionDate: getCollectionDate(2), status: "AVAILABLE", expiryDate: getExpiryDate(40), storageFacilityId: storageFacilityIds[0] },
          { unitId: "BU-20241213-0002", componentType: "WHOLE_BLOOD", bloodGroup: "O-", rhFactor: "Negative", volume: 450, donorId: donorData[4]?.id || "donor-5", donorName: "Mohammad Iqbal Khan", collectionDate: getCollectionDate(2), status: "RESERVED", expiryDate: getExpiryDate(33), storageFacilityId: storageFacilityIds[0], reservedForPatientName: "ICU Patient Emergency" },
          { unitId: "BU-20241214-0001", componentType: "PRBC", bloodGroup: "A-", rhFactor: "Negative", volume: 280, donorId: donorData[5]?.id || "donor-6", donorName: "Kavita Joshi", collectionDate: getCollectionDate(1), status: "AVAILABLE", expiryDate: getExpiryDate(41), storageFacilityId: storageFacilityIds[1] },
          { unitId: "BU-20241214-0002", componentType: "FFP", bloodGroup: "B-", rhFactor: "Negative", volume: 200, donorId: donorData[6]?.id || "donor-7", donorName: "Vikram Deshmukh", collectionDate: getCollectionDate(1), status: "AVAILABLE", expiryDate: getExpiryDate(364), storageFacilityId: storageFacilityIds[2] },
          { unitId: "BU-20241215-0001", componentType: "WHOLE_BLOOD", bloodGroup: "AB-", rhFactor: "Negative", volume: 450, donorId: donorData[7]?.id || "donor-8", donorName: "Anita Rao", collectionDate: getCollectionDate(0), status: "COLLECTED", expiryDate: getExpiryDate(35), storageFacilityId: storageFacilityIds[1] },
          { unitId: "BU-20241208-0001", componentType: "PRBC", bloodGroup: "O+", rhFactor: "Positive", volume: 280, donorId: donorData[0]?.id || "donor-1", donorName: "Rajesh Kumar Sharma", collectionDate: getCollectionDate(10), status: "ISSUED", expiryDate: getExpiryDate(25), storageFacilityId: storageFacilityIds[0], issuedToPatientName: "Rahul Mehra", issuedDate: getCollectionDate(1), issueDepartment: "ICU" }
        ];
        await db.insert(bloodUnits).values(testUnits);
        console.log("Blood Bank units seeded: " + testUnits.length + " units");

        // Update storage facility occupancy
        await db.update(bloodStorageFacilities).set({ currentOccupancy: 5 }).where(eq(bloodStorageFacilities.facilityCode, "REF-001"));
        await db.update(bloodStorageFacilities).set({ currentOccupancy: 3 }).where(eq(bloodStorageFacilities.facilityCode, "REF-002"));
        await db.update(bloodStorageFacilities).set({ currentOccupancy: 2 }).where(eq(bloodStorageFacilities.facilityCode, "FRZ-001"));
        await db.update(bloodStorageFacilities).set({ currentOccupancy: 1 }).where(eq(bloodStorageFacilities.facilityCode, "PLT-001"));
      }

      // Check if transfusion orders exist
      const existingOrders = await db.select().from(bloodTransfusionOrders);
      if (existingOrders.length === 0) {
        const today = new Date().toISOString().split('T')[0];
        const testOrders = [
          { orderId: "TO-20241218-0001", patientId: "patient-1", patientName: "Suresh Kapoor", patientBloodGroup: "O+", patientRhFactor: "Positive", wardDepartment: "ICU", componentRequired: "PRBC", unitsRequired: 2, urgency: "URGENT", indication: "Post-operative anemia", requestingDoctorId: "doctor-1", requestingDoctorName: "Dr. Anil Mehta", status: "PENDING", crossMatchRequired: true, crossMatchStatus: "PENDING" },
          { orderId: "TO-20241218-0002", patientId: "patient-2", patientName: "Meena Saxena", patientBloodGroup: "A+", patientRhFactor: "Positive", wardDepartment: "OT", componentRequired: "FFP", unitsRequired: 1, urgency: "ROUTINE", indication: "Coagulation disorder correction", requestingDoctorId: "doctor-2", requestingDoctorName: "Dr. Priya Nair", status: "APPROVED", crossMatchRequired: false, crossMatchStatus: "COMPATIBLE" },
          { orderId: "TO-20241217-0001", patientId: "patient-3", patientName: "Arun Tiwari", patientBloodGroup: "B+", patientRhFactor: "Positive", wardDepartment: "EMERGENCY", componentRequired: "WHOLE_BLOOD", unitsRequired: 3, urgency: "EMERGENCY", indication: "Trauma with massive blood loss", requestingDoctorId: "doctor-1", requestingDoctorName: "Dr. Anil Mehta", status: "ISSUED", crossMatchRequired: true, crossMatchStatus: "COMPATIBLE" }
        ];
        await db.insert(bloodTransfusionOrders).values(testOrders);
        console.log("Blood Bank orders seeded: " + testOrders.length + " orders");
      }

      // Seed temperature logs for storage facilities
      const existingTempLogs = await db.select().from(bloodTemperatureLogs).limit(1);
      if (existingTempLogs.length === 0 && storageFacilityIds.length > 0) {
        const tempLogs = [];
        const now = new Date();
        
        // Generate 24 hours of temperature readings (every 2 hours)
        for (let i = 0; i < 12; i++) {
          const timestamp = new Date(now.getTime() - i * 2 * 60 * 60 * 1000);
          
          // Refrigerator 1 - normal readings
          tempLogs.push({
            facilityId: storageFacilityIds[0],
            temperature: (3.5 + Math.random() * 1.5).toFixed(1),
            isBreach: false,
            recordedByName: "Auto-Monitor",
            notes: "Routine monitoring"
          });
          
          // Refrigerator 2 - one breach
          const temp2 = i === 3 ? "7.2" : (4 + Math.random() * 1).toFixed(1);
          tempLogs.push({
            facilityId: storageFacilityIds[1],
            temperature: temp2,
            isBreach: i === 3,
            breachType: i === 3 ? "HIGH" : null,
            recordedByName: "Auto-Monitor",
            notes: i === 3 ? "Temperature breach detected - immediate action required" : "Routine monitoring"
          });
          
          // Freezer - normal readings
          tempLogs.push({
            facilityId: storageFacilityIds[2],
            temperature: (-25 + Math.random() * 4).toFixed(1),
            isBreach: false,
            recordedByName: "Auto-Monitor",
            notes: "Routine monitoring"
          });
          
          // Platelet agitator - normal readings
          tempLogs.push({
            facilityId: storageFacilityIds[3],
            temperature: (21 + Math.random() * 2).toFixed(1),
            isBreach: false,
            recordedByName: "Auto-Monitor",
            notes: "Routine monitoring"
          });
        }
        
        await db.insert(bloodTemperatureLogs).values(tempLogs);
        console.log("Blood Bank temperature logs seeded: " + tempLogs.length + " readings");
        
        // Mark one facility as having had a breach
        await db.update(bloodStorageFacilities)
          .set({ hasTemperatureBreach: true })
          .where(eq(bloodStorageFacilities.facilityCode, "REF-002"));
      }

      // Seed audit log entries
      const existingAuditLogs = await db.select().from(bloodBankAuditLog).limit(1);
      if (existingAuditLogs.length === 0) {
        const auditEntries = [
          { entityType: "BLOOD_UNIT", entityId: "BU-20241210-0001", action: "CREATE", details: "Blood unit collected from donor Rajesh Kumar Sharma", userId: "admin", userName: "System Admin", userRole: "ADMIN" },
          { entityType: "BLOOD_UNIT", entityId: "BU-20241210-0001", action: "UPDATE", details: "Status changed: COLLECTED -> TESTING", userId: "admin", userName: "Lab Technician", userRole: "ADMIN" },
          { entityType: "BLOOD_UNIT", entityId: "BU-20241210-0001", action: "UPDATE", details: "Status changed: TESTING -> AVAILABLE", userId: "admin", userName: "Lab Technician", userRole: "ADMIN" },
          { entityType: "DONOR", entityId: "DN-20241215-0001", action: "CREATE", details: "New donor registered: Rajesh Kumar Sharma (O+)", userId: "admin", userName: "System Admin", userRole: "ADMIN" },
          { entityType: "TRANSFUSION_ORDER", entityId: "TO-20241218-0001", action: "CREATE", details: "Transfusion order created for patient Suresh Kapoor", userId: "admin", userName: "Dr. Anil Mehta", userRole: "ADMIN" },
          { entityType: "STORAGE", entityId: "REF-002", action: "TEMPERATURE_BREACH", details: "Temperature breach detected: 7.2C (Max allowed: 6C)", userId: "system", userName: "Auto-Monitor", userRole: "SYSTEM" }
        ];
        await db.insert(bloodBankAuditLog).values(auditEntries);
        console.log("Blood Bank audit logs seeded: " + auditEntries.length + " entries");
      }

    } catch (error) {
      console.error("Error seeding blood bank data:", error);
    }
  };

  // Run blood bank seeding
  await seedBloodBankData();

  // ========== MEDICAL STORE MANAGEMENT ROUTES ==========

  // Get all medical stores (Admin only)
  app.get("/api/medical-stores", async (req, res) => {
    try {
      const stores = await databaseStorage.getAllMedicalStores();
      res.json(stores);
    } catch (error) {
      console.error("Error fetching medical stores:", error);
      res.status(500).json({ error: "Failed to fetch medical stores" });
    }
  });

  // Get single medical store
  app.get("/api/medical-stores/:id", async (req, res) => {
    try {
      const store = await databaseStorage.getMedicalStore(req.params.id);
      if (!store) {
        return res.status(404).json({ error: "Medical store not found" });
      }
      res.json(store);
    } catch (error) {
      console.error("Error fetching medical store:", error);
      res.status(500).json({ error: "Failed to fetch medical store" });
    }
  });

  // Create medical store (Admin only)
  app.post("/api/medical-stores", async (req, res) => {
    try {
      const validatedData = insertMedicalStoreSchema.parse(req.body);
      
      // Generate store code if not provided
      if (!validatedData.storeCode) {
        const existingStores = await databaseStorage.getAllMedicalStores();
        const storeNumber = existingStores.length + 1;
        validatedData.storeCode = `MS-${String(storeNumber).padStart(3, '0')}`;
      }
      
      const store = await databaseStorage.createMedicalStore(validatedData);
      res.status(201).json(store);
    } catch (error) {
      console.error("Error creating medical store:", error);
      res.status(500).json({ error: "Failed to create medical store" });
    }
  });

  // Update medical store (Admin only)
  app.patch("/api/medical-stores/:id", async (req, res) => {
    try {
      const store = await databaseStorage.updateMedicalStore(req.params.id, req.body);
      if (!store) {
        return res.status(404).json({ error: "Medical store not found" });
      }
      res.json(store);
    } catch (error) {
      console.error("Error updating medical store:", error);
      res.status(500).json({ error: "Failed to update medical store" });
    }
  });

  // Delete medical store (Admin only)
  app.delete("/api/medical-stores/:id", async (req, res) => {
    try {
      const deleted = await databaseStorage.deleteMedicalStore(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Medical store not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting medical store:", error);
      res.status(500).json({ error: "Failed to delete medical store" });
    }
  });

  // Get active medical stores (for patients to see)
  app.get("/api/medical-stores/active/list", async (req, res) => {
    try {
      const stores = await databaseStorage.getAllMedicalStores();
      const activeStores = stores.filter(s => s.status === 'ACTIVE');
      res.json(activeStores);
    } catch (error) {
      console.error("Error fetching active medical stores:", error);
      res.status(500).json({ error: "Failed to fetch medical stores" });
    }
  });

  // ========== MEDICAL STORE USER ROUTES ==========

  // Create medical store user (Admin only) - also creates a user account
  app.post("/api/medical-stores/:storeId/users", async (req, res) => {
    try {
      const { username, password, name, email, staffRole, employeeId } = req.body;
      
      // Validate required fields
      if (!username || !password) {
        return res.status(400).json({ error: "Username and password are required" });
      }
      
      // Check if username already exists
      const existingUser = await databaseStorage.getUserByUsername(username);
      if (existingUser) {
        return res.status(409).json({ error: "Username already exists" });
      }
      
      // Hash password
      const hashedPassword = await bcrypt.hash(password, SALT_ROUNDS);
      
      // Create user account with MEDICAL_STORE role
      const newUser = await databaseStorage.createUser({
        username,
        password: hashedPassword,
        role: "MEDICAL_STORE",
        name: name || username,
        email: email || null,
      });
      
      // Link user to medical store
      const storeUser = await databaseStorage.createMedicalStoreUser({
        userId: newUser.id,
        storeId: req.params.storeId,
        staffRole: staffRole || "PHARMACIST",
        employeeId: employeeId || null,
        isActive: true,
      });
      
      res.status(201).json({ user: newUser, storeUser });
    } catch (error) {
      console.error("Error creating medical store user:", error);
      res.status(500).json({ error: "Failed to create medical store user" });
    }
  });

  // Get users for a medical store
  app.get("/api/medical-stores/:storeId/users", async (req, res) => {
    try {
      const storeUsers = await databaseStorage.getMedicalStoreUsersByStore(req.params.storeId);
      res.json(storeUsers);
    } catch (error) {
      console.error("Error fetching store users:", error);
      res.status(500).json({ error: "Failed to fetch store users" });
    }
  });

  // Get current user's store info (for medical store portal)
  app.get("/api/medical-stores/my-store/:userId", async (req, res) => {
    try {
      const storeUser = await databaseStorage.getMedicalStoreUserByUserId(req.params.userId);
      if (!storeUser) {
        return res.status(404).json({ error: "Store user not found" });
      }
      const store = await databaseStorage.getMedicalStore(storeUser.storeId);
      res.json({ storeUser, store });
    } catch (error) {
      console.error("Error fetching user's store:", error);
      res.status(500).json({ error: "Failed to fetch store info" });
    }
  });

  // ========== PRESCRIPTION ACCESS ROUTES (Medical Store) ==========

  // Search prescriptions by patient name or ID (for medical store)
  app.get("/api/medical-stores/prescriptions/search", async (req, res) => {
    try {
      const { query } = req.query;
      if (!query) {
        return res.status(400).json({ error: "Search query is required" });
      }
      
      // Get all finalized prescriptions
      const allPrescriptions = await db.select().from(prescriptions)
        .where(eq(prescriptions.prescriptionStatus, 'finalized'))
        .orderBy(desc(prescriptions.createdAt));
      
      // Filter by patient name or prescription number
      const searchLower = String(query).toLowerCase();
      const matchedPrescriptions = allPrescriptions.filter(p => 
        p.patientName.toLowerCase().includes(searchLower) ||
        p.patientId.toLowerCase().includes(searchLower) ||
        (p.prescriptionNumber && p.prescriptionNumber.toLowerCase().includes(searchLower))
      );
      
      res.json(matchedPrescriptions);
    } catch (error) {
      console.error("Error searching prescriptions:", error);
      res.status(500).json({ error: "Failed to search prescriptions" });
    }
  });

  // Get prescription details for dispensing
  app.get("/api/medical-stores/prescriptions/:id", async (req, res) => {
    try {
      const prescription = await databaseStorage.getPrescription(req.params.id);
      if (!prescription) {
        return res.status(404).json({ error: "Prescription not found" });
      }
      
      // Get any existing dispensing records for this prescription
      const dispensingRecords = await databaseStorage.getPrescriptionDispensingByPrescription(req.params.id);
      
      res.json({ prescription, dispensingRecords });
    } catch (error) {
      console.error("Error fetching prescription:", error);
      res.status(500).json({ error: "Failed to fetch prescription" });
    }
  });

  // ========== PRESCRIPTION DISPENSING ROUTES ==========

  // Create dispensing record
  app.post("/api/medical-stores/dispensing", async (req, res) => {
    try {
      const { prescriptionId, storeId, storeName, dispensedBy, dispensedByName, items, ...restData } = req.body;
      
      // Generate dispensing number
      const year = new Date().getFullYear();
      const allDispensing = await databaseStorage.getAllPrescriptionDispensing();
      const dispensingNumber = `DISP-${year}-${String(allDispensing.length + 1).padStart(4, '0')}`;
      
      // Get prescription details
      const prescription = await databaseStorage.getPrescription(prescriptionId);
      if (!prescription) {
        return res.status(404).json({ error: "Prescription not found" });
      }
      
      // Create dispensing record
      const dispensing = await databaseStorage.createPrescriptionDispensing({
        dispensingNumber,
        prescriptionId,
        prescriptionNumber: prescription.prescriptionNumber,
        patientId: prescription.patientId,
        patientName: prescription.patientName,
        storeId,
        storeName,
        dispensedBy,
        dispensedByName,
        dispensingStatus: "PENDING",
        ...restData,
      });
      
      // Create dispensing items if provided
      if (items && Array.isArray(items)) {
        for (const item of items) {
          await databaseStorage.createDispensingItem({
            dispensingId: dispensing.id,
            ...item,
          });
        }
      }
      
      res.status(201).json(dispensing);
    } catch (error) {
      console.error("Error creating dispensing:", error);
      res.status(500).json({ error: "Failed to create dispensing record" });
    }
  });

  // Update dispensing record
  app.patch("/api/medical-stores/dispensing/:id", async (req, res) => {
    try {
      const dispensing = await databaseStorage.updatePrescriptionDispensing(req.params.id, req.body);
      if (!dispensing) {
        return res.status(404).json({ error: "Dispensing record not found" });
      }
      res.json(dispensing);
    } catch (error) {
      console.error("Error updating dispensing:", error);
      res.status(500).json({ error: "Failed to update dispensing record" });
    }
  });

  // Get dispensing records for a store
  app.get("/api/medical-stores/:storeId/dispensing", async (req, res) => {
    try {
      const dispensingRecords = await databaseStorage.getPrescriptionDispensingByStore(req.params.storeId);
      res.json(dispensingRecords);
    } catch (error) {
      console.error("Error fetching dispensing records:", error);
      res.status(500).json({ error: "Failed to fetch dispensing records" });
    }
  });

  // ========== MEDICAL STORE BILLING ROUTES ==========

  // Create bill from dispensing
  app.post("/api/medical-stores/bills", async (req, res) => {
    try {
      const { dispensingId, storeId, ...restData } = req.body;
      
      // Get dispensing record
      const allDispensing = await databaseStorage.getAllPrescriptionDispensing();
      const dispensing = allDispensing.find(d => d.id === dispensingId);
      if (!dispensing) {
        return res.status(404).json({ error: "Dispensing record not found" });
      }
      
      // Generate bill number
      const year = new Date().getFullYear();
      const allBills = await databaseStorage.getAllMedicalStoreBills();
      const billNumber = `INV-${year}-${String(allBills.length + 1).padStart(4, '0')}`;
      
      // Get store details
      const store = await databaseStorage.getMedicalStore(storeId);
      
      // Create bill
      const bill = await databaseStorage.createMedicalStoreBill({
        billNumber,
        dispensingId,
        storeId,
        storeName: store?.storeName || 'Unknown Store',
        storeAddress: store?.address,
        storeGst: store?.gstNumber,
        patientId: dispensing.patientId,
        patientName: dispensing.patientName,
        patientPhone: dispensing.patientPhone,
        prescriptionNumber: dispensing.prescriptionNumber,
        ...restData,
      });
      
      // Update dispensing status to FULLY_DISPENSED
      await databaseStorage.updatePrescriptionDispensing(dispensingId, {
        dispensingStatus: "FULLY_DISPENSED",
        paymentStatus: restData.paymentStatus || "PENDING",
      });
      
      res.status(201).json(bill);
    } catch (error) {
      console.error("Error creating bill:", error);
      res.status(500).json({ error: "Failed to create bill" });
    }
  });

  // Get bills for a store
  app.get("/api/medical-stores/:storeId/bills", async (req, res) => {
    try {
      const bills = await databaseStorage.getMedicalStoreBillsByStore(req.params.storeId);
      res.json(bills);
    } catch (error) {
      console.error("Error fetching bills:", error);
      res.status(500).json({ error: "Failed to fetch bills" });
    }
  });

  // Update bill (e.g., mark as paid)
  app.patch("/api/medical-stores/bills/:id", async (req, res) => {
    try {
      const bill = await databaseStorage.updateMedicalStoreBill(req.params.id, req.body);
      if (!bill) {
        return res.status(404).json({ error: "Bill not found" });
      }
      res.json(bill);
    } catch (error) {
      console.error("Error updating bill:", error);
      res.status(500).json({ error: "Failed to update bill" });
    }
  });

  // ========== MEDICAL STORE ACCESS LOGS ==========

  // Log access (automatically called on prescription view/dispensing)
  app.post("/api/medical-stores/access-logs", async (req, res) => {
    try {
      const log = await databaseStorage.createMedicalStoreAccessLog(req.body);
      res.status(201).json(log);
    } catch (error) {
      console.error("Error creating access log:", error);
      res.status(500).json({ error: "Failed to create access log" });
    }
  });

  // Get access logs (Admin only)
  app.get("/api/medical-stores/access-logs/all", async (req, res) => {
    try {
      const logs = await databaseStorage.getMedicalStoreAccessLogs();
      res.json(logs);
    } catch (error) {
      console.error("Error fetching access logs:", error);
      res.status(500).json({ error: "Failed to fetch access logs" });
    }
  });

  // Get access logs for a specific store
  app.get("/api/medical-stores/:storeId/access-logs", async (req, res) => {
    try {
      const logs = await databaseStorage.getMedicalStoreAccessLogs(req.params.storeId);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching store access logs:", error);
      res.status(500).json({ error: "Failed to fetch access logs" });
    }
  });

  // ========== PATIENT PRESCRIPTION ACCESS ==========

  // Get prescriptions for a patient (for patient portal)
  app.get("/api/patients/:patientId/prescriptions", async (req, res) => {
    try {
      const patientPrescriptions = await db.select().from(prescriptions)
        .where(eq(prescriptions.patientId, req.params.patientId))
        .orderBy(desc(prescriptions.createdAt));
      res.json(patientPrescriptions);
    } catch (error) {
      console.error("Error fetching patient prescriptions:", error);
      res.status(500).json({ error: "Failed to fetch prescriptions" });
    }
  });

  // ========== MEDICAL STORE INVENTORY ROUTES ==========

  // Get store inventory
  app.get("/api/medical-stores/:storeId/inventory", async (req, res) => {
    try {
      const inventory = await databaseStorage.getMedicalStoreInventory(req.params.storeId);
      res.json(inventory);
    } catch (error) {
      console.error("Error fetching inventory:", error);
      res.status(500).json({ error: "Failed to fetch inventory" });
    }
  });

  // Add inventory item
  app.post("/api/medical-stores/:storeId/inventory", async (req, res) => {
    try {
      const item = await databaseStorage.createMedicalStoreInventoryItem({
        storeId: req.params.storeId,
        ...req.body,
      });
      res.status(201).json(item);
    } catch (error) {
      console.error("Error adding inventory item:", error);
      res.status(500).json({ error: "Failed to add inventory item" });
    }
  });

  // Update inventory item
  app.patch("/api/medical-stores/inventory/:id", async (req, res) => {
    try {
      const item = await databaseStorage.updateMedicalStoreInventoryItem(req.params.id, req.body);
      if (!item) {
        return res.status(404).json({ error: "Inventory item not found" });
      }
      res.json(item);
    } catch (error) {
      console.error("Error updating inventory item:", error);
      res.status(500).json({ error: "Failed to update inventory item" });
    }
  });

  // Delete inventory item
  app.delete("/api/medical-stores/inventory/:id", async (req, res) => {
    try {
      const deleted = await databaseStorage.deleteMedicalStoreInventoryItem(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Inventory item not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting inventory item:", error);
      res.status(500).json({ error: "Failed to delete inventory item" });
    }
  });

  // ==================== PATHOLOGY LAB ROUTES ====================

  // Get all pathology labs
  app.get("/api/pathology-labs", async (req, res) => {
    try {
      const labs = await databaseStorage.getAllPathologyLabs();
      res.json(labs);
    } catch (error) {
      console.error("Error fetching pathology labs:", error);
      res.status(500).json({ error: "Failed to fetch pathology labs" });
    }
  });

  // Get single pathology lab
  app.get("/api/pathology-labs/:id", async (req, res) => {
    try {
      const lab = await databaseStorage.getPathologyLab(req.params.id);
      if (!lab) {
        return res.status(404).json({ error: "Lab not found" });
      }
      res.json(lab);
    } catch (error) {
      console.error("Error fetching lab:", error);
      res.status(500).json({ error: "Failed to fetch lab" });
    }
  });

  // Create pathology lab
  app.post("/api/pathology-labs", async (req, res) => {
    try {
      const lab = await databaseStorage.createPathologyLab(req.body);
      res.status(201).json(lab);
    } catch (error) {
      console.error("Error creating pathology lab:", error);
      res.status(500).json({ error: "Failed to create pathology lab" });
    }
  });

  // Update pathology lab
  app.patch("/api/pathology-labs/:id", async (req, res) => {
    try {
      const lab = await databaseStorage.updatePathologyLab(req.params.id, req.body);
      if (!lab) {
        return res.status(404).json({ error: "Lab not found" });
      }
      res.json(lab);
    } catch (error) {
      console.error("Error updating lab:", error);
      res.status(500).json({ error: "Failed to update lab" });
    }
  });

  // Delete pathology lab
  app.delete("/api/pathology-labs/:id", async (req, res) => {
    try {
      const success = await databaseStorage.deletePathologyLab(req.params.id);
      if (!success) {
        return res.status(404).json({ error: "Lab not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting lab:", error);
      res.status(500).json({ error: "Failed to delete lab" });
    }
  });

  // Get all lab tests
  app.get("/api/lab-tests", async (req, res) => {
    try {
      const tests = await databaseStorage.getAllLabTests();
      res.json(tests);
    } catch (error) {
      console.error("Error fetching lab tests:", error);
      res.status(500).json({ error: "Failed to fetch lab tests" });
    }
  });

  // Create lab test
  app.post("/api/lab-tests", async (req, res) => {
    try {
      const test = await databaseStorage.createLabTest(req.body);
      res.status(201).json(test);
    } catch (error) {
      console.error("Error creating lab test:", error);
      res.status(500).json({ error: "Failed to create lab test" });
    }
  });

  // Update lab test
  app.patch("/api/lab-tests/:id", async (req, res) => {
    try {
      const test = await databaseStorage.updateLabTest(req.params.id, req.body);
      if (!test) {
        return res.status(404).json({ error: "Test not found" });
      }
      res.json(test);
    } catch (error) {
      console.error("Error updating test:", error);
      res.status(500).json({ error: "Failed to update test" });
    }
  });

  // Delete lab test
  app.delete("/api/lab-tests/:id", async (req, res) => {
    try {
      const success = await databaseStorage.deleteLabTest(req.params.id);
      if (!success) {
        return res.status(404).json({ error: "Test not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting test:", error);
      res.status(500).json({ error: "Failed to delete test" });
    }
  });

  // Get all lab test orders
  app.get("/api/lab-test-orders", async (req, res) => {
    try {
      const orders = await databaseStorage.getAllLabTestOrders();
      res.json(orders);
    } catch (error) {
      console.error("Error fetching lab test orders:", error);
      res.status(500).json({ error: "Failed to fetch lab test orders" });
    }
  });

  // Get orders by lab
  app.get("/api/lab-test-orders/lab/:labId", async (req, res) => {
    try {
      const orders = await databaseStorage.getLabTestOrdersByLab(req.params.labId);
      res.json(orders);
    } catch (error) {
      console.error("Error fetching lab orders:", error);
      res.status(500).json({ error: "Failed to fetch lab orders" });
    }
  });

  // Create lab test order
  app.post("/api/lab-test-orders", async (req, res) => {
    try {
      const allOrders = await databaseStorage.getAllLabTestOrders();
      const orderNumber = `LAB-${new Date().getFullYear()}-${String(allOrders.length + 1).padStart(4, '0')}`;
      const order = await databaseStorage.createLabTestOrder({ ...req.body, orderNumber });
      res.status(201).json(order);
    } catch (error) {
      console.error("Error creating lab test order:", error);
      res.status(500).json({ error: "Failed to create lab test order" });
    }
  });

  // Batch create lab test orders (transactional - all succeed or all fail)
  app.post("/api/lab-test-orders/batch", async (req, res) => {
    try {
      const { orders } = req.body as { orders: any[] };
      if (!Array.isArray(orders) || orders.length === 0) {
        return res.status(400).json({ error: "Orders array is required" });
      }
      
      // Schema for batch validation - orderNumber is generated by DB, so omit it
      const batchOrderSchema = insertLabTestOrderSchema.omit({ orderNumber: true });
      
      // Validate each order against Zod schema for type safety and data integrity
      const validatedOrders = orders.map((order, index) => {
        const result = batchOrderSchema.safeParse({
          patientId: order.patientId,
          patientName: order.patientName,
          patientUhid: order.patientUhid,
          patientAge: order.patientAge,
          patientGender: order.patientGender,
          doctorId: order.doctorId,
          doctorName: order.doctorName,
          testId: order.testId,
          testName: order.testName,
          testCode: order.testCode,
          priority: order.priority || "NORMAL",
          clinicalNotes: order.clinicalNotes,
          orderedAt: order.orderedAt ? new Date(order.orderedAt) : new Date()
        });
        
        if (!result.success) {
          throw new Error(`Order at index ${index} validation failed: ${result.error.issues.map(i => i.message).join(", ")}`);
        }
        return result.data;
      });
      
      // Use storage layer for transactional batch insert (order numbers generated via sequence)
      const createdOrders = await databaseStorage.createLabTestOrdersBatch(validatedOrders);
      
      res.status(201).json({
        totalRequested: orders.length,
        successCount: createdOrders.length,
        failedCount: 0,
        orders: createdOrders,
        errors: []
      });
    } catch (error: any) {
      console.error("Error creating batch lab test orders:", error);
      res.status(500).json({ error: error.message || "Failed to create batch lab test orders - transaction rolled back" });
    }
  });

  // Update lab test order
  app.patch("/api/lab-test-orders/:id", async (req, res) => {
    try {
      const order = await databaseStorage.updateLabTestOrder(req.params.id, req.body);
      if (!order) {
        return res.status(404).json({ error: "Order not found" });
      }
      res.json(order);
    } catch (error) {
      console.error("Error updating order:", error);
      res.status(500).json({ error: "Failed to update order" });
    }
  });

  // Get all sample collections
  app.get("/api/sample-collections", async (req, res) => {
    try {
      const samples = await databaseStorage.getAllSampleCollections();
      res.json(samples);
    } catch (error) {
      console.error("Error fetching sample collections:", error);
      res.status(500).json({ error: "Failed to fetch sample collections" });
    }
  });

  // Create sample collection
  app.post("/api/sample-collections", async (req, res) => {
    try {
      const sample = await databaseStorage.createSampleCollection(req.body);
      await databaseStorage.updateLabTestOrder(req.body.orderId, { orderStatus: "SAMPLE_COLLECTED" });
      res.status(201).json(sample);
    } catch (error) {
      console.error("Error creating sample collection:", error);
      res.status(500).json({ error: "Failed to create sample collection" });
    }
  });

  // Update sample collection status
  app.patch("/api/sample-collections/:id", async (req, res) => {
    try {
      const sample = await databaseStorage.updateSampleCollection(req.params.id, req.body);
      if (!sample) {
        return res.status(404).json({ error: "Sample not found" });
      }
      res.json(sample);
    } catch (error) {
      console.error("Error updating sample:", error);
      res.status(500).json({ error: "Failed to update sample" });
    }
  });

  // Get all lab reports - role-based filtering for security
  app.get("/api/lab-reports", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      // Role-based filtering
      const allReports = await databaseStorage.getAllLabReports();
      
      // ADMIN and PATHOLOGY_LAB can see all reports
      if (user.role === "ADMIN" || user.role === "PATHOLOGY_LAB") {
        return res.json(allReports);
      }
      
      // DOCTOR can only see reports for their patients
      if (user.role === "DOCTOR") {
        const doctorReports = allReports.filter(r => r.doctorId === user.id);
        return res.json(doctorReports);
      }
      
      // PATIENT can only see their own reports
      if (user.role === "PATIENT") {
        const patientReports = allReports.filter(r => r.patientId === user.id);
        return res.json(patientReports);
      }
      
      // NURSE can see reports for patients they are caring for
      if (user.role === "NURSE") {
        return res.json(allReports);
      }
      
      // Default: return empty array for other roles
      res.json([]);
    } catch (error) {
      console.error("Error fetching lab reports:", error);
      res.status(500).json({ error: "Failed to fetch lab reports" });
    }
  });

  // Get reports by patient - with authorization check
  app.get("/api/lab-reports/patient/:patientId", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const patientId = req.params.patientId;
      
      // Only allow access if:
      // 1. User is the patient themselves
      // 2. User is ADMIN/PATHOLOGY_LAB/DOCTOR/NURSE
      const allowedRoles = ["ADMIN", "PATHOLOGY_LAB", "DOCTOR", "NURSE"];
      if (user.role !== "PATIENT" && !allowedRoles.includes(user.role)) {
        return res.status(403).json({ error: "Access denied" });
      }
      
      // If patient, can only access their own reports
      if (user.role === "PATIENT" && user.id !== patientId) {
        return res.status(403).json({ error: "Access denied. You can only view your own lab reports." });
      }
      
      const reports = await databaseStorage.getLabReportsByPatient(patientId);
      res.json(reports);
    } catch (error) {
      console.error("Error fetching patient reports:", error);
      res.status(500).json({ error: "Failed to fetch patient reports" });
    }
  });

  // Get reports by lab
  app.get("/api/lab-reports/lab/:labId", async (req, res) => {
    try {
      const reports = await databaseStorage.getLabReportsByLab(req.params.labId);
      res.json(reports);
    } catch (error) {
      console.error("Error fetching lab reports:", error);
      res.status(500).json({ error: "Failed to fetch lab reports" });
    }
  });

  // Get single lab report with results
  app.get("/api/lab-reports/:id", async (req, res) => {
    try {
      const report = await databaseStorage.getLabReport(req.params.id);
      if (!report) {
        return res.status(404).json({ error: "Report not found" });
      }
      const results = await databaseStorage.getLabReportResults(report.id);
      res.json({ ...report, results });
    } catch (error) {
      console.error("Error fetching report:", error);
      res.status(500).json({ error: "Failed to fetch report" });
    }
  });

  // Create lab report with notifications - Restricted to PATHOLOGY_LAB and ADMIN
  // Supports both order-based reports and walk-in patient reports
  app.post("/api/lab-reports", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      // Role-based authorization - only PATHOLOGY_LAB and ADMIN can create reports
      const allowedRoles = ["PATHOLOGY_LAB", "ADMIN"];
      if (!allowedRoles.includes(user.role)) {
        return res.status(403).json({ error: "Access denied. Only pathology lab staff and administrators can create lab reports." });
      }
      
      const allReports = await databaseStorage.getAllLabReports();
      const reportNumber = `RPT-${new Date().getFullYear()}-${String(allReports.length + 1).padStart(4, '0')}`;
      
      // Handle walk-in patient reports (no order required)
      const isWalkIn = req.body.isWalkIn === true;
      const orderNumber = isWalkIn 
        ? `WALKIN-${new Date().getFullYear()}-${String(allReports.length + 1).padStart(4, '0')}`
        : (req.body.orderNumber || `ORD-${Date.now()}`);
      
      // Build report data with walk-in support
      const reportData = {
        ...req.body,
        reportNumber,
        orderNumber,
        orderId: isWalkIn ? null : req.body.orderId,
        doctorId: isWalkIn ? null : req.body.doctorId,
        doctorName: isWalkIn ? (req.body.referredBy || 'Self') : req.body.doctorName,
        reportDate: new Date(),
        reportType: req.body.reportType || "STRUCTURED",
        verifiedBy: user.firstName + ' ' + user.lastName,
        verifiedAt: new Date(),
      };
      
      const report = await databaseStorage.createLabReport(reportData);

      // Only update order status if this is not a walk-in patient and orderId exists
      if (!isWalkIn && req.body.orderId) {
        await databaseStorage.updateLabTestOrder(req.body.orderId, { orderStatus: "COMPLETED" });
      }

      // Send notifications based on walk-in status
      const notificationData = {
        title: isWalkIn ? "Walk-in Lab Report Created" : "Lab Report Available",
        message: `${isWalkIn ? 'Walk-in' : 'New'} lab report: ${report.testName} for patient ${report.patientName}`,
        type: "lab_report",
        isRead: false,
        relatedEntityId: report.id,
        relatedEntityType: "lab_report",
      };
      
      // For non-walk-in patients, notify patient and doctor
      if (!isWalkIn) {
        // Notify patient
        await databaseStorage.createUserNotification({ ...notificationData, userId: report.patientId, userRole: "PATIENT" });
        
        // Notify doctor if exists
        if (report.doctorId) {
          await databaseStorage.createUserNotification({ ...notificationData, userId: report.doctorId, userRole: "DOCTOR" });
        }
      }
      
      // Always notify admins and nurses (staff) for all reports including walk-in
      const admins = await databaseStorage.getUsersByRole("ADMIN");
      for (const admin of admins) {
        await databaseStorage.createUserNotification({ ...notificationData, userId: admin.id, userRole: "ADMIN" });
      }

      const nurses = await databaseStorage.getUsersByRole("NURSE");
      for (const nurse of nurses) {
        await databaseStorage.createUserNotification({ ...notificationData, userId: nurse.id, userRole: "NURSE" });
      }

      await databaseStorage.createPathologyLabAccessLog({
        labId: report.labId,
        labName: report.labName,
        userId: req.body.uploadedBy || report.labId,
        userName: req.body.uploadedByName || report.labName,
        userRole: "PATHOLOGY_LAB",
        action: "REPORT_UPLOAD",
        reportId: report.id,
        patientId: report.patientId,
        patientName: report.patientName,
        details: `Uploaded report ${reportNumber} for test ${report.testName}`,
      });

      res.status(201).json(report);
    } catch (error) {
      console.error("Error creating lab report:", error);
      res.status(500).json({ error: "Failed to create lab report" });
    }
  });

  // Upload lab report with file (PDF/image) - Authorization middleware runs BEFORE multer
  app.post("/api/lab-reports/upload", requireLabReportUploadAuth, uploadLabReport.single('reportFile'), async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      
      // User already validated by requireLabReportUploadAuth middleware
      // Parse form data
      const formData = req.body;
      const file = req.file;
      
      if (!file) {
        return res.status(400).json({ error: "Report file is required" });
      }
      
      // Generate report number
      const allReports = await databaseStorage.getAllLabReports();
      const reportNumber = `RPT-${new Date().getFullYear()}-${String(allReports.length + 1).padStart(4, '0')}`;
      
      // Create file URL
      const pdfUrl = `/uploads/lab-reports/${file.filename}`;
      
      // Create lab report
      const reportData = {
        reportNumber,
        orderId: formData.orderId,
        orderNumber: formData.orderNumber || `ORD-${Date.now()}`,
        patientId: formData.patientId,
        patientName: formData.patientName,
        patientUhid: formData.patientUhid || null,
        doctorId: formData.doctorId || user.id,
        doctorName: formData.doctorName || user.firstName + ' ' + user.lastName,
        labId: user.id,
        labName: formData.labName || "Hospital Lab",
        testId: formData.testId || formData.orderId,
        testName: formData.testName || "Lab Test",
        testCategory: formData.testCategory || "General",
        reportDate: new Date(),
        reportStatus: "COMPLETED",
        reportType: "PDF",
        pdfUrl,
        resultData: formData.resultSummary ? JSON.stringify({ summary: formData.resultSummary }) : null,
        interpretation: formData.interpretation || "NORMAL",
        remarks: formData.remarks || null,
        verifiedBy: user.firstName + ' ' + user.lastName,
        verifiedAt: new Date(),
        isNotified: false,
      };
      
      const report = await databaseStorage.createLabReport(reportData);
      
      // Mark the order as completed if orderId provided
      if (formData.orderId) {
        await databaseStorage.updateLabTestOrder(formData.orderId, { orderStatus: "COMPLETED" });
      }
      
      // Send notifications
      const notificationData = {
        title: "Lab Report Available",
        message: `Your lab report for ${reportData.testName} is now available.`,
        type: "lab_report",
        priority: formData.interpretation === "CRITICAL" ? "critical" : "normal",
        channel: "push",
        isRead: false,
        referenceId: report.id,
        referenceType: "lab_report",
      };
      
      // Notify patient
      await databaseStorage.createUserNotification({ 
        userId: report.patientId, 
        userRole: "PATIENT",
        type: notificationData.type,
        title: notificationData.title,
        message: notificationData.message,
        relatedEntityId: report.id,
        relatedEntityType: "lab_report",
        isRead: false,
      });
      
      // Notify doctor if doctorId exists
      if (report.doctorId) {
        await databaseStorage.createUserNotification({ 
          userId: report.doctorId, 
          userRole: "DOCTOR",
          type: notificationData.type,
          title: notificationData.title,
          message: notificationData.message,
          relatedEntityId: report.id,
          relatedEntityType: "lab_report",
          isRead: false,
        });
      }
      
      // Notify admins
      const admins = await databaseStorage.getUsersByRole("ADMIN");
      for (const admin of admins) {
        await databaseStorage.createUserNotification({ 
          userId: admin.id, 
          userRole: "ADMIN",
          type: notificationData.type,
          title: notificationData.title,
          message: notificationData.message,
          relatedEntityId: report.id,
          relatedEntityType: "lab_report",
          isRead: false,
        });
      }
      
      // Create access log
      await databaseStorage.createPathologyLabAccessLog({
        labId: user.id,
        labName: reportData.labName,
        userId: user.id,
        userName: user.firstName + ' ' + user.lastName,
        userRole: user.role,
        action: "REPORT_UPLOAD",
        reportId: report.id,
        patientId: report.patientId,
        patientName: report.patientName,
        details: `Uploaded report ${reportNumber} with file for ${reportData.testName}`,
      });
      
      res.status(201).json(report);
    } catch (error) {
      console.error("Error uploading lab report:", error);
      res.status(500).json({ error: "Failed to upload lab report" });
    }
  });

  // Update lab report
  app.patch("/api/lab-reports/:id", async (req, res) => {
    try {
      const report = await databaseStorage.updateLabReport(req.params.id, req.body);
      if (!report) {
        return res.status(404).json({ error: "Report not found" });
      }
      res.json(report);
    } catch (error) {
      console.error("Error updating report:", error);
      res.status(500).json({ error: "Failed to update report" });
    }
  });

  // Add results to a report
  app.post("/api/lab-reports/:reportId/results", async (req, res) => {
    try {
      const results = req.body.results || [req.body];
      const createdResults = [];
      for (const result of results) {
        const created = await databaseStorage.createLabReportResult({ ...result, reportId: req.params.reportId });
        createdResults.push(created);
      }
      res.status(201).json(createdResults);
    } catch (error) {
      console.error("Error adding report results:", error);
      res.status(500).json({ error: "Failed to add report results" });
    }
  });

  // Get pathology lab access logs
  app.get("/api/pathology-labs/access-logs", async (req, res) => {
    try {
      const logs = await databaseStorage.getPathologyLabAccessLogs();
      res.json(logs);
    } catch (error) {
      console.error("Error fetching access logs:", error);
      res.status(500).json({ error: "Failed to fetch access logs" });
    }
  });

  // Create pathology lab access log
  app.post("/api/pathology-labs/access-logs", async (req, res) => {
    try {
      const log = await databaseStorage.createPathologyLabAccessLog(req.body);
      res.status(201).json(log);
    } catch (error) {
      console.error("Error creating access log:", error);
      res.status(500).json({ error: "Failed to create access log" });
    }
  });

  // ============================================
  // PATIENT BARCODE SYSTEM - UHID Based Secure Scanning
  // ============================================

  // Allowed roles for barcode scanning (ADMIN, DOCTOR, NURSE only)
  const BARCODE_ALLOWED_ROLES = ["ADMIN", "DOCTOR", "NURSE"];

  // Generate UHID for new patient
  const generateUHID = async (admissionType: string): Promise<string> => {
    const year = new Date().getFullYear();
    const prefix = admissionType === "IPD" ? "GRAV-IPD" : "GRAV-OPD";
    
    // Get count of existing barcodes for this type and year
    const existingBarcodes = await db.select().from(patientBarcodes)
      .where(eq(patientBarcodes.admissionType, admissionType));
    
    const count = existingBarcodes.filter(b => b.uhid.includes(`${year}`)).length + 1;
    const paddedCount = count.toString().padStart(6, '0');
    
    return `${prefix}-${year}-${paddedCount}`;
  };

  // Generate encrypted token for barcode
  const generateEncryptedToken = (patientId: string, uhid: string): string => {
    const data = `${patientId}|${uhid}|${Date.now()}`;
    const cipher = crypto.createHash('sha256');
    cipher.update(data);
    return cipher.digest('hex');
  };

  // Generate barcode on patient admission
  app.post("/api/barcode/generate", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      
      if (!user) {
        return res.status(401).json({ error: "Authentication required" });
      }

      // Only ADMIN, DOCTOR, NURSE can generate barcodes
      if (!BARCODE_ALLOWED_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized: Only Admin, Doctor, or Nurse can generate patient barcodes" });
      }

      const { patientId, patientName, admissionType, wardBed, treatingDoctor } = req.body;

      if (!patientId || !patientName || !admissionType) {
        return res.status(400).json({ error: "Patient ID, name, and admission type are required" });
      }

      // Generate UHID
      const uhid = await generateUHID(admissionType);
      
      // Generate encrypted token (no patient data in barcode)
      const encryptedToken = generateEncryptedToken(patientId, uhid);
      
      // Barcode data is just the UHID and token - no sensitive info
      const barcodeData = `HMS:${uhid}:${encryptedToken.substring(0, 16)}`;

      // Create barcode record
      const [barcode] = await db.insert(patientBarcodes).values({
        patientId,
        patientName,
        uhid,
        admissionType,
        encryptedToken,
        barcodeData,
        wardBed: wardBed || null,
        treatingDoctor: treatingDoctor || null,
        isActive: true,
      }).returning();

      // Log the barcode generation
      await db.insert(barcodeScanLogs).values({
        barcodeId: barcode.id,
        uhid,
        scannedBy: user.id,
        scannedByName: user.name || user.username,
        role: user.role,
        allowed: true,
        ipAddress: req.ip || null,
        deviceInfo: req.headers['user-agent'] || null,
      });

      res.status(201).json({
        id: barcode.id,
        uhid,
        barcodeData,
        patientName,
        admissionType,
        wardBed,
        treatingDoctor,
        createdAt: barcode.createdAt,
      });
    } catch (error) {
      console.error("Error generating barcode:", error);
      res.status(500).json({ error: "Failed to generate barcode" });
    }
  });

  // Scan barcode - STRICT ROLE-BASED ACCESS (ADMIN, DOCTOR, NURSE only)
  app.post("/api/barcode/scan", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      
      if (!user) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const { barcodeData, uhid: manualUhid } = req.body;
      const searchUhid = manualUhid || (barcodeData?.includes(':') ? barcodeData.split(':')[1] : barcodeData);

      // Log every scan attempt
      const logScanAttempt = async (allowed: boolean, reason?: string, barcodeId?: string) => {
        await db.insert(barcodeScanLogs).values({
          barcodeId: barcodeId || null,
          uhid: searchUhid || null,
          scannedBy: user.id,
          scannedByName: user.name || user.username,
          role: user.role,
          allowed,
          denialReason: reason || null,
          ipAddress: req.ip || null,
          deviceInfo: req.headers['user-agent'] || null,
        });
      };

      // STRICT ROLE CHECK - Only ADMIN, DOCTOR, NURSE allowed
      if (!BARCODE_ALLOWED_ROLES.includes(user.role)) {
        await logScanAttempt(false, `Access denied: Role ${user.role} not authorized`);
        return res.status(403).json({ 
          error: "ACCESS DENIED: Your role is not authorized to scan patient barcodes",
          roleRequired: "ADMIN, DOCTOR, or NURSE",
          yourRole: user.role
        });
      }

      if (!searchUhid) {
        await logScanAttempt(false, "No barcode data provided");
        return res.status(400).json({ error: "Barcode data or UHID is required" });
      }

      // Find barcode by UHID
      const [barcode] = await db.select().from(patientBarcodes)
        .where(eq(patientBarcodes.uhid, searchUhid));

      if (!barcode) {
        await logScanAttempt(false, "Barcode not found in system");
        return res.status(404).json({ error: "Patient barcode not found in system" });
      }

      if (!barcode.isActive) {
        await logScanAttempt(false, "Barcode is inactive/expired", barcode.id);
        return res.status(400).json({ error: "This patient barcode is no longer active" });
      }

      // Log successful scan
      await logScanAttempt(true, undefined, barcode.id);

      // Fetch comprehensive patient data based on role
      const patientId = barcode.patientId;
      
      // Get monitoring sessions for this patient
      const sessions = await db.select().from(patientMonitoringSessions)
        .where(eq(patientMonitoringSessions.patientId, patientId))
        .orderBy(desc(patientMonitoringSessions.createdAt));
      
      const latestSession = sessions[0];

      // Get prescriptions
      const patientPrescriptions = await db.select().from(prescriptions)
        .where(eq(prescriptions.patientId, patientId));

      // Get allergies if session exists
      let allergies = null;
      if (latestSession) {
        const [allergyData] = await db.select().from(patientAllergiesPrecautions)
          .where(eq(patientAllergiesPrecautions.sessionId, latestSession.id));
        allergies = allergyData;
      }

      // Get latest vitals if session exists
      let latestVitals = null;
      if (latestSession) {
        const [vitals] = await db.select().from(vitalsHourly)
          .where(eq(vitalsHourly.sessionId, latestSession.id))
          .orderBy(desc(vitalsHourly.recordedAt))
          .limit(1);
        latestVitals = vitals;
      }

      // Prepare role-filtered response
      const baseData = {
        barcode: {
          id: barcode.id,
          uhid: barcode.uhid,
          admissionType: barcode.admissionType,
          wardBed: barcode.wardBed,
          treatingDoctor: barcode.treatingDoctor,
          createdAt: barcode.createdAt,
        },
        patient: {
          id: patientId,
          name: barcode.patientName,
          uhid: barcode.uhid,
          admissionType: barcode.admissionType,
          wardBed: barcode.wardBed,
          treatingDoctor: barcode.treatingDoctor,
          age: latestSession?.age,
          gender: latestSession?.gender,
          status: latestSession?.status || "active",
        },
        scanInfo: {
          scannedBy: user.name || user.username,
          scannedAt: new Date().toISOString(),
          role: user.role,
        }
      };

      // Role-based data visibility
      let responseData: any = { ...baseData };

      // NURSE: Vitals, medication administration, nursing notes
      if (user.role === "NURSE" || user.role === "DOCTOR" || user.role === "ADMIN") {
        responseData.vitals = latestVitals;
        responseData.allergies = allergies;
        responseData.monitoringSession = latestSession;
      }

      // ALL AUTHORIZED ROLES: Full access to prescriptions, sessions, and billing
      if (user.role === "DOCTOR" || user.role === "ADMIN" || user.role === "NURSE") {
        responseData.prescriptions = patientPrescriptions;
        responseData.allSessions = sessions;
        
        // Get billing data - full access for all authorized roles
        const bills = await databaseStorage.getPatientBills(patientId);
        responseData.billing = bills;
      }

      res.json(responseData);
    } catch (error) {
      console.error("Error scanning barcode:", error);
      res.status(500).json({ error: "Failed to scan barcode" });
    }
  });

  // Get all patient barcodes (for admin/authorized staff)
  app.get("/api/barcodes", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      
      if (!user || !BARCODE_ALLOWED_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }

      const barcodes = await db.select().from(patientBarcodes)
        .orderBy(desc(patientBarcodes.createdAt));
      
      res.json(barcodes);
    } catch (error) {
      console.error("Error fetching barcodes:", error);
      res.status(500).json({ error: "Failed to fetch barcodes" });
    }
  });

  // Get barcode by UHID
  app.get("/api/barcodes/uhid/:uhid", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      
      if (!user || !BARCODE_ALLOWED_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }

      const [barcode] = await db.select().from(patientBarcodes)
        .where(eq(patientBarcodes.uhid, req.params.uhid));
      
      if (!barcode) {
        return res.status(404).json({ error: "Barcode not found" });
      }

      res.json(barcode);
    } catch (error) {
      console.error("Error fetching barcode:", error);
      res.status(500).json({ error: "Failed to fetch barcode" });
    }
  });

  // Get barcode scan logs (audit trail)
  app.get("/api/barcode/scan-logs", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      
      if (!user || user.role !== "ADMIN") {
        return res.status(403).json({ error: "Only Admin can view scan logs" });
      }

      const logs = await db.select().from(barcodeScanLogs)
        .orderBy(desc(barcodeScanLogs.timestamp))
        .limit(100);
      
      res.json(logs);
    } catch (error) {
      console.error("Error fetching scan logs:", error);
      res.status(500).json({ error: "Failed to fetch scan logs" });
    }
  });

  // Generate barcode image as PNG
  app.get("/api/barcodes/image/:uhid", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      
      if (!user || !BARCODE_ALLOWED_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }

      const [barcode] = await db.select().from(patientBarcodes)
        .where(eq(patientBarcodes.uhid, req.params.uhid));
      
      if (!barcode) {
        return res.status(404).json({ error: "Barcode not found" });
      }

      // Generate encrypted token for scanning (HMAC signature for integrity)
      const encryptionSecret = process.env.BARCODE_SECRET || "hms-gravity-hospital-2025";
      const dataToSign = `${barcode.uhid}:${barcode.patientId}`;
      const signature = crypto.createHmac("sha256", encryptionSecret)
        .update(dataToSign)
        .digest("hex")
        .substring(0, 12);
      
      // Barcode content format: HMS:UHID:SIGNATURE
      const barcodeContent = `HMS:${barcode.uhid}:${signature}`;

      // Generate QR code (compact and easier to scan with camera)
      const png = await bwipjs.toBuffer({
        bcid: "qrcode",
        text: barcodeContent,
        scale: 4,
        eclevel: "M",
      });

      res.set("Content-Type", "image/png");
      res.set("Cache-Control", "public, max-age=3600");
      res.send(png);
    } catch (error) {
      console.error("Error generating barcode image:", error);
      res.status(500).json({ error: "Failed to generate barcode image" });
    }
  });

  // Deactivate a barcode (on discharge)
  app.patch("/api/barcodes/:id/deactivate", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      
      if (!user || !BARCODE_ALLOWED_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }

      const [updated] = await db.update(patientBarcodes)
        .set({ isActive: false })
        .where(eq(patientBarcodes.id, req.params.id))
        .returning();
      
      if (!updated) {
        return res.status(404).json({ error: "Barcode not found" });
      }

      res.json(updated);
    } catch (error) {
      console.error("Error deactivating barcode:", error);
      res.status(500).json({ error: "Failed to deactivate barcode" });
    }
  });

  // Bulk generate barcodes for all patients without one (Admin only)
  app.post("/api/barcodes/generate-all", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      
      if (!user || user.role !== "ADMIN") {
        return res.status(403).json({ error: "Only Admin can bulk generate barcodes" });
      }

      // Get all service patients
      const allPatients = await db.select().from(servicePatients);
      
      // Get existing barcodes
      const existingBarcodes = await db.select().from(patientBarcodes);
      const existingPatientIds = new Set(existingBarcodes.map(b => b.patientId));

      const newBarcodes = [];
      let ipdCount = existingBarcodes.filter(b => b.admissionType === "IPD").length;
      let opdCount = existingBarcodes.filter(b => b.admissionType === "OPD").length;

      for (const patient of allPatients) {
        if (!existingPatientIds.has(patient.id)) {
          // Alternate between IPD and OPD for demo purposes
          const admissionType = newBarcodes.length % 2 === 0 ? "IPD" : "OPD";
          const year = new Date().getFullYear();
          
          let count;
          if (admissionType === "IPD") {
            ipdCount++;
            count = ipdCount;
          } else {
            opdCount++;
            count = opdCount;
          }
          
          const prefix = admissionType === "IPD" ? "GRAV-IPD" : "GRAV-OPD";
          const uhid = `${prefix}-${year}-${count.toString().padStart(6, '0')}`;
          
          const patientName = `${patient.firstName} ${patient.lastName}`;
          const encryptedToken = generateEncryptedToken(patient.id, uhid);
          const barcodeData = `HMS:${uhid}:${encryptedToken.substring(0, 16)}`;

          const [barcode] = await db.insert(patientBarcodes).values({
            patientId: patient.id,
            patientName,
            uhid,
            admissionType,
            encryptedToken,
            barcodeData,
            wardBed: admissionType === "IPD" ? `Ward-${Math.floor(Math.random() * 5) + 1}/Bed-${Math.floor(Math.random() * 20) + 1}` : null,
            treatingDoctor: null,
            isActive: true,
          }).returning();

          newBarcodes.push(barcode);
        }
      }

      // Log bulk generation
      if (newBarcodes.length > 0) {
        await db.insert(barcodeScanLogs).values({
          barcodeId: newBarcodes[0].id,
          uhid: "BULK-GENERATION",
          scannedBy: user.id,
          scannedByName: user.name || user.username,
          role: user.role,
          allowed: true,
          ipAddress: req.ip || null,
          deviceInfo: `Bulk generated ${newBarcodes.length} barcodes`,
        });
      }

      res.json({
        message: `Generated ${newBarcodes.length} new barcodes`,
        totalPatients: allPatients.length,
        existingBarcodes: existingPatientIds.size,
        newBarcodes: newBarcodes.length,
        barcodes: newBarcodes,
      });
    } catch (error) {
      console.error("Error bulk generating barcodes:", error);
      res.status(500).json({ error: "Failed to bulk generate barcodes" });
    }
  });

  // Get all patients with their barcodes (for Admin view)
  app.get("/api/patients/with-barcodes", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      
      if (!user || !BARCODE_ALLOWED_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }

      // Get all service patients
      const allPatients = await db.select().from(servicePatients);
      
      // Get all barcodes
      const allBarcodes = await db.select().from(patientBarcodes)
        .orderBy(desc(patientBarcodes.createdAt));
      
      // Create a map of patient ID to barcode
      const barcodeMap = new Map();
      for (const barcode of allBarcodes) {
        if (!barcodeMap.has(barcode.patientId)) {
          barcodeMap.set(barcode.patientId, barcode);
        }
      }

      // Combine patient data with barcode data
      const patientsWithBarcodes = allPatients.map(patient => {
        const barcode = barcodeMap.get(patient.id);
        return {
          id: patient.id,
          name: `${patient.firstName} ${patient.lastName}`,
          firstName: patient.firstName,
          lastName: patient.lastName,
          gender: patient.gender,
          dateOfBirth: patient.dateOfBirth,
          phone: patient.phone,
          email: patient.email,
          address: patient.address,
          emergencyContact: patient.emergencyContact,
          emergencyPhone: patient.emergencyPhone,
          insuranceProvider: patient.insuranceProvider,
          insuranceNumber: patient.insuranceNumber,
          barcode: barcode ? {
            id: barcode.id,
            uhid: barcode.uhid,
            admissionType: barcode.admissionType,
            wardBed: barcode.wardBed,
            treatingDoctor: barcode.treatingDoctor,
            barcodeData: barcode.barcodeData,
            isActive: barcode.isActive,
            createdAt: barcode.createdAt,
          } : null,
          hasBarcode: !!barcode,
        };
      });

      res.json(patientsWithBarcodes);
    } catch (error) {
      console.error("Error fetching patients with barcodes:", error);
      res.status(500).json({ error: "Failed to fetch patients with barcodes" });
    }
  });

  // ========== STAFF MANAGEMENT MODULE ROUTES ==========

  const STAFF_MANAGEMENT_ADMIN_ROLES = ["ADMIN", "OPD_MANAGER"];
  const STAFF_MANAGEMENT_ALL_ROLES = ["ADMIN", "OPD_MANAGER", "DOCTOR", "NURSE", "MEDICAL_STORE", "PATHOLOGY_LAB"];

  // Staff Master CRUD
  app.get("/api/staff", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      const staff = await storage.getAllStaffMaster();
      res.json(staff);
    } catch (error) {
      console.error("Error fetching staff:", error);
      res.status(500).json({ error: "Failed to fetch staff" });
    }
  });

  app.get("/api/staff/me", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) return res.status(401).json({ error: "Unauthorized" });
      
      let staff = await storage.getStaffMasterByUserId(user.id);
      if (!staff && STAFF_MANAGEMENT_ALL_ROLES.includes(user.role)) {
        const empCode = `EMP${Date.now().toString().slice(-6)}`;
        staff = await storage.createStaffMaster({
          userId: user.id,
          employeeCode: empCode,
          fullName: user.name || user.username || "Staff Member",
          role: user.role,
          department: user.role === "DOCTOR" ? "OPD" : user.role === "NURSE" ? "NURSING" : "ADMIN",
          status: "ACTIVE",
        });
      }
      if (!staff) return res.status(404).json({ error: "Staff profile not found" });
      res.json(staff);
    } catch (error) {
      console.error("Error fetching staff profile:", error);
      res.status(500).json({ error: "Failed to fetch staff profile" });
    }
  });

  app.get("/api/staff/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) return res.status(401).json({ error: "Unauthorized" });
      
      const staff = await storage.getStaffMaster(req.params.id);
      if (!staff) return res.status(404).json({ error: "Staff not found" });
      
      // Staff can only see their own profile unless admin
      if (!STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role) && staff.userId !== user.id) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      res.json(staff);
    } catch (error) {
      console.error("Error fetching staff:", error);
      res.status(500).json({ error: "Failed to fetch staff" });
    }
  });

  app.get("/api/staff/user/:userId", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) return res.status(401).json({ error: "Unauthorized" });
      
      const staff = await storage.getStaffMasterByUserId(req.params.userId);
      if (!staff) return res.status(404).json({ error: "Staff profile not found" });
      
      // Staff can only see their own profile unless admin
      if (!STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role) && staff.userId !== user.id) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      res.json(staff);
    } catch (error) {
      console.error("Error fetching staff by user:", error);
      res.status(500).json({ error: "Failed to fetch staff profile" });
    }
  });

  app.get("/api/staff/department/:department", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      const staff = await storage.getStaffMasterByDepartment(req.params.department);
      res.json(staff);
    } catch (error) {
      console.error("Error fetching staff by department:", error);
      res.status(500).json({ error: "Failed to fetch staff" });
    }
  });

  app.get("/api/staff/role/:role", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      const staff = await storage.getStaffMasterByRole(req.params.role);
      res.json(staff);
    } catch (error) {
      console.error("Error fetching staff by role:", error);
      res.status(500).json({ error: "Failed to fetch staff" });
    }
  });

  app.post("/api/staff", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      console.log("POST /api/staff - Full session:", JSON.stringify(session));
      console.log("POST /api/staff - Session user:", user);
      console.log("POST /api/staff - User role:", user?.role, "User ID:", user?.id);
      console.log("POST /api/staff - Allowed roles:", STAFF_MANAGEMENT_ADMIN_ROLES);
      console.log("POST /api/staff - Role check:", user?.role, "in", STAFF_MANAGEMENT_ADMIN_ROLES, "=", user?.role && STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role));
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        console.log("POST /api/staff - Unauthorized: user role", user?.role, "not in", STAFF_MANAGEMENT_ADMIN_ROLES);
        return res.status(403).json({ error: "Unauthorized" });
      }
      console.log("POST /api/staff - Creating staff with:", req.body);
      const staff = await storage.createStaffMaster(req.body);
      res.status(201).json(staff);
    } catch (error) {
      console.error("Error creating staff:", error);
      res.status(500).json({ error: "Failed to create staff" });
    }
  });

  app.patch("/api/staff/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      const staff = await storage.updateStaffMaster(req.params.id, req.body);
      if (!staff) return res.status(404).json({ error: "Staff not found" });
      res.json(staff);
    } catch (error) {
      console.error("Error updating staff:", error);
      res.status(500).json({ error: "Failed to update staff" });
    }
  });

  app.delete("/api/staff/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || user.role !== "ADMIN") {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      // Get staff record before deletion to find linked user
      const staffRecord = await storage.getStaffMaster(req.params.id);
      if (!staffRecord) {
        return res.status(404).json({ error: "Staff not found" });
      }
      
      const linkedUserId = staffRecord.userId;
      const staffId = req.params.id;
      const staffName = staffRecord.fullName;
      const employeeCode = staffRecord.employeeCode;
      
      // CRITICAL: Cascade delete with proper ordering - revoke access FIRST, then delete records
      // Order: Sessions -> User -> Staff (reverse dependency order to ensure access is revoked immediately)
      if (linkedUserId) {
        try {
          // Step 1: Invalidate all sessions FIRST (immediate access revocation)
          await pool.query(`DELETE FROM session WHERE sess::jsonb->'user'->>'id' = $1`, [linkedUserId]);
          console.log(`Sessions invalidated for user ${linkedUserId}`);
          
          // Step 2: Delete the user account (prevents new logins)
          await databaseStorage.deleteUser(linkedUserId);
          console.log(`User account ${linkedUserId} deleted due to staff removal`);
          
          // Step 3: Delete the staff record
          const deleted = await storage.deleteStaffMaster(staffId);
          if (!deleted) {
            // Staff record deletion failed - log and return error so admin knows to retry
            await storage.createActivityLog({
              action: "STAFF_DELETE_PARTIAL_FAILURE",
              entityType: "staff",
              entityId: staffId,
              performedBy: user.name || user.username,
              performedByRole: user.role,
              details: `User account and sessions for ${staffName} were deleted, but staff record deletion failed. Access revoked but staff record remains.`,
              activityType: "warning"
            });
            return res.status(500).json({ 
              error: "User access revoked but staff record cleanup failed. Please retry or contact administrator." 
            });
          }
          
          // Create audit log for successful cascading deletion
          await storage.createActivityLog({
            action: "STAFF_DELETED_CASCADE",
            entityType: "staff",
            entityId: staffId,
            performedBy: user.name || user.username,
            performedByRole: user.role,
            details: `Staff member ${staffName} (${employeeCode}) removed - user account ${linkedUserId} and all sessions deleted`,
            activityType: "urgent"
          });
          
          res.json({ success: true, message: "Staff member, user account, and all sessions deleted successfully" });
        } catch (cascadeError) {
          console.error("Error during cascade deletion:", cascadeError);
          // Log the failure and return error - access revocation failed
          try {
            await storage.createActivityLog({
              action: "STAFF_DELETE_CASCADE_FAILED",
              entityType: "staff",
              entityId: staffId,
              performedBy: user.name || user.username,
              performedByRole: user.role,
              details: `Staff ${staffName} cascade deletion failed: ${(cascadeError as Error).message}. Manual cleanup required.`,
              activityType: "warning"
            });
          } catch {}
          return res.status(500).json({ 
            error: "Failed to fully revoke staff access. Please contact system administrator for manual cleanup." 
          });
        }
      } else {
        // No linked user - just delete the staff record
        const deleted = await storage.deleteStaffMaster(staffId);
        if (!deleted) return res.status(404).json({ error: "Staff not found" });
        
        await storage.createActivityLog({
          action: "STAFF_DELETED",
          entityType: "staff",
          entityId: staffId,
          performedBy: user.name || user.username,
          performedByRole: user.role,
          details: `Staff member ${staffName} (${employeeCode}) removed (no linked user account)`,
          activityType: "info"
        });
        
        res.json({ success: true, message: "Staff member deleted successfully" });
      }
    } catch (error) {
      console.error("Error deleting staff:", error);
      res.status(500).json({ error: "Failed to delete staff" });
    }
  });

  // Shift Roster Routes
  app.get("/api/roster", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ALL_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const { startDate, endDate, department } = req.query;
      let roster;
      
      if (startDate && endDate) {
        roster = await storage.getShiftRosterByDateRange(startDate as string, endDate as string);
      } else if (department) {
        roster = await storage.getShiftRosterByDepartment(department as string);
      } else {
        roster = await storage.getAllShiftRoster();
      }
      res.json(roster);
    } catch (error) {
      console.error("Error fetching roster:", error);
      res.status(500).json({ error: "Failed to fetch roster" });
    }
  });

  app.get("/api/roster/date/:date", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ALL_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      const roster = await storage.getShiftRosterByDate(req.params.date);
      res.json(roster);
    } catch (error) {
      console.error("Error fetching roster by date:", error);
      res.status(500).json({ error: "Failed to fetch roster" });
    }
  });

  app.get("/api/roster/staff/:staffId", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) return res.status(401).json({ error: "Unauthorized" });
      
      // Staff can see their own roster
      const staffProfile = await storage.getStaffMasterByUserId(user.id);
      if (!STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role) && 
          (!staffProfile || staffProfile.id !== req.params.staffId)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const roster = await storage.getShiftRosterByStaff(req.params.staffId);
      res.json(roster);
    } catch (error) {
      console.error("Error fetching staff roster:", error);
      res.status(500).json({ error: "Failed to fetch staff roster" });
    }
  });

  app.get("/api/roster/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ALL_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      const roster = await storage.getShiftRoster(req.params.id);
      if (!roster) return res.status(404).json({ error: "Shift not found" });
      res.json(roster);
    } catch (error) {
      console.error("Error fetching shift:", error);
      res.status(500).json({ error: "Failed to fetch shift" });
    }
  });

  app.post("/api/roster", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      // Check for overlapping shifts
      const existingShifts = await storage.getShiftRosterByStaff(req.body.staffId);
      const newDate = req.body.shiftDate;
      const newStart = req.body.startTime;
      const newEnd = req.body.endTime;
      
      const hasConflict = existingShifts.some(shift => {
        if (shift.shiftDate !== newDate) return false;
        // Simple time overlap check
        return !(newEnd <= shift.startTime || newStart >= shift.endTime);
      });
      
      if (hasConflict && !req.body.overrideReason) {
        return res.status(400).json({ error: "Shift conflict detected. Provide override reason to proceed." });
      }
      
      const roster = await storage.createShiftRoster({
        ...req.body,
        assignedBy: user.id,
      });
      
      // Create audit log
      await storage.createRosterAuditLog({
        rosterId: roster.id,
        action: "CREATED",
        changedBy: user.id,
        changedByName: user.name || user.username,
        newValue: JSON.stringify(roster),
        reason: req.body.overrideReason,
      });
      
      // Notify staff member of new shift assignment
      const staffMember = await storage.getStaffMaster(req.body.staffId);
      if (staffMember?.userId) {
        await notificationService.notifyRosterUpdated(
          staffMember.userId,
          staffMember.fullName,
          "assigned",
          roster.shiftDate,
          roster.shiftType
        );
      }
      
      res.status(201).json(roster);
    } catch (error) {
      console.error("Error creating shift:", error);
      res.status(500).json({ error: "Failed to create shift" });
    }
  });

  app.patch("/api/roster/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const existingRoster = await storage.getShiftRoster(req.params.id);
      if (!existingRoster) return res.status(404).json({ error: "Shift not found" });
      
      const roster = await storage.updateShiftRoster(req.params.id, req.body);
      
      // Create audit log
      await storage.createRosterAuditLog({
        rosterId: roster!.id,
        action: "UPDATED",
        changedBy: user.id,
        changedByName: user.name || user.username,
        previousValue: JSON.stringify(existingRoster),
        newValue: JSON.stringify(roster),
        reason: req.body.updateReason,
      });
      
      // Notify staff member of shift update
      const staffMember = await storage.getStaffMaster(roster!.staffId);
      if (staffMember?.userId) {
        await notificationService.notifyRosterUpdated(
          staffMember.userId,
          staffMember.fullName,
          "updated",
          roster!.shiftDate,
          roster!.shiftType
        );
      }
      
      res.json(roster);
    } catch (error) {
      console.error("Error updating shift:", error);
      res.status(500).json({ error: "Failed to update shift" });
    }
  });

  app.delete("/api/roster/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const existingRoster = await storage.getShiftRoster(req.params.id);
      if (!existingRoster) return res.status(404).json({ error: "Shift not found" });
      
      // Create audit log before deletion
      await storage.createRosterAuditLog({
        rosterId: req.params.id,
        action: "DELETED",
        changedBy: user.id,
        changedByName: user.name || user.username,
        previousValue: JSON.stringify(existingRoster),
        reason: req.body.deleteReason,
      });
      
      // Notify staff member of shift removal
      const staffMember = await storage.getStaffMaster(existingRoster.staffId);
      if (staffMember?.userId) {
        await notificationService.notifyRosterUpdated(
          staffMember.userId,
          staffMember.fullName,
          "removed",
          existingRoster.shiftDate,
          existingRoster.shiftType
        );
      }
      
      const deleted = await storage.deleteShiftRoster(req.params.id);
      res.json({ success: deleted });
    } catch (error) {
      console.error("Error deleting shift:", error);
      res.status(500).json({ error: "Failed to delete shift" });
    }
  });

  // Task Logs Routes
  app.get("/api/tasks", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ALL_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      if (STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        const tasks = await storage.getAllTaskLogs();
        return res.json(tasks);
      }
      
      // Non-admin staff can only see their own tasks
      const staffProfile = await storage.getStaffMasterByUserId(user.id);
      if (!staffProfile) return res.json([]);
      
      const tasks = await storage.getTaskLogsByStaff(staffProfile.id);
      res.json(tasks);
    } catch (error) {
      console.error("Error fetching tasks:", error);
      res.status(500).json({ error: "Failed to fetch tasks" });
    }
  });

  app.get("/api/tasks/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) return res.status(401).json({ error: "Unauthorized" });
      
      const task = await storage.getTaskLog(req.params.id);
      if (!task) return res.status(404).json({ error: "Task not found" });
      res.json(task);
    } catch (error) {
      console.error("Error fetching task:", error);
      res.status(500).json({ error: "Failed to fetch task" });
    }
  });

  app.get("/api/tasks/staff/:staffId", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) return res.status(401).json({ error: "Unauthorized" });
      
      const tasks = await storage.getTaskLogsByStaff(req.params.staffId);
      res.json(tasks);
    } catch (error) {
      console.error("Error fetching staff tasks:", error);
      res.status(500).json({ error: "Failed to fetch tasks" });
    }
  });

  app.post("/api/tasks", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ALL_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const task = await storage.createTaskLog({
        ...req.body,
        assignedBy: req.body.assignedBy || user.id,
      });
      res.status(201).json(task);
    } catch (error) {
      console.error("Error creating task:", error);
      res.status(500).json({ error: "Failed to create task" });
    }
  });

  app.patch("/api/tasks/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ALL_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const task = await storage.updateTaskLog(req.params.id, req.body);
      if (!task) return res.status(404).json({ error: "Task not found" });
      res.json(task);
    } catch (error) {
      console.error("Error updating task:", error);
      res.status(500).json({ error: "Failed to update task" });
    }
  });

  // Attendance Routes
  app.get("/api/attendance", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const { date } = req.query;
      if (date) {
        const attendance = await storage.getAttendanceLogsByDate(date as string);
        return res.json(attendance);
      }
      
      const attendance = await storage.getAllAttendanceLogs();
      res.json(attendance);
    } catch (error) {
      console.error("Error fetching attendance:", error);
      res.status(500).json({ error: "Failed to fetch attendance" });
    }
  });

  app.get("/api/attendance/staff/:staffId", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) return res.status(401).json({ error: "Unauthorized" });
      
      const attendance = await storage.getAttendanceLogsByStaff(req.params.staffId);
      res.json(attendance);
    } catch (error) {
      console.error("Error fetching staff attendance:", error);
      res.status(500).json({ error: "Failed to fetch attendance" });
    }
  });

  app.post("/api/attendance/check-in", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ALL_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      let staffProfile = await storage.getStaffMasterByUserId(user.id);
      if (!staffProfile) {
        const empCode = `EMP${Date.now().toString().slice(-6)}`;
        staffProfile = await storage.createStaffMaster({
          userId: user.id,
          employeeCode: empCode,
          fullName: user.name || user.username || "Staff Member",
          role: user.role,
          department: user.role === "DOCTOR" ? "OPD" : user.role === "NURSE" ? "NURSING" : "ADMIN",
          status: "ACTIVE",
        });
      }
      
      const today = new Date().toISOString().split('T')[0];
      const existing = await storage.getAttendanceLogByStaffAndDate(staffProfile.id, today);
      
      if (existing) {
        return res.status(400).json({ error: "Already checked in today" });
      }
      
      const attendance = await storage.createAttendanceLog({
        staffId: staffProfile.id,
        date: today,
        checkInTime: new Date(),
        checkInMethod: req.body.method || "MANUAL",
        status: "PRESENT",
      });
      
      res.status(201).json(attendance);
    } catch (error) {
      console.error("Error checking in:", error);
      res.status(500).json({ error: "Failed to check in" });
    }
  });

  app.post("/api/attendance/check-out", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ALL_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      let staffProfile = await storage.getStaffMasterByUserId(user.id);
      if (!staffProfile) {
        const empCode = `EMP${Date.now().toString().slice(-6)}`;
        staffProfile = await storage.createStaffMaster({
          userId: user.id,
          employeeCode: empCode,
          fullName: user.name || user.username || "Staff Member",
          role: user.role,
          department: user.role === "DOCTOR" ? "OPD" : user.role === "NURSE" ? "NURSING" : "ADMIN",
          status: "ACTIVE",
        });
      }
      
      const today = new Date().toISOString().split('T')[0];
      const existing = await storage.getAttendanceLogByStaffAndDate(staffProfile.id, today);
      
      if (!existing) {
        return res.status(400).json({ error: "No check-in found for today" });
      }
      
      if (existing.checkOutTime) {
        return res.status(400).json({ error: "Already checked out today" });
      }
      
      const checkOutTime = new Date();
      const checkInTime = existing.checkInTime ? new Date(existing.checkInTime) : new Date();
      const workHours = ((checkOutTime.getTime() - checkInTime.getTime()) / (1000 * 60 * 60)).toFixed(2);
      
      const attendance = await storage.updateAttendanceLog(existing.id, {
        checkOutTime,
        checkOutMethod: req.body.method || "MANUAL",
        workHours,
      });
      
      res.json(attendance);
    } catch (error) {
      console.error("Error checking out:", error);
      res.status(500).json({ error: "Failed to check out" });
    }
  });

  app.post("/api/attendance", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const attendance = await storage.createAttendanceLog(req.body);
      res.status(201).json(attendance);
    } catch (error) {
      console.error("Error creating attendance:", error);
      res.status(500).json({ error: "Failed to create attendance record" });
    }
  });

  app.patch("/api/attendance/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const attendance = await storage.updateAttendanceLog(req.params.id, {
        ...req.body,
        approvedBy: user.id,
      });
      if (!attendance) return res.status(404).json({ error: "Attendance record not found" });
      res.json(attendance);
    } catch (error) {
      console.error("Error updating attendance:", error);
      res.status(500).json({ error: "Failed to update attendance" });
    }
  });

  // Leave Request Routes
  app.get("/api/leave", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) return res.status(401).json({ error: "Unauthorized" });
      
      if (STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        const { status } = req.query;
        if (status) {
          const leaves = await storage.getLeaveRequestsByStatus(status as string);
          return res.json(leaves);
        }
        const leaves = await storage.getAllLeaveRequests();
        return res.json(leaves);
      }
      
      // Staff can only see their own leave requests
      const staffProfile = await storage.getStaffMasterByUserId(user.id);
      if (!staffProfile) return res.json([]);
      
      const leaves = await storage.getLeaveRequestsByStaff(staffProfile.id);
      res.json(leaves);
    } catch (error) {
      console.error("Error fetching leave requests:", error);
      res.status(500).json({ error: "Failed to fetch leave requests" });
    }
  });

  app.get("/api/leave/pending", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const leaves = await storage.getPendingLeaveRequests();
      res.json(leaves);
    } catch (error) {
      console.error("Error fetching pending leaves:", error);
      res.status(500).json({ error: "Failed to fetch pending leave requests" });
    }
  });

  app.get("/api/leave/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) return res.status(401).json({ error: "Unauthorized" });
      
      const leave = await storage.getLeaveRequest(req.params.id);
      if (!leave) return res.status(404).json({ error: "Leave request not found" });
      res.json(leave);
    } catch (error) {
      console.error("Error fetching leave request:", error);
      res.status(500).json({ error: "Failed to fetch leave request" });
    }
  });

  app.post("/api/leave", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ALL_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      let staffProfile = await storage.getStaffMasterByUserId(user.id);
      if (!staffProfile) {
        const empCode = `EMP${Date.now().toString().slice(-6)}`;
        staffProfile = await storage.createStaffMaster({
          userId: user.id,
          employeeCode: empCode,
          fullName: user.name || user.username || "Staff Member",
          role: user.role,
          department: user.role === "DOCTOR" ? "OPD" : user.role === "NURSE" ? "NURSING" : "ADMIN",
          status: "ACTIVE",
        });
      }
      
      const { startDate, endDate, leaveType, reason } = req.body;
      const start = new Date(startDate);
      const end = new Date(endDate);
      const totalDays = Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24)) + 1;
      
      const leave = await storage.createLeaveRequest({
        staffId: staffProfile.id,
        leaveType,
        startDate,
        endDate,
        reason,
        totalDays,
        status: "PENDING",
      });
      res.status(201).json(leave);
    } catch (error) {
      console.error("Error creating leave request:", error);
      res.status(500).json({ error: "Failed to create leave request" });
    }
  });

  app.patch("/api/leave/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) return res.status(401).json({ error: "Unauthorized" });
      
      const { action } = req.body;
      let updates: any = {};
      
      const existingLeave = await storage.getLeaveRequest(req.params.id);
      if (!existingLeave) return res.status(404).json({ error: "Leave request not found" });
      
      if (action === "approve") {
        if (!STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
          return res.status(403).json({ error: "Unauthorized" });
        }
        updates = {
          status: "APPROVED",
          hrApprovedBy: user.id,
          hrApprovedAt: new Date(),
        };
      } else if (action === "reject") {
        if (!STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
          return res.status(403).json({ error: "Unauthorized" });
        }
        updates = {
          status: "REJECTED",
          rejectedBy: user.id,
          rejectionReason: req.body.reason,
        };
      } else if (action === "cancel") {
        const staffProfile = await storage.getStaffMasterByUserId(user.id);
        if (!staffProfile || existingLeave.staffId !== staffProfile.id) {
          return res.status(403).json({ error: "Cannot cancel this leave request" });
        }
        updates = { status: "CANCELLED" };
      } else {
        updates = req.body;
      }
      
      const leave = await storage.updateLeaveRequest(req.params.id, updates);
      if (!leave) return res.status(404).json({ error: "Leave request not found" });
      
      if (action === "approve" || action === "reject") {
        const staffProfile = await storage.getStaffMaster(existingLeave.staffId);
        if (staffProfile?.userId) {
          const startDate = typeof existingLeave.startDate === 'string' 
            ? existingLeave.startDate 
            : new Date(existingLeave.startDate).toLocaleDateString();
          const endDate = typeof existingLeave.endDate === 'string' 
            ? existingLeave.endDate 
            : new Date(existingLeave.endDate).toLocaleDateString();
          
          await notificationService.notifyLeaveStatusUpdated(
            staffProfile.userId,
            staffProfile.fullName,
            leave.id,
            updates.status,
            existingLeave.leaveType,
            startDate,
            endDate,
            req.body.reason
          );
        }
      }
      
      res.json(leave);
    } catch (error) {
      console.error("Error updating leave request:", error);
      res.status(500).json({ error: "Failed to update leave request" });
    }
  });

  // Overtime Routes
  app.get("/api/overtime", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) return res.status(401).json({ error: "Unauthorized" });
      
      if (STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        const { status } = req.query;
        if (status) {
          const overtime = await storage.getOvertimeLogsByStatus(status as string);
          return res.json(overtime);
        }
        const overtime = await storage.getAllOvertimeLogs();
        return res.json(overtime);
      }
      
      const staffProfile = await storage.getStaffMasterByUserId(user.id);
      if (!staffProfile) return res.json([]);
      
      const overtime = await storage.getOvertimeLogsByStaff(staffProfile.id);
      res.json(overtime);
    } catch (error) {
      console.error("Error fetching overtime logs:", error);
      res.status(500).json({ error: "Failed to fetch overtime logs" });
    }
  });

  app.get("/api/overtime/pending", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const overtime = await storage.getPendingOvertimeLogs();
      res.json(overtime);
    } catch (error) {
      console.error("Error fetching pending overtime:", error);
      res.status(500).json({ error: "Failed to fetch pending overtime" });
    }
  });

  app.post("/api/overtime", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ALL_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const overtime = await storage.createOvertimeLog(req.body);
      res.status(201).json(overtime);
    } catch (error) {
      console.error("Error creating overtime log:", error);
      res.status(500).json({ error: "Failed to create overtime log" });
    }
  });

  app.patch("/api/overtime/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const { action } = req.body;
      let updates: any = {};
      
      if (action === "approve") {
        updates = {
          status: "APPROVED",
          approvedBy: user.id,
          approvedAt: new Date(),
        };
      } else if (action === "reject") {
        updates = { status: "REJECTED" };
      } else {
        updates = req.body;
      }
      
      const overtime = await storage.updateOvertimeLog(req.params.id, updates);
      if (!overtime) return res.status(404).json({ error: "Overtime log not found" });
      res.json(overtime);
    } catch (error) {
      console.error("Error updating overtime log:", error);
      res.status(500).json({ error: "Failed to update overtime log" });
    }
  });

  // Performance Metrics Routes
  app.get("/api/performance", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const metrics = await storage.getAllStaffPerformanceMetrics();
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching performance metrics:", error);
      res.status(500).json({ error: "Failed to fetch performance metrics" });
    }
  });

  app.get("/api/performance/staff/:staffId", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) return res.status(401).json({ error: "Unauthorized" });
      
      const metrics = await storage.getStaffPerformanceMetricsByStaff(req.params.staffId);
      res.json(metrics);
    } catch (error) {
      console.error("Error fetching staff performance:", error);
      res.status(500).json({ error: "Failed to fetch performance metrics" });
    }
  });

  app.post("/api/performance", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const metric = await storage.createStaffPerformanceMetric({
        ...req.body,
        evaluatedBy: user.id,
      });
      res.status(201).json(metric);
    } catch (error) {
      console.error("Error creating performance metric:", error);
      res.status(500).json({ error: "Failed to create performance metric" });
    }
  });

  app.patch("/api/performance/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const metric = await storage.updateStaffPerformanceMetric(req.params.id, req.body);
      if (!metric) return res.status(404).json({ error: "Performance metric not found" });
      res.json(metric);
    } catch (error) {
      console.error("Error updating performance metric:", error);
      res.status(500).json({ error: "Failed to update performance metric" });
    }
  });

  // Roster Audit Logs
  app.get("/api/roster-audit", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || user.role !== "ADMIN") {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const logs = await storage.getAllRosterAuditLogs();
      res.json(logs);
    } catch (error) {
      console.error("Error fetching roster audit logs:", error);
      res.status(500).json({ error: "Failed to fetch audit logs" });
    }
  });

  app.get("/api/roster-audit/:rosterId", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const logs = await storage.getRosterAuditLogsByRoster(req.params.rosterId);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching roster audit logs:", error);
      res.status(500).json({ error: "Failed to fetch audit logs" });
    }
  });

  // Sync doctor appointments with roster - create shifts from doctor schedules
  app.post("/api/roster/sync-appointments", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const { date, doctorId } = req.body;
      
      // Get all doctor time slots for the specified date
      const allTimeSlots = await storage.getAllDoctorTimeSlots();
      const dateSlots = allTimeSlots.filter(slot => {
        if (slot.date !== date) return false;
        if (doctorId && slot.doctorId !== doctorId) return false;
        return true;
      });
      
      const createdShifts = [];
      
      for (const slot of dateSlots) {
        // Check if staff profile exists for this doctor
        const staffProfile = await storage.getStaffMasterByUserId(slot.doctorId);
        if (!staffProfile) continue;
        
        // Check if shift already exists
        const existingShifts = await storage.getShiftRosterByStaff(staffProfile.id);
        const hasExisting = existingShifts.some(s => 
          s.shiftDate === slot.date && 
          s.startTime === slot.startTime &&
          s.linkedAppointmentId === slot.id
        );
        
        if (hasExisting) continue;
        
        // Create shift from appointment slot
        const shift = await storage.createShiftRoster({
          staffId: staffProfile.id,
          department: staffProfile.department || "OPD",
          shiftDate: slot.date,
          shiftType: slot.slotType === "OPD" ? "MORNING" : "ON_CALL",
          startTime: slot.startTime,
          endTime: slot.endTime,
          status: slot.status === "booked" ? "SCHEDULED" : "SCHEDULED",
          assignedBy: user.id,
          linkedAppointmentId: slot.id,
          notes: `Auto-synced from appointment slot ${slot.id}`,
        });
        
        createdShifts.push(shift);
      }
      
      res.json({ 
        success: true, 
        message: `Created ${createdShifts.length} shifts from appointment slots`,
        shifts: createdShifts 
      });
    } catch (error) {
      console.error("Error syncing appointments:", error);
      res.status(500).json({ error: "Failed to sync appointments with roster" });
    }
  });

  // Analytics endpoint for department-wise staff metrics
  app.get("/api/analytics/staff", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !STAFF_MANAGEMENT_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const { startDate, endDate, department } = req.query;
      
      // Get all staff
      const allStaff = await storage.getAllStaffMaster();
      const filteredStaff = department 
        ? allStaff.filter(s => s.department === department)
        : allStaff;
      
      // Get roster data
      let rosterData;
      if (startDate && endDate) {
        rosterData = await storage.getShiftRosterByDateRange(startDate as string, endDate as string);
      } else {
        rosterData = await storage.getAllShiftRoster();
      }
      
      // Calculate analytics
      const staffCount = filteredStaff.length;
      const activeStaff = filteredStaff.filter(s => s.status === "ACTIVE").length;
      const onLeaveStaff = filteredStaff.filter(s => s.status === "ON_LEAVE").length;
      
      const shiftsByType = {
        MORNING: rosterData.filter(r => r.shiftType === "MORNING").length,
        EVENING: rosterData.filter(r => r.shiftType === "EVENING").length,
        NIGHT: rosterData.filter(r => r.shiftType === "NIGHT").length,
        ON_CALL: rosterData.filter(r => r.shiftType === "ON_CALL").length,
      };
      
      const shiftStatus = {
        SCHEDULED: rosterData.filter(r => r.status === "SCHEDULED").length,
        COMPLETED: rosterData.filter(r => r.status === "COMPLETED").length,
        MISSED: rosterData.filter(r => r.status === "MISSED").length,
        CANCELLED: rosterData.filter(r => r.status === "CANCELLED").length,
      };
      
      // Get leave and overtime data
      const pendingLeaves = await storage.getPendingLeaveRequests();
      const pendingOvertime = await storage.getPendingOvertimeLogs();
      
      // Department breakdown
      const departments = [...new Set(allStaff.map(s => s.department).filter(Boolean))];
      const departmentBreakdown = departments.map(dept => ({
        department: dept,
        staffCount: allStaff.filter(s => s.department === dept).length,
        activeCount: allStaff.filter(s => s.department === dept && s.status === "ACTIVE").length,
      }));
      
      res.json({
        summary: {
          totalStaff: staffCount,
          activeStaff,
          onLeaveStaff,
          totalShifts: rosterData.length,
          pendingLeaveRequests: pendingLeaves.length,
          pendingOvertimeApprovals: pendingOvertime.length,
        },
        shiftsByType,
        shiftStatus,
        departmentBreakdown,
      });
    } catch (error) {
      console.error("Error fetching staff analytics:", error);
      res.status(500).json({ error: "Failed to fetch analytics" });
    }
  });

  // ==================== INSURANCE MANAGEMENT ROUTES ====================
  const INSURANCE_ADMIN_ROLES = ["ADMIN"];
  const INSURANCE_VIEW_ROLES = ["ADMIN", "PATIENT", "DOCTOR", "NURSE", "OPD_MANAGER"];
  const INSURANCE_PROCESS_ROLES = ["ADMIN"]; // Insurance Desk role can be added

  // Generate unique claim number
  function generateClaimNumber(): string {
    const timestamp = Date.now().toString(36).toUpperCase();
    const random = Math.random().toString(36).substring(2, 6).toUpperCase();
    return `CLM-${timestamp}-${random}`;
  }

  // ===== INSURANCE PROVIDERS (Admin CRUD) =====
  
  // Get all insurance providers (Admin sees all, others see active only)
  app.get("/api/insurance/providers", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      if (INSURANCE_ADMIN_ROLES.includes(user.role)) {
        const providers = await storage.getAllInsuranceProviders();
        res.json(providers);
      } else {
        const providers = await storage.getActiveInsuranceProviders();
        res.json(providers);
      }
    } catch (error) {
      console.error("Error fetching insurance providers:", error);
      res.status(500).json({ error: "Failed to fetch providers" });
    }
  });

  // Get single insurance provider
  app.get("/api/insurance/providers/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const provider = await storage.getInsuranceProvider(req.params.id);
      if (!provider) {
        return res.status(404).json({ error: "Provider not found" });
      }
      res.json(provider);
    } catch (error) {
      console.error("Error fetching provider:", error);
      res.status(500).json({ error: "Failed to fetch provider" });
    }
  });

  // Create insurance provider (Admin only)
  app.post("/api/insurance/providers", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !INSURANCE_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized - Admin access required" });
      }
      
      const provider = await storage.createInsuranceProvider({
        ...req.body,
        createdByAdminId: user.id,
      });
      res.status(201).json(provider);
    } catch (error) {
      console.error("Error creating provider:", error);
      res.status(500).json({ error: "Failed to create provider" });
    }
  });

  // Update insurance provider (Admin only)
  app.patch("/api/insurance/providers/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !INSURANCE_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized - Admin access required" });
      }
      
      const provider = await storage.updateInsuranceProvider(req.params.id, req.body);
      if (!provider) {
        return res.status(404).json({ error: "Provider not found" });
      }
      res.json(provider);
    } catch (error) {
      console.error("Error updating provider:", error);
      res.status(500).json({ error: "Failed to update provider" });
    }
  });

  // Deactivate insurance provider (Admin only - soft delete)
  app.delete("/api/insurance/providers/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !INSURANCE_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized - Admin access required" });
      }
      
      const provider = await storage.deactivateInsuranceProvider(req.params.id);
      if (!provider) {
        return res.status(404).json({ error: "Provider not found" });
      }
      res.json({ success: true, message: "Provider deactivated" });
    } catch (error) {
      console.error("Error deactivating provider:", error);
      res.status(500).json({ error: "Failed to deactivate provider" });
    }
  });

  // ===== PATIENT INSURANCE =====
  
  // Get patient's insurance policies
  app.get("/api/insurance/patient/:patientId", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      // Patients can only see their own, others with view role can see any
      if (user.role === "PATIENT" && user.id !== req.params.patientId) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const insurance = await storage.getPatientInsuranceByPatient(req.params.patientId);
      res.json(insurance);
    } catch (error) {
      console.error("Error fetching patient insurance:", error);
      res.status(500).json({ error: "Failed to fetch insurance" });
    }
  });

  // Add patient insurance
  app.post("/api/insurance/patient", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const insurance = await storage.createPatientInsurance(req.body);
      res.status(201).json(insurance);
    } catch (error) {
      console.error("Error creating patient insurance:", error);
      res.status(500).json({ error: "Failed to add insurance" });
    }
  });

  // Update patient insurance
  app.patch("/api/insurance/patient/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const insurance = await storage.updatePatientInsurance(req.params.id, req.body);
      if (!insurance) {
        return res.status(404).json({ error: "Insurance not found" });
      }
      res.json(insurance);
    } catch (error) {
      console.error("Error updating patient insurance:", error);
      res.status(500).json({ error: "Failed to update insurance" });
    }
  });

  // ===== INSURANCE CLAIMS =====
  
  // Get all claims (Admin/Insurance Desk)
  app.get("/api/insurance/claims", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !INSURANCE_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const { status } = req.query;
      let claims;
      if (status) {
        claims = await storage.getInsuranceClaimsByStatus(status as string);
      } else {
        claims = await storage.getAllInsuranceClaims();
      }
      res.json(claims);
    } catch (error) {
      console.error("Error fetching claims:", error);
      res.status(500).json({ error: "Failed to fetch claims" });
    }
  });

  // Get patient's claims
  app.get("/api/insurance/claims/patient/:patientId", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      if (user.role === "PATIENT" && user.id !== req.params.patientId) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const claims = await storage.getInsuranceClaimsByPatient(req.params.patientId);
      res.json(claims);
    } catch (error) {
      console.error("Error fetching patient claims:", error);
      res.status(500).json({ error: "Failed to fetch claims" });
    }
  });

  // Get single claim with documents and logs
  app.get("/api/insurance/claims/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const claim = await storage.getInsuranceClaim(req.params.id);
      if (!claim) {
        return res.status(404).json({ error: "Claim not found" });
      }
      
      const documents = await storage.getClaimDocuments(req.params.id);
      const logs = await storage.getClaimLogs(req.params.id);
      
      res.json({ claim, documents, logs });
    } catch (error) {
      console.error("Error fetching claim:", error);
      res.status(500).json({ error: "Failed to fetch claim" });
    }
  });

  // Create new claim
  app.post("/api/insurance/claims", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const claimNumber = generateClaimNumber();
      const claim = await storage.createInsuranceClaim({
        ...req.body,
        claimNumber,
        submittedBy: user.id,
      });
      
      // Create audit log
      await storage.createClaimLog({
        claimId: claim.id,
        actionType: "CREATED",
        performedByRole: user.role,
        performedById: user.id,
        performedByName: user.name || user.username,
        newValue: JSON.stringify({ status: claim.status, claimNumber }),
        remarks: "Claim created",
      });
      
      // Send WebSocket notification to admins for new claim
      notificationService.broadcast({
        type: "insurance_claim_submitted",
        claimId: claim.id,
        claimNumber: claim.claimNumber,
        patientId: claim.patientId,
        claimType: claim.claimType,
        status: claim.status,
        timestamp: new Date().toISOString(),
      });
      
      res.status(201).json(claim);
    } catch (error) {
      console.error("Error creating claim:", error);
      res.status(500).json({ error: "Failed to create claim" });
    }
  });

  // Update claim (status changes, processing)
  app.patch("/api/insurance/claims/:id", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const existingClaim = await storage.getInsuranceClaim(req.params.id);
      if (!existingClaim) {
        return res.status(404).json({ error: "Claim not found" });
      }
      
      const previousStatus = existingClaim.status;
      const updates: any = { ...req.body };
      
      // Set processed info for status changes
      if (req.body.status && req.body.status !== previousStatus) {
        updates.processedBy = user.id;
        updates.processedAt = new Date();
        
        if (req.body.status === "SETTLED") {
          updates.settledAt = new Date();
        }
      }
      
      const claim = await storage.updateInsuranceClaim(req.params.id, updates);
      
      // Create audit log for status change
      if (req.body.status && req.body.status !== previousStatus) {
        await storage.createClaimLog({
          claimId: req.params.id,
          actionType: "STATUS_CHANGED",
          performedByRole: user.role,
          performedById: user.id,
          performedByName: user.name || user.username,
          previousValue: previousStatus,
          newValue: req.body.status,
          remarks: req.body.remarks || `Status changed from ${previousStatus} to ${req.body.status}`,
        });
      }
      
      res.json(claim);
    } catch (error) {
      console.error("Error updating claim:", error);
      res.status(500).json({ error: "Failed to update claim" });
    }
  });

  // ===== CLAIM DOCUMENTS =====
  
  // Upload document to claim
  app.post("/api/insurance/claims/:claimId/documents", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const claim = await storage.getInsuranceClaim(req.params.claimId);
      if (!claim) {
        return res.status(404).json({ error: "Claim not found" });
      }
      
      const document = await storage.createClaimDocument({
        claimId: req.params.claimId,
        ...req.body,
        uploadedBy: user.id,
        uploadedByRole: user.role,
      });
      
      // Create audit log
      await storage.createClaimLog({
        claimId: req.params.claimId,
        actionType: "DOCUMENT_UPLOADED",
        performedByRole: user.role,
        performedById: user.id,
        performedByName: user.name || user.username,
        newValue: JSON.stringify({ documentType: req.body.documentType, documentName: req.body.documentName }),
        remarks: `Document uploaded: ${req.body.documentType}`,
      });
      
      res.status(201).json(document);
    } catch (error) {
      console.error("Error uploading document:", error);
      res.status(500).json({ error: "Failed to upload document" });
    }
  });

  // Verify document (Admin/Insurance Desk)
  app.patch("/api/insurance/documents/:id/verify", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !INSURANCE_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const document = await storage.verifyClaimDocument(req.params.id, user.id);
      if (!document) {
        return res.status(404).json({ error: "Document not found" });
      }
      res.json(document);
    } catch (error) {
      console.error("Error verifying document:", error);
      res.status(500).json({ error: "Failed to verify document" });
    }
  });

  // ===== PROVIDER CHECKLISTS =====
  
  // Get provider checklists
  app.get("/api/insurance/providers/:providerId/checklists", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const { claimType } = req.query;
      let checklists;
      if (claimType) {
        checklists = await storage.getProviderChecklistsByType(req.params.providerId, claimType as string);
      } else {
        checklists = await storage.getProviderChecklists(req.params.providerId);
      }
      res.json(checklists);
    } catch (error) {
      console.error("Error fetching checklists:", error);
      res.status(500).json({ error: "Failed to fetch checklists" });
    }
  });

  // Update provider checklists (Admin only)
  app.post("/api/insurance/providers/:providerId/checklists", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !INSURANCE_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized - Admin access required" });
      }
      
      // Delete existing and create new
      await storage.deleteProviderChecklists(req.params.providerId);
      
      const checklists = [];
      for (const item of req.body.checklists) {
        const checklist = await storage.createProviderChecklist({
          providerId: req.params.providerId,
          ...item,
        });
        checklists.push(checklist);
      }
      
      res.status(201).json(checklists);
    } catch (error) {
      console.error("Error updating checklists:", error);
      res.status(500).json({ error: "Failed to update checklists" });
    }
  });

  // ===== INSURANCE DASHBOARD (Admin) =====
  app.get("/api/insurance/dashboard", async (req, res) => {
    try {
      const session = (req.session as any);
      const user = session?.user;
      if (!user || !INSURANCE_ADMIN_ROLES.includes(user.role)) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const allClaims = await storage.getAllInsuranceClaims();
      const allProviders = await storage.getAllInsuranceProviders();
      
      // Calculate dashboard metrics
      const claimsByStatus = {
        DRAFT: allClaims.filter(c => c.status === "DRAFT").length,
        SUBMITTED: allClaims.filter(c => c.status === "SUBMITTED").length,
        UNDER_REVIEW: allClaims.filter(c => c.status === "UNDER_REVIEW").length,
        QUERY_RAISED: allClaims.filter(c => c.status === "QUERY_RAISED").length,
        APPROVED: allClaims.filter(c => c.status === "APPROVED").length,
        PARTIALLY_APPROVED: allClaims.filter(c => c.status === "PARTIALLY_APPROVED").length,
        REJECTED: allClaims.filter(c => c.status === "REJECTED").length,
        SETTLED: allClaims.filter(c => c.status === "SETTLED").length,
      };
      
      const totalApproved = allClaims.filter(c => ["APPROVED", "PARTIALLY_APPROVED", "SETTLED"].includes(c.status || "")).length;
      const totalRejected = allClaims.filter(c => c.status === "REJECTED").length;
      const approvalRate = allClaims.length > 0 ? ((totalApproved / allClaims.length) * 100).toFixed(1) : 0;
      
      const totalSettledAmount = allClaims
        .filter(c => c.settledAmount)
        .reduce((sum, c) => sum + parseFloat(c.settledAmount || "0"), 0);
      
      const pendingClaims = allClaims.filter(c => 
        ["SUBMITTED", "UNDER_REVIEW", "QUERY_RAISED"].includes(c.status || "")
      ).length;
      
      res.json({
        summary: {
          totalClaims: allClaims.length,
          pendingClaims,
          approvalRate: `${approvalRate}%`,
          totalSettledAmount: totalSettledAmount.toFixed(2),
          activeProviders: allProviders.filter(p => p.activeStatus).length,
        },
        claimsByStatus,
        recentClaims: allClaims.slice(0, 10),
      });
    } catch (error) {
      console.error("Error fetching insurance dashboard:", error);
      res.status(500).json({ error: "Failed to fetch dashboard" });
    }
  });

  // ===== FACE RECOGNITION & IDENTITY VERIFICATION API =====

  // Calculate cosine similarity between two embedding vectors
  function cosineSimilarity(a: number[], b: number[]): number {
    if (a.length !== b.length) return 0;
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }

  // Get recognition threshold setting
  async function getRecognitionThreshold(): Promise<number> {
    const setting = await storage.getFaceRecognitionSetting("recognition_threshold");
    return setting ? parseFloat(setting.settingValue) : 0.78;
  }

  // Face Embeddings - Store face data (Admin, Nurse, OPD_MANAGER)
  app.post("/api/face-recognition/embeddings", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      
      // Manual auth check
      if (!user) {
        console.log("Face-recognition embeddings: No session user found");
        return res.status(401).json({ error: "Unauthorized. Please log in." });
      }
      
      const allowedRoles = ["SUPER_ADMIN", "ADMIN", "NURSE", "OPD_MANAGER"];
      if (!allowedRoles.includes(user.role)) {
        return res.status(403).json({ error: `Access denied. Required roles: ${allowedRoles.join(", ")}` });
      }
      
      const { userId, userType, embeddingVector, faceQualityScore, captureDeviceId, captureLocation } = req.body;
      
      if (!userId || !userType || !embeddingVector) {
        return res.status(400).json({ error: "Missing required fields: userId, userType, embeddingVector" });
      }
      
      // Check consent exists
      const consent = await storage.getBiometricConsent(userId, userType);
      if (!consent || !consent.consentStatus) {
        return res.status(400).json({ error: "Biometric consent not given for this user" });
      }
      
      // Deactivate any existing embeddings for this user
      await storage.deactivateFaceEmbedding(userId, userType);
      
      const embedding = await storage.createFaceEmbedding({
        userId,
        userType,
        embeddingVector: typeof embeddingVector === 'string' ? embeddingVector : JSON.stringify(embeddingVector),
        faceQualityScore: faceQualityScore?.toString(),
        captureDeviceId,
        captureLocation,
        isActive: true,
      });
      
      res.status(201).json(embedding);
    } catch (error) {
      console.error("Error creating face embedding:", error);
      res.status(500).json({ error: "Failed to create face embedding" });
    }
  });

  // Get user's face embedding
  app.get("/api/face-recognition/embeddings/user/:userId/:userType", requireAuth, async (req, res) => {
    try {
      const embedding = await storage.getFaceEmbeddingByUser(req.params.userId, req.params.userType);
      if (!embedding) {
        return res.status(404).json({ error: "Face embedding not found" });
      }
      // Don't return the actual embedding vector to non-admin
      const user = (req as any).session?.user;
      if (user.role !== "ADMIN") {
        res.json({ ...embedding, embeddingVector: "[ENCRYPTED]" });
      } else {
        res.json(embedding);
      }
    } catch (error) {
      console.error("Error fetching face embedding:", error);
      res.status(500).json({ error: "Failed to fetch face embedding" });
    }
  });

  // Biometric Consent - Record consent
  app.post("/api/face-recognition/consent", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      
      // Manual auth check with better error info
      if (!user) {
        console.log("Face-recognition consent: No session user found");
        return res.status(401).json({ error: "Unauthorized. Please log in." });
      }
      
      const allowedRoles = ["SUPER_ADMIN", "ADMIN", "NURSE", "OPD_MANAGER"];
      if (!allowedRoles.includes(user.role)) {
        return res.status(403).json({ error: `Access denied. Required roles: ${allowedRoles.join(", ")}` });
      }
      
      const { userId, userType, consentStatus, ipAddress } = req.body;
      
      if (!userId || !userType) {
        return res.status(400).json({ error: "Missing required fields: userId, userType" });
      }
      
      // Check if consent already exists
      const existing = await storage.getBiometricConsent(userId, userType);
      if (existing) {
        const updated = await storage.updateBiometricConsent(existing.id, {
          consentStatus: consentStatus !== false,
          consentGivenAt: consentStatus ? new Date() : undefined,
          consentGivenBy: user.id,
          ipAddress,
        });
        return res.json(updated);
      }
      
      const consent = await storage.createBiometricConsent({
        userId,
        userType,
        biometricType: "FACE",
        consentStatus: consentStatus !== false,
        consentGivenAt: consentStatus ? new Date() : undefined,
        consentGivenBy: user.id,
        ipAddress,
      });
      
      res.status(201).json(consent);
    } catch (error) {
      console.error("Error creating consent:", error);
      res.status(500).json({ error: "Failed to create consent" });
    }
  });

  // Get consent status
  app.get("/api/face-recognition/consent/:userId/:userType", requireAuth, async (req, res) => {
    try {
      const consent = await storage.getBiometricConsent(req.params.userId, req.params.userType);
      res.json({ consent, hasConsent: consent?.consentStatus || false });
    } catch (error) {
      console.error("Error fetching consent:", error);
      res.status(500).json({ error: "Failed to fetch consent" });
    }
  });

  // Revoke consent
  app.post("/api/face-recognition/consent/revoke", requireAuth, requireRole(["SUPER_ADMIN", "ADMIN", "PATIENT"]), async (req, res) => {
    try {
      const { userId, userType, reason } = req.body;
      const user = (req as any).session?.user;
      
      // Patient can only revoke their own consent
      if (user.role === "PATIENT" && user.id !== userId) {
        return res.status(403).json({ error: "Can only revoke your own consent" });
      }
      
      await storage.revokeBiometricConsent(userId, userType, user.id, reason);
      // Also deactivate face embeddings
      await storage.deactivateFaceEmbedding(userId, userType);
      
      res.json({ success: true, message: "Consent revoked and face data deactivated" });
    } catch (error) {
      console.error("Error revoking consent:", error);
      res.status(500).json({ error: "Failed to revoke consent" });
    }
  });

  // Face Recognition - Match face against stored embeddings
  app.post("/api/face-recognition/match", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      
      // Manual auth check
      if (!user) {
        console.log("Face-recognition match: No session user found");
        return res.status(401).json({ error: "Unauthorized. Please log in." });
      }
      
      const allowedRoles = ["SUPER_ADMIN", "ADMIN", "NURSE", "OPD_MANAGER", "DOCTOR"];
      if (!allowedRoles.includes(user.role)) {
        return res.status(403).json({ error: `Access denied. Required roles: ${allowedRoles.join(", ")}` });
      }
      
      const startTime = Date.now();
      const { embeddingVector, userType, purpose, location, deviceId } = req.body;
      
      if (!embeddingVector) {
        return res.status(400).json({ error: "Missing embeddingVector" });
      }
      
      const inputVector = typeof embeddingVector === 'string' ? JSON.parse(embeddingVector) : embeddingVector;
      const threshold = await getRecognitionThreshold();
      
      // Get all active embeddings of the specified type
      const allEmbeddings = await storage.getAllActiveFaceEmbeddings(userType);
      
      let bestMatch: any = null;
      let highestScore = 0;
      const matches: any[] = [];
      
      for (const embedding of allEmbeddings) {
        const storedVector = JSON.parse(embedding.embeddingVector);
        const similarity = cosineSimilarity(inputVector, storedVector);
        
        if (similarity >= threshold) {
          matches.push({ embedding, similarity });
          if (similarity > highestScore) {
            highestScore = similarity;
            bestMatch = embedding;
          }
        }
      }
      
      const processingTime = Date.now() - startTime;
      let matchStatus = "FAILURE";
      
      if (matches.length === 1) {
        matchStatus = "SUCCESS";
      } else if (matches.length > 1) {
        matchStatus = "MULTIPLE_MATCHES";
      }
      
      // Log the recognition attempt
      const log = await storage.createFaceRecognitionLog({
        userType: userType || "UNKNOWN",
        matchedUserId: bestMatch?.userId || null,
        confidenceScore: highestScore.toString(),
        thresholdUsed: threshold.toString(),
        matchStatus,
        location,
        purpose: purpose || "VERIFICATION",
        deviceId,
        processingTimeMs: processingTime,
        performedBy: user.id,
      });
      
      res.json({
        matched: matchStatus === "SUCCESS" || matchStatus === "MULTIPLE_MATCHES",
        matchStatus,
        matchedUserId: bestMatch?.userId,
        matchedUserType: bestMatch?.userType,
        confidenceScore: highestScore,
        threshold,
        multipleMatches: matches.length > 1,
        matchCount: matches.length,
        processingTimeMs: processingTime,
        logId: log.id,
      });
    } catch (error) {
      console.error("Error matching face:", error);
      res.status(500).json({ error: "Failed to match face" });
    }
  });

  // Duplicate Patient Check - During registration
  app.post("/api/face-recognition/duplicate-check", requireAuth, requireRole(["SUPER_ADMIN", "ADMIN", "NURSE", "OPD_MANAGER"]), async (req, res) => {
    try {
      const { embeddingVector, newPatientId, location } = req.body;
      const user = (req as any).session?.user;
      
      if (!embeddingVector) {
        return res.status(400).json({ error: "Missing embeddingVector" });
      }
      
      const inputVector = typeof embeddingVector === 'string' ? JSON.parse(embeddingVector) : embeddingVector;
      const threshold = await getRecognitionThreshold();
      
      // Get all patient embeddings
      const patientEmbeddings = await storage.getAllActiveFaceEmbeddings("PATIENT");
      
      const potentialDuplicates: any[] = [];
      
      for (const embedding of patientEmbeddings) {
        // Skip if same patient
        if (embedding.userId === newPatientId) continue;
        
        const storedVector = JSON.parse(embedding.embeddingVector);
        const similarity = cosineSimilarity(inputVector, storedVector);
        
        if (similarity >= threshold) {
          potentialDuplicates.push({
            existingPatientId: embedding.userId,
            confidenceScore: similarity,
          });
        }
      }
      
      // Log the check
      await storage.createFaceRecognitionLog({
        userType: "PATIENT",
        matchedUserId: potentialDuplicates[0]?.existingPatientId || null,
        confidenceScore: (potentialDuplicates[0]?.confidenceScore || 0).toString(),
        thresholdUsed: threshold.toString(),
        matchStatus: potentialDuplicates.length > 0 ? "MULTIPLE_MATCHES" : "FAILURE",
        location,
        purpose: "DUPLICATE_CHECK",
        performedBy: user.id,
      });
      
      // Create alerts for each potential duplicate
      for (const duplicate of potentialDuplicates) {
        if (newPatientId) {
          await storage.createDuplicatePatientAlert({
            newPatientId,
            existingPatientId: duplicate.existingPatientId,
            confidenceScore: duplicate.confidenceScore.toString(),
            alertStatus: "PENDING",
          });
        }
      }
      
      res.json({
        hasDuplicates: potentialDuplicates.length > 0,
        duplicateCount: potentialDuplicates.length,
        potentialDuplicates: potentialDuplicates.map(d => ({
          existingPatientId: d.existingPatientId.slice(-4).padStart(d.existingPatientId.length, '*'),
          confidenceScore: (d.confidenceScore * 100).toFixed(1) + '%',
        })),
      });
    } catch (error) {
      console.error("Error checking duplicates:", error);
      res.status(500).json({ error: "Failed to check duplicates" });
    }
  });

  // Get duplicate alerts
  app.get("/api/face-recognition/duplicate-alerts", requireAuth, requireRole(["SUPER_ADMIN", "ADMIN"]), async (req, res) => {
    try {
      const status = req.query.status as string;
      const alerts = await storage.getDuplicatePatientAlerts(status);
      res.json(alerts);
    } catch (error) {
      console.error("Error fetching duplicate alerts:", error);
      res.status(500).json({ error: "Failed to fetch duplicate alerts" });
    }
  });

  // Resolve duplicate alert
  app.post("/api/face-recognition/duplicate-alerts/:id/resolve", requireAuth, requireRole(["SUPER_ADMIN", "ADMIN"]), async (req, res) => {
    try {
      const { status, notes, mergedToId } = req.body;
      const user = (req as any).session?.user;
      
      const alert = await storage.resolveDuplicateAlert(
        req.params.id,
        user.id,
        status,
        notes,
        mergedToId
      );
      
      res.json(alert);
    } catch (error) {
      console.error("Error resolving duplicate alert:", error);
      res.status(500).json({ error: "Failed to resolve duplicate alert" });
    }
  });

  // Face Attendance - Punch In/Out
  app.post("/api/face-recognition/attendance", requireAuth, requireRole(["SUPER_ADMIN", "ADMIN", "NURSE", "OPD_MANAGER"]), async (req, res) => {
    try {
      const { embeddingVector, location, deviceId, staffId } = req.body;
      const user = (req as any).session?.user;
      
      if (!embeddingVector) {
        return res.status(400).json({ error: "Missing embeddingVector" });
      }
      
      const inputVector = typeof embeddingVector === 'string' ? JSON.parse(embeddingVector) : embeddingVector;
      const threshold = await getRecognitionThreshold();
      
      // Get all staff embeddings
      const staffEmbeddings = await storage.getAllActiveFaceEmbeddings("STAFF");
      
      let bestMatch: any = null;
      let highestScore = 0;
      
      for (const embedding of staffEmbeddings) {
        const storedVector = JSON.parse(embedding.embeddingVector);
        const similarity = cosineSimilarity(inputVector, storedVector);
        
        if (similarity >= threshold && similarity > highestScore) {
          highestScore = similarity;
          bestMatch = embedding;
        }
      }
      
      // Log recognition attempt
      const log = await storage.createFaceRecognitionLog({
        userType: "STAFF",
        matchedUserId: bestMatch?.userId || null,
        confidenceScore: highestScore.toString(),
        thresholdUsed: threshold.toString(),
        matchStatus: bestMatch ? "SUCCESS" : "FAILURE",
        location,
        purpose: "ATTENDANCE",
        deviceId,
        performedBy: user.id,
      });
      
      if (!bestMatch) {
        return res.status(404).json({ 
          error: "Face not recognized",
          matchStatus: "FAILURE",
          confidenceScore: highestScore 
        });
      }
      
      // Determine punch type based on last attendance
      const lastAttendance = await storage.getLatestFaceAttendance(bestMatch.userId);
      const punchType = (!lastAttendance || lastAttendance.punchType === "OUT") ? "IN" : "OUT";
      
      // Create attendance record
      const attendance = await storage.createFaceAttendance({
        staffId: bestMatch.userId,
        punchType,
        confidenceScore: highestScore.toString(),
        deviceId,
        location,
        recognitionLogId: log.id,
      });
      
      res.json({
        success: true,
        punchType,
        staffId: bestMatch.userId,
        confidenceScore: highestScore,
        attendanceId: attendance.id,
        timestamp: attendance.createdAt,
      });
    } catch (error) {
      console.error("Error recording attendance:", error);
      res.status(500).json({ error: "Failed to record attendance" });
    }
  });

  // Get staff attendance
  app.get("/api/face-recognition/attendance/:staffId", requireAuth, async (req, res) => {
    try {
      const attendance = await storage.getFaceAttendanceByStaff(req.params.staffId);
      res.json(attendance);
    } catch (error) {
      console.error("Error fetching attendance:", error);
      res.status(500).json({ error: "Failed to fetch attendance" });
    }
  });

  // Get today's attendance (all staff)
  app.get("/api/face-recognition/attendance-today", requireAuth, requireRole(["SUPER_ADMIN", "ADMIN"]), async (req, res) => {
    try {
      const attendance = await storage.getAllFaceAttendanceToday();
      res.json(attendance);
    } catch (error) {
      console.error("Error fetching today's attendance:", error);
      res.status(500).json({ error: "Failed to fetch today's attendance" });
    }
  });

  // Recognition settings (Admin only)
  app.get("/api/face-recognition/settings", requireAuth, requireRole(["SUPER_ADMIN", "ADMIN"]), async (req, res) => {
    try {
      const settings = await storage.getAllFaceRecognitionSettings();
      res.json(settings);
    } catch (error) {
      console.error("Error fetching settings:", error);
      res.status(500).json({ error: "Failed to fetch settings" });
    }
  });

  app.post("/api/face-recognition/settings", requireAuth, requireRole(["SUPER_ADMIN", "ADMIN"]), async (req, res) => {
    try {
      const { key, value, description } = req.body;
      const user = (req as any).session?.user;
      
      const setting = await storage.upsertFaceRecognitionSetting(key, value, description, user.id);
      res.json(setting);
    } catch (error) {
      console.error("Error updating setting:", error);
      res.status(500).json({ error: "Failed to update setting" });
    }
  });

  // Recognition logs (Admin only)
  app.get("/api/face-recognition/logs", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      
      // Manual auth check
      if (!user) {
        console.log("Face-recognition logs: No session user found");
        return res.status(401).json({ error: "Unauthorized. Please log in." });
      }
      
      const allowedRoles = ["SUPER_ADMIN", "ADMIN"];
      if (!allowedRoles.includes(user.role)) {
        return res.status(403).json({ error: `Access denied. Required roles: ${allowedRoles.join(", ")}` });
      }
      
      const filters = {
        userType: req.query.userType as string,
        matchStatus: req.query.matchStatus as string,
      };
      const logs = await storage.getFaceRecognitionLogs(filters);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching recognition logs:", error);
      res.status(500).json({ error: "Failed to fetch recognition logs" });
    }
  });

  // Recognition stats dashboard (Admin only)
  app.get("/api/face-recognition/stats", async (req, res) => {
    try {
      const user = (req as any).session?.user;
      
      // Manual auth check
      if (!user) {
        console.log("Face-recognition stats: No session user found");
        return res.status(401).json({ error: "Unauthorized. Please log in." });
      }
      
      const allowedRoles = ["SUPER_ADMIN", "ADMIN"];
      if (!allowedRoles.includes(user.role)) {
        return res.status(403).json({ error: `Access denied. Required roles: ${allowedRoles.join(", ")}` });
      }
      
      const stats = await storage.getRecognitionStats();
      const settings = await storage.getAllFaceRecognitionSettings();
      const pendingAlerts = await storage.getDuplicatePatientAlerts("PENDING");
      const allEmbeddings = await storage.getAllActiveFaceEmbeddings();
      
      res.json({
        ...stats,
        activeEmbeddings: allEmbeddings.length,
        patientEmbeddings: allEmbeddings.filter((e: any) => e.userType === "PATIENT").length,
        staffEmbeddings: allEmbeddings.filter((e: any) => e.userType === "STAFF").length,
        pendingDuplicateAlerts: pendingAlerts.length,
        settings: settings.reduce((acc: any, s: any) => ({ ...acc, [s.settingKey]: s.settingValue }), {}),
      });
    } catch (error) {
      console.error("Error fetching stats:", error);
      res.status(500).json({ error: "Failed to fetch stats" });
    }
  });

  // Patient quick check-in via face
  app.post("/api/face-recognition/patient-checkin", requireAuth, requireRole(["SUPER_ADMIN", "ADMIN", "NURSE", "OPD_MANAGER"]), async (req, res) => {
    try {
      const { embeddingVector, location, deviceId } = req.body;
      const user = (req as any).session?.user;
      
      if (!embeddingVector) {
        return res.status(400).json({ error: "Missing embeddingVector" });
      }
      
      const inputVector = typeof embeddingVector === 'string' ? JSON.parse(embeddingVector) : embeddingVector;
      const threshold = await getRecognitionThreshold();
      const startTime = Date.now();
      
      // Get all patient embeddings
      const patientEmbeddings = await storage.getAllActiveFaceEmbeddings("PATIENT");
      
      let bestMatch: any = null;
      let highestScore = 0;
      
      for (const embedding of patientEmbeddings) {
        const storedVector = JSON.parse(embedding.embeddingVector);
        const similarity = cosineSimilarity(inputVector, storedVector);
        
        if (similarity >= threshold && similarity > highestScore) {
          highestScore = similarity;
          bestMatch = embedding;
        }
      }
      
      const processingTime = Date.now() - startTime;
      
      // Log the recognition attempt
      await storage.createFaceRecognitionLog({
        userType: "PATIENT",
        matchedUserId: bestMatch?.userId || null,
        confidenceScore: highestScore.toString(),
        thresholdUsed: threshold.toString(),
        matchStatus: bestMatch ? "SUCCESS" : "FAILURE",
        location,
        purpose: "CHECK_IN",
        deviceId,
        processingTimeMs: processingTime,
        performedBy: user.id,
      });
      
      if (!bestMatch) {
        return res.json({
          matched: false,
          message: "Patient not recognized. Please use manual check-in with UHID or mobile number.",
          confidenceScore: highestScore,
          processingTimeMs: processingTime,
        });
      }
      
      // Get patient details
      const patientProfile = await storage.getPatientProfileByPatientId(bestMatch.userId);
      const patientUser = await storage.getUser(bestMatch.userId);
      
      res.json({
        matched: true,
        patientId: bestMatch.userId,
        patientName: patientProfile?.fullName || patientUser?.name || "Unknown",
        confidenceScore: highestScore,
        processingTimeMs: processingTime,
        patientProfile,
      });
    } catch (error) {
      console.error("Error during patient check-in:", error);
      res.status(500).json({ error: "Failed to check-in patient" });
    }
  });

  // ========== REFERRAL MANAGEMENT ==========
  
  // Referral Sources
  app.get("/api/referral-sources", requireAuth, requireRole(["ADMIN"]), async (req, res) => {
    try {
      const sources = await storage.getReferralSources();
      res.json(sources);
    } catch (error) {
      console.error("Error fetching referral sources:", error);
      res.status(500).json({ error: "Failed to fetch referral sources" });
    }
  });

  app.post("/api/referral-sources", requireAuth, requireRole(["ADMIN"]), async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const source = await storage.createReferralSource({ 
        ...req.body, 
        tenantId: user.tenantId || user.hospitalName || "default",
        createdBy: user.id 
      });
      res.status(201).json(source);
    } catch (error) {
      console.error("Error creating referral source:", error);
      res.status(500).json({ error: "Failed to create referral source" });
    }
  });

  app.patch("/api/referral-sources/:id", requireAuth, requireRole(["ADMIN"]), async (req, res) => {
    try {
      const source = await storage.updateReferralSource(req.params.id, req.body);
      if (!source) return res.status(404).json({ error: "Referral source not found" });
      res.json(source);
    } catch (error) {
      console.error("Error updating referral source:", error);
      res.status(500).json({ error: "Failed to update referral source" });
    }
  });

  app.delete("/api/referral-sources/:id", requireAuth, requireRole(["ADMIN"]), async (req, res) => {
    try {
      const deleted = await storage.deleteReferralSource(req.params.id);
      if (!deleted) return res.status(404).json({ error: "Referral source not found" });
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting referral source:", error);
      res.status(500).json({ error: "Failed to delete referral source" });
    }
  });

  // Patient Referrals
  app.get("/api/referrals", requireAuth, requireRole(["ADMIN"]), async (req, res) => {
    try {
      const { referralType, status } = req.query;
      const filters: { referralType?: string; status?: string } = {};
      if (referralType && typeof referralType === 'string') filters.referralType = referralType;
      if (status && typeof status === 'string') filters.status = status;
      const referrals = await storage.getPatientReferrals(Object.keys(filters).length > 0 ? filters : undefined);
      res.json(referrals);
    } catch (error) {
      console.error("Error fetching referrals:", error);
      res.status(500).json({ error: "Failed to fetch referrals" });
    }
  });

  app.post("/api/referrals", requireAuth, requireRole(["ADMIN"]), async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const referral = await storage.createPatientReferral({ 
        ...req.body, 
        tenantId: user.tenantId || user.hospitalName || "default",
        createdBy: user.id 
      });
      res.status(201).json(referral);
    } catch (error) {
      console.error("Error creating referral:", error);
      res.status(500).json({ error: "Failed to create referral" });
    }
  });

  app.get("/api/referrals/:id", requireAuth, requireRole(["ADMIN"]), async (req, res) => {
    try {
      const referral = await storage.getPatientReferral(req.params.id);
      if (!referral) return res.status(404).json({ error: "Referral not found" });
      res.json(referral);
    } catch (error) {
      console.error("Error fetching referral:", error);
      res.status(500).json({ error: "Failed to fetch referral" });
    }
  });

  app.patch("/api/referrals/:id", requireAuth, requireRole(["ADMIN"]), async (req, res) => {
    try {
      const referral = await storage.updatePatientReferral(req.params.id, req.body);
      if (!referral) return res.status(404).json({ error: "Referral not found" });
      res.json(referral);
    } catch (error) {
      console.error("Error updating referral:", error);
      res.status(500).json({ error: "Failed to update referral" });
    }
  });

  app.delete("/api/referrals/:id", requireAuth, requireRole(["ADMIN"]), async (req, res) => {
    try {
      const deleted = await storage.deletePatientReferral(req.params.id);
      if (!deleted) return res.status(404).json({ error: "Referral not found" });
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting referral:", error);
      res.status(500).json({ error: "Failed to delete referral" });
    }
  });

  // Seed demo referral sources
  app.post("/api/referral-sources/seed", requireAuth, requireRole(["ADMIN"]), async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const tenantId = user.tenantId || user.hospitalName || "default";
      
      // Check if sources already exist
      const existingSources = await storage.getReferralSources();
      if (existingSources.length > 0) {
        return res.json({ message: "Referral sources already seeded", count: existingSources.length });
      }

      // 10 Outside Doctors for incoming referrals (REFER_FROM)
      const outsideDoctors = [
        { sourceName: "Dr. Rajesh Kumar", sourceType: "Doctor", contactPerson: "Dr. Rajesh Kumar", phone: "+91 98765 43210", email: "dr.rajesh@clinic.com", address: "Krishna Clinic, MG Road, Mumbai", specializations: "General Medicine", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Dr. Priya Sharma", sourceType: "Doctor", contactPerson: "Dr. Priya Sharma", phone: "+91 98765 43211", email: "dr.priya@familycare.com", address: "Family Care Center, Andheri West, Mumbai", specializations: "Family Medicine", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Dr. Amit Patel", sourceType: "Doctor", contactPerson: "Dr. Amit Patel", phone: "+91 98765 43212", email: "dr.amit@cardiocare.com", address: "Cardio Care Clinic, Bandra, Mumbai", specializations: "Cardiology", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Dr. Sunita Reddy", sourceType: "Doctor", contactPerson: "Dr. Sunita Reddy", phone: "+91 98765 43213", email: "dr.sunita@orthoclinic.com", address: "Ortho Clinic, Dadar, Mumbai", specializations: "Orthopedics", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Dr. Mohammed Khan", sourceType: "Doctor", contactPerson: "Dr. Mohammed Khan", phone: "+91 98765 43214", email: "dr.khan@neurocenter.com", address: "Neuro Center, Worli, Mumbai", specializations: "Neurology", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Dr. Anjali Desai", sourceType: "Doctor", contactPerson: "Dr. Anjali Desai", phone: "+91 98765 43215", email: "dr.anjali@pediatricare.com", address: "Pediatri Care, Powai, Mumbai", specializations: "Pediatrics", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Dr. Vikram Singh", sourceType: "Doctor", contactPerson: "Dr. Vikram Singh", phone: "+91 98765 43216", email: "dr.vikram@skinclinic.com", address: "Skin Clinic, Juhu, Mumbai", specializations: "Dermatology", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Dr. Meera Nair", sourceType: "Doctor", contactPerson: "Dr. Meera Nair", phone: "+91 98765 43217", email: "dr.meera@gynecare.com", address: "Gyne Care Clinic, Thane, Mumbai", specializations: "Gynecology", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Dr. Suresh Iyer", sourceType: "Doctor", contactPerson: "Dr. Suresh Iyer", phone: "+91 98765 43218", email: "dr.suresh@entclinic.com", address: "ENT Clinic, Malad, Mumbai", specializations: "ENT", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Dr. Kavita Joshi", sourceType: "Doctor", contactPerson: "Dr. Kavita Joshi", phone: "+91 98765 43219", email: "dr.kavita@eyecare.com", address: "Eye Care Center, Borivali, Mumbai", specializations: "Ophthalmology", isActive: true, tenantId, createdBy: user.id },
      ];

      // 10 Major Hospitals in India for outgoing referrals (REFER_TO)
      const majorHospitals = [
        { sourceName: "AIIMS Delhi", sourceType: "Hospital", contactPerson: "Referral Desk", phone: "+91 11 2658 8500", email: "referrals@aiims.edu", address: "Ansari Nagar, New Delhi - 110029", specializations: "Multi-Specialty", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Tata Memorial Hospital", sourceType: "Hospital", contactPerson: "Referral Coordinator", phone: "+91 22 2417 7000", email: "referrals@tmc.gov.in", address: "Dr. E Borges Road, Parel, Mumbai - 400012", specializations: "Oncology", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Apollo Hospitals Chennai", sourceType: "Hospital", contactPerson: "Patient Services", phone: "+91 44 2829 3333", email: "referrals@apollohospitals.com", address: "Greams Lane, Chennai - 600006", specializations: "Multi-Specialty", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Fortis Hospital Bangalore", sourceType: "Hospital", contactPerson: "Referral Team", phone: "+91 80 6621 4444", email: "referrals.blr@fortishealthcare.com", address: "Bannerghatta Road, Bangalore - 560076", specializations: "Multi-Specialty", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Medanta The Medicity", sourceType: "Hospital", contactPerson: "International Patient Desk", phone: "+91 124 4141 414", email: "referrals@medanta.org", address: "Sector 38, Gurgaon - 122001", specializations: "Multi-Specialty", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Kokilaben Dhirubhai Ambani Hospital", sourceType: "Hospital", contactPerson: "Referral Services", phone: "+91 22 3066 6666", email: "referrals@kokilabenhospital.com", address: "Four Bungalows, Andheri West, Mumbai - 400053", specializations: "Multi-Specialty", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Christian Medical College Vellore", sourceType: "Hospital", contactPerson: "Referral Office", phone: "+91 416 228 1000", email: "referrals@cmcvellore.ac.in", address: "Ida Scudder Road, Vellore - 632004", specializations: "Multi-Specialty", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Narayana Health Bangalore", sourceType: "Hospital", contactPerson: "Patient Coordinator", phone: "+91 80 7122 2222", email: "referrals@narayanahealth.org", address: "Bommasandra, Bangalore - 560099", specializations: "Cardiac Care", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Max Super Speciality Hospital Delhi", sourceType: "Hospital", contactPerson: "Referral Desk", phone: "+91 11 2651 5050", email: "referrals@maxhealthcare.com", address: "Saket, New Delhi - 110017", specializations: "Multi-Specialty", isActive: true, tenantId, createdBy: user.id },
        { sourceName: "Lilavati Hospital Mumbai", sourceType: "Hospital", contactPerson: "Patient Services", phone: "+91 22 2675 1000", email: "referrals@lilavatihospital.com", address: "A-791 Bandra Reclamation, Mumbai - 400050", specializations: "Multi-Specialty", isActive: true, tenantId, createdBy: user.id },
      ];

      // Create all sources
      for (const source of [...outsideDoctors, ...majorHospitals]) {
        await storage.createReferralSource(source);
      }

      res.json({ message: "Demo referral sources seeded successfully", count: 20 });
    } catch (error) {
      console.error("Error seeding referral sources:", error);
      res.status(500).json({ error: "Failed to seed referral sources" });
    }
  });

  // ========== HOSPITAL SERVICES API ==========
  
  // Get all departments with their services
  app.get("/api/hospital-service-departments", async (req, res) => {
    try {
      const departments = await storage.getHospitalServiceDepartments();
      const allServices = await storage.getHospitalServices();
      
      // Group services by department
      const departmentsWithServices = departments.map(dept => ({
        ...dept,
        services: allServices.filter(s => s.departmentId === dept.id)
      }));
      
      res.json(departmentsWithServices);
    } catch (error) {
      console.error("Error fetching departments:", error);
      res.status(500).json({ error: "Failed to fetch departments" });
    }
  });

  // Create a new department (Admin only)
  app.post("/api/hospital-service-departments", requireAuth, requireRole(["SUPER_ADMIN"]), async (req, res) => {
    try {
      const department = await storage.createHospitalServiceDepartment(req.body);
      res.status(201).json(department);
    } catch (error) {
      console.error("Error creating department:", error);
      res.status(500).json({ error: "Failed to create department" });
    }
  });

  // Update department (Admin only)
  app.patch("/api/hospital-service-departments/:id", requireAuth, requireRole(["SUPER_ADMIN"]), async (req, res) => {
    try {
      const department = await storage.updateHospitalServiceDepartment(req.params.id, req.body);
      if (!department) return res.status(404).json({ error: "Department not found" });
      res.json(department);
    } catch (error) {
      console.error("Error updating department:", error);
      res.status(500).json({ error: "Failed to update department" });
    }
  });

  // Delete department (Super Admin only)
  app.delete("/api/hospital-service-departments/:id", requireAuth, requireRole(["SUPER_ADMIN"]), async (req, res) => {
    try {
      const deleted = await storage.deleteHospitalServiceDepartment(req.params.id);
      if (!deleted) return res.status(404).json({ error: "Department not found" });
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting department:", error);
      res.status(500).json({ error: "Failed to delete department" });
    }
  });

  // Get services for a department
  app.get("/api/hospital-services", async (req, res) => {
    try {
      const departmentId = req.query.departmentId as string | undefined;
      const services = await storage.getHospitalServices(departmentId);
      res.json(services);
    } catch (error) {
      console.error("Error fetching services:", error);
      res.status(500).json({ error: "Failed to fetch services" });
    }
  });

  // Create a new service (Super Admin only)
  app.post("/api/hospital-services", requireAuth, requireRole(["SUPER_ADMIN"]), async (req, res) => {
    try {
      const service = await storage.createHospitalService(req.body);
      res.status(201).json(service);
    } catch (error) {
      console.error("Error creating service:", error);
      res.status(500).json({ error: "Failed to create service" });
    }
  });

  // Update service (Super Admin only)
  app.patch("/api/hospital-services/:id", requireAuth, requireRole(["SUPER_ADMIN"]), async (req, res) => {
    try {
      const service = await storage.updateHospitalService(req.params.id, req.body);
      if (!service) return res.status(404).json({ error: "Service not found" });
      res.json(service);
    } catch (error) {
      console.error("Error updating service:", error);
      res.status(500).json({ error: "Failed to update service" });
    }
  });

  // Delete service (Super Admin only)
  app.delete("/api/hospital-services/:id", requireAuth, requireRole(["SUPER_ADMIN"]), async (req, res) => {
    try {
      const deleted = await storage.deleteHospitalService(req.params.id);
      if (!deleted) return res.status(404).json({ error: "Service not found" });
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting service:", error);
      res.status(500).json({ error: "Failed to delete service" });
    }
  });

  // Bulk create services (Super Admin only) - for seeding
  app.post("/api/hospital-services/bulk", requireAuth, requireRole(["SUPER_ADMIN"]), async (req, res) => {
    try {
      const { services } = req.body;
      if (!Array.isArray(services)) {
        return res.status(400).json({ error: "Services must be an array" });
      }
      const createdServices = await storage.bulkCreateHospitalServices(services);
      res.status(201).json(createdServices);
    } catch (error) {
      console.error("Error bulk creating services:", error);
      res.status(500).json({ error: "Failed to bulk create services" });
    }
  });

  // ==========================================
  // OPD PRESCRIPTION TEMPLATES - Quick OPD Templates
  // ==========================================

  // Get all templates (accessible to ADMIN, DOCTOR, OPD_MANAGER)
  app.get("/api/opd-templates", requireAuth, requireRole(["ADMIN", "DOCTOR", "OPD_MANAGER"]), async (req, res) => {
    try {
      const { category, createdBy } = req.query;
      const templates = await storage.getOpdTemplates({
        category: category as string,
        createdBy: createdBy as string
      });
      res.json(templates);
    } catch (error) {
      console.error("Error fetching OPD templates:", error);
      res.status(500).json({ error: "Failed to fetch templates" });
    }
  });

  // Get single template by ID
  app.get("/api/opd-templates/:id", requireAuth, requireRole(["ADMIN", "DOCTOR", "OPD_MANAGER"]), async (req, res) => {
    try {
      const template = await storage.getOpdTemplate(req.params.id);
      if (!template) return res.status(404).json({ error: "Template not found" });
      res.json(template);
    } catch (error) {
      console.error("Error fetching template:", error);
      res.status(500).json({ error: "Failed to fetch template" });
    }
  });

  // Get template by slug
  app.get("/api/opd-templates/slug/:slug", requireAuth, requireRole(["ADMIN", "DOCTOR", "OPD_MANAGER"]), async (req, res) => {
    try {
      const template = await storage.getOpdTemplateBySlug(req.params.slug);
      if (!template) return res.status(404).json({ error: "Template not found" });
      res.json(template);
    } catch (error) {
      console.error("Error fetching template:", error);
      res.status(500).json({ error: "Failed to fetch template" });
    }
  });

  // Create new template (ADMIN and DOCTOR only)
  app.post("/api/opd-templates", requireAuth, requireRole(["ADMIN", "DOCTOR"]), async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const userId = user?.id;
      const userName = user?.firstName && user?.lastName ? `${user.firstName} ${user.lastName}` : user?.username;
      
      const templateData = {
        ...req.body,
        createdBy: userId,
        createdByName: userName,
        isSystemTemplate: false
      };
      
      const template = await storage.createOpdTemplate(templateData);
      res.status(201).json(template);
    } catch (error) {
      console.error("Error creating template:", error);
      res.status(500).json({ error: "Failed to create template" });
    }
  });

  // Update template (ADMIN can update any, DOCTOR can update their own)
  app.patch("/api/opd-templates/:id", requireAuth, requireRole(["ADMIN", "DOCTOR"]), async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const userId = user?.id;
      const userName = user?.firstName && user?.lastName ? `${user.firstName} ${user.lastName}` : user?.username;
      const userRole = user?.role;
      
      const existing = await storage.getOpdTemplate(req.params.id);
      if (!existing) return res.status(404).json({ error: "Template not found" });
      
      // Doctors can only update their own non-system templates
      if (userRole === "DOCTOR" && existing.createdBy !== userId) {
        return res.status(403).json({ error: "You can only edit your own templates" });
      }
      
      // System templates can only be updated by ADMIN
      if (existing.isSystemTemplate && userRole !== "ADMIN") {
        return res.status(403).json({ error: "Only administrators can modify system templates" });
      }
      
      const template = await storage.updateOpdTemplate(req.params.id, req.body, userId, userName);
      res.json(template);
    } catch (error) {
      console.error("Error updating template:", error);
      res.status(500).json({ error: "Failed to update template" });
    }
  });

  // Delete template (ADMIN can delete any non-system, DOCTOR can delete their own)
  app.delete("/api/opd-templates/:id", requireAuth, requireRole(["ADMIN", "DOCTOR"]), async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const userId = user?.id;
      const userRole = user?.role;
      
      const existing = await storage.getOpdTemplate(req.params.id);
      if (!existing) return res.status(404).json({ error: "Template not found" });
      
      // Cannot delete system templates
      if (existing.isSystemTemplate) {
        return res.status(403).json({ error: "System templates cannot be deleted" });
      }
      
      // Doctors can only delete their own templates
      if (userRole === "DOCTOR" && existing.createdBy !== userId) {
        return res.status(403).json({ error: "You can only delete your own templates" });
      }
      
      const deleted = await storage.deleteOpdTemplate(req.params.id);
      if (!deleted) return res.status(400).json({ error: "Failed to delete template" });
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting template:", error);
      res.status(500).json({ error: "Failed to delete template" });
    }
  });

  // Increment usage count when template is applied
  app.post("/api/opd-templates/:id/use", requireAuth, requireRole(["ADMIN", "DOCTOR", "OPD_MANAGER"]), async (req, res) => {
    try {
      await storage.incrementTemplateUsage(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error incrementing usage:", error);
      res.status(500).json({ error: "Failed to update usage" });
    }
  });

  // Get version history for a template
  app.get("/api/opd-templates/:id/versions", requireAuth, requireRole(["ADMIN", "DOCTOR"]), async (req, res) => {
    try {
      const versions = await storage.getOpdTemplateVersions(req.params.id);
      res.json(versions);
    } catch (error) {
      console.error("Error fetching versions:", error);
      res.status(500).json({ error: "Failed to fetch versions" });
    }
  });

  // Seed system templates (ADMIN only)
  app.post("/api/opd-templates/seed", requireAuth, requireRole(["ADMIN"]), async (req, res) => {
    try {
      await storage.seedSystemTemplates();
      res.json({ success: true, message: "System templates seeded successfully" });
    } catch (error) {
      console.error("Error seeding templates:", error);
      res.status(500).json({ error: "Failed to seed templates" });
    }
  });

  // ==========================================
  // ID Card Scanning & Alert System Routes
  // ==========================================

  // Get all ID card scans
  app.get("/api/id-card-scans", requireAuth, requireRole(["ADMIN", "NURSE", "OPD_MANAGER"]), async (req, res) => {
    try {
      const scans = await db.select().from(idCardScans).orderBy(desc(idCardScans.createdAt));
      res.json(scans);
    } catch (error) {
      console.error("Error fetching ID card scans:", error);
      res.status(500).json({ error: "Failed to fetch ID card scans" });
    }
  });

  // Create ID card scan with OCR processing
  app.post("/api/id-card-scans", requireAuth, requireRole(["ADMIN", "NURSE", "OPD_MANAGER"]), async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const scanData = {
        ...req.body,
        scannedBy: user?.id,
        scannedByName: user?.name || user?.username,
        processingStatus: "completed"
      };
      
      const [scan] = await db.insert(idCardScans).values(scanData).returning();
      res.json(scan);
    } catch (error) {
      console.error("Error creating ID card scan:", error);
      res.status(500).json({ error: "Failed to create ID card scan" });
    }
  });

  // OCR processing endpoint - simulates OCR extraction
  app.post("/api/id-card-scans/process-ocr", requireAuth, requireRole(["ADMIN", "NURSE", "OPD_MANAGER"]), async (req, res) => {
    try {
      const { imageData, idCardType, side } = req.body;
      
      // In a real implementation, this would call an OCR service
      // For now, we return a structure that the frontend can use
      // The frontend will handle actual OCR using browser-based libraries
      
      res.json({
        success: true,
        message: "Image received for processing",
        idCardType,
        side,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error("Error processing OCR:", error);
      res.status(500).json({ error: "Failed to process OCR" });
    }
  });

  // Get all critical alerts
  app.get("/api/critical-alerts", requireAuth, requireRole(["ADMIN", "DOCTOR", "NURSE", "OPD_MANAGER"]), async (req, res) => {
    try {
      const { status } = req.query;
      let alerts;
      
      if (status) {
        alerts = await db.select().from(criticalAlerts)
          .where(eq(criticalAlerts.status, status as string))
          .orderBy(desc(criticalAlerts.createdAt));
      } else {
        alerts = await db.select().from(criticalAlerts)
          .orderBy(desc(criticalAlerts.createdAt));
      }
      
      res.json(alerts);
    } catch (error) {
      console.error("Error fetching critical alerts:", error);
      res.status(500).json({ error: "Failed to fetch critical alerts" });
    }
  });

  // Get active critical alerts count (for dashboard badge)
  app.get("/api/critical-alerts/active-count", requireAuth, async (req, res) => {
    try {
      const alerts = await db.select().from(criticalAlerts)
        .where(eq(criticalAlerts.status, "active"));
      res.json({ count: alerts.length });
    } catch (error) {
      console.error("Error fetching active alerts count:", error);
      res.status(500).json({ error: "Failed to fetch active alerts count" });
    }
  });

  // Create critical alert (called when underage pregnancy detected)
  app.post("/api/critical-alerts", requireAuth, requireRole(["ADMIN", "NURSE", "OPD_MANAGER"]), async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const alertData = {
        ...req.body,
        createdBy: user?.id,
        createdByName: user?.name || user?.username,
        status: "active"
      };
      
      const [alert] = await db.insert(criticalAlerts).values(alertData).returning();
      
      // Broadcast real-time notification to admin/management
      notificationService.broadcastToRole("ADMIN", {
        type: "CRITICAL_ALERT",
        title: alertData.alertTitle,
        message: alertData.alertMessage,
        alertId: alert.id,
        severity: alertData.severity,
        timestamp: new Date().toISOString()
      });
      
      res.json(alert);
    } catch (error) {
      console.error("Error creating critical alert:", error);
      res.status(500).json({ error: "Failed to create critical alert" });
    }
  });

  // Check for critical alert conditions (backend rule enforcement)
  app.post("/api/critical-alerts/check", requireAuth, requireRole(["ADMIN", "NURSE", "OPD_MANAGER"]), async (req, res) => {
    try {
      const { patientName, patientAge, patientGender, department, visitReason, visitType, idCardScanId, patientId } = req.body;
      const user = (req as any).session?.user;
      
      const alerts = [];
      
      // Rule: Age < 18 AND Department = Gynecology AND Pregnancy-related visit
      if (patientAge < 18 && 
          department?.toLowerCase() === "gynecology" && 
          (visitType === "pregnancy_related" || 
           visitReason?.toLowerCase().includes("pregnancy") ||
           visitReason?.toLowerCase().includes("pregnant"))) {
        
        const alertData = {
          alertType: "UNDERAGE_PREGNANCY",
          severity: "critical",
          patientId,
          patientName,
          patientAge,
          patientGender,
          department,
          visitReason,
          visitType,
          alertTitle: "CRITICAL: Underage Pregnancy Case",
          alertMessage: `Underage patient (${patientAge} years old) registered for pregnancy-related visit in Gynecology department. Immediate attention required.`,
          additionalNotes: `Patient: ${patientName}, Age: ${patientAge}, Reason: ${visitReason}`,
          idCardScanId,
          createdBy: user?.id,
          createdByName: user?.name || user?.username,
          status: "active"
        };
        
        const [alert] = await db.insert(criticalAlerts).values(alertData).returning();
        alerts.push(alert);
        
        // Broadcast real-time notification
        notificationService.broadcastToRole("ADMIN", {
          type: "CRITICAL_ALERT",
          title: alertData.alertTitle,
          message: alertData.alertMessage,
          alertId: alert.id,
          severity: "critical",
          timestamp: new Date().toISOString()
        });
      }
      
      res.json({ 
        alertsTriggered: alerts.length > 0,
        alerts 
      });
    } catch (error) {
      console.error("Error checking critical alert conditions:", error);
      res.status(500).json({ error: "Failed to check alert conditions" });
    }
  });

  // Acknowledge critical alert
  app.patch("/api/critical-alerts/:id/acknowledge", requireAuth, requireRole(["ADMIN", "DOCTOR", "NURSE"]), async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const [alert] = await db.update(criticalAlerts)
        .set({
          status: "acknowledged",
          acknowledgedBy: user?.id,
          acknowledgedByName: user?.name || user?.username,
          acknowledgedAt: new Date(),
          updatedAt: new Date()
        })
        .where(eq(criticalAlerts.id, req.params.id))
        .returning();
      
      if (!alert) {
        return res.status(404).json({ error: "Alert not found" });
      }
      
      res.json(alert);
    } catch (error) {
      console.error("Error acknowledging alert:", error);
      res.status(500).json({ error: "Failed to acknowledge alert" });
    }
  });

  // Resolve critical alert
  app.patch("/api/critical-alerts/:id/resolve", requireAuth, requireRole(["ADMIN", "DOCTOR"]), async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const { resolutionNotes } = req.body;
      
      const [alert] = await db.update(criticalAlerts)
        .set({
          status: "resolved",
          resolvedBy: user?.id,
          resolvedByName: user?.name || user?.username,
          resolvedAt: new Date(),
          resolutionNotes,
          updatedAt: new Date()
        })
        .where(eq(criticalAlerts.id, req.params.id))
        .returning();
      
      if (!alert) {
        return res.status(404).json({ error: "Alert not found" });
      }
      
      res.json(alert);
    } catch (error) {
      console.error("Error resolving alert:", error);
      res.status(500).json({ error: "Failed to resolve alert" });
    }
  });

  // ============================================
  // SUPER ADMIN API ROUTES
  // ============================================

  // Require SUPER_ADMIN role middleware
  const requireSuperAdmin = (req: any, res: any, next: any) => {
    const user = req.session?.user;
    if (!user || user.role !== "SUPER_ADMIN") {
      return res.status(403).json({ error: "Super Admin access required" });
    }
    next();
  };

  // Get Super Admin Dashboard Stats
  app.get("/api/super-admin/dashboard", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const [usersCount] = await db.execute(sql`SELECT COUNT(*) as count FROM users`);
      const [billingCount] = await db.execute(sql`SELECT COUNT(*) as count FROM billing_records`);
      const [claimsCount] = await db.execute(sql`SELECT COUNT(*) as count FROM insurance_claims WHERE status = 'pending'`);
      const [auditCount] = await db.execute(sql`SELECT COUNT(*) as count FROM audit_logs WHERE timestamp > NOW() - INTERVAL '24 hours'`);
      
      res.json({
        totalUsers: usersCount?.count || 0,
        totalBillingRecords: billingCount?.count || 0,
        pendingClaims: claimsCount?.count || 0,
        recentAuditLogs: auditCount?.count || 0
      });
    } catch (error) {
      console.error("Error fetching super admin dashboard:", error);
      res.status(500).json({ error: "Failed to fetch dashboard stats" });
    }
  });

  // Audit Logs
  app.get("/api/super-admin/audit-logs", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const logs = await db.select().from(auditLogs).orderBy(desc(auditLogs.timestamp)).limit(100);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching audit logs:", error);
      res.status(500).json({ error: "Failed to fetch audit logs" });
    }
  });

  app.post("/api/super-admin/audit-logs", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const log = insertAuditLogSchema.parse({
        ...req.body,
        userId: user?.id,
        userName: user?.name || user?.username,
        userRole: user?.role
      });
      const [newLog] = await db.insert(auditLogs).values(log).returning();
      res.json(newLog);
    } catch (error) {
      console.error("Error creating audit log:", error);
      res.status(500).json({ error: "Failed to create audit log" });
    }
  });

  // Financial Locks
  app.get("/api/super-admin/financial-locks", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const locks = await db.select().from(financialLocks).orderBy(desc(financialLocks.createdAt));
      res.json(locks);
    } catch (error) {
      console.error("Error fetching financial locks:", error);
      res.status(500).json({ error: "Failed to fetch financial locks" });
    }
  });

  app.post("/api/super-admin/financial-locks", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const lock = insertFinancialLockSchema.parse({
        ...req.body,
        lockedBy: user?.id
      });
      const [newLock] = await db.insert(financialLocks).values(lock).returning();
      
      // Create audit log
      await db.insert(auditLogs).values({
        id: crypto.randomUUID(),
        action: "FINANCIAL_LOCK_CREATED",
        module: "BILLING",
        userId: user?.id,
        userName: user?.name || user?.username,
        userRole: user?.role,
        resourceType: "financial_lock",
        resourceId: newLock.id,
        details: { lockType: lock.lockType, period: lock.period },
        ipAddress: req.ip
      });
      
      res.json(newLock);
    } catch (error) {
      console.error("Error creating financial lock:", error);
      res.status(500).json({ error: "Failed to create financial lock" });
    }
  });

  // Role Permissions
  app.get("/api/super-admin/permissions", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const permissions = await db.select().from(rolePermissions);
      res.json(permissions);
    } catch (error) {
      console.error("Error fetching permissions:", error);
      res.status(500).json({ error: "Failed to fetch permissions" });
    }
  });

  app.post("/api/super-admin/permissions", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const permission = insertRolePermissionSchema.parse({
        ...req.body,
        grantedBy: user?.id
      });
      const [newPermission] = await db.insert(rolePermissions).values(permission).returning();
      res.json(newPermission);
    } catch (error) {
      console.error("Error creating permission:", error);
      res.status(500).json({ error: "Failed to create permission" });
    }
  });

  app.patch("/api/super-admin/permissions/:id", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const [permission] = await db.update(rolePermissions)
        .set(req.body)
        .where(eq(rolePermissions.id, req.params.id))
        .returning();
      res.json(permission);
    } catch (error) {
      console.error("Error updating permission:", error);
      res.status(500).json({ error: "Failed to update permission" });
    }
  });

  app.post("/api/super-admin/permissions/bulk", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const { role, permissions: permList } = req.body;
      
      if (!role || !Array.isArray(permList)) {
        return res.status(400).json({ error: "Role and permissions array required" });
      }

      const results = [];
      
      for (const perm of permList) {
        const existingPerm = await db.select().from(rolePermissions)
          .where(and(eq(rolePermissions.role, role), eq(rolePermissions.module, perm.module)))
          .limit(1);
        
        if (existingPerm.length > 0) {
          const [updated] = await db.update(rolePermissions)
            .set({
              canView: perm.canView ?? false,
              canCreate: perm.canCreate ?? false,
              canEdit: perm.canEdit ?? false,
              canDelete: perm.canDelete ?? false,
              canApprove: perm.canApprove ?? false,
              canLock: perm.canLock ?? false,
              canUnlock: perm.canUnlock ?? false,
              canExport: perm.canExport ?? false,
              updatedAt: new Date()
            })
            .where(eq(rolePermissions.id, existingPerm[0].id))
            .returning();
          results.push(updated);
        } else {
          const [created] = await db.insert(rolePermissions).values({
            role,
            module: perm.module,
            canView: perm.canView ?? false,
            canCreate: perm.canCreate ?? false,
            canEdit: perm.canEdit ?? false,
            canDelete: perm.canDelete ?? false,
            canApprove: perm.canApprove ?? false,
            canLock: perm.canLock ?? false,
            canUnlock: perm.canUnlock ?? false,
            canExport: perm.canExport ?? false,
            createdBy: user?.id
          }).returning();
          results.push(created);
        }
      }
      
      await db.insert(auditLogs).values({
        userId: user?.id || "unknown",
        userName: user?.name || "System",
        userRole: user?.role || "UNKNOWN",
        action: "UPDATE",
        module: "USERS",
        entityType: "ROLE_PERMISSION",
        entityId: role,
        changeDescription: `Permissions updated for role ${role}. Modules: ${permList.map((p: any) => p.module).join(", ")}`,
        severity: "warning",
        ipAddress: req.ip || "unknown"
      });
      
      res.json({ success: true, updated: results.length, permissions: results });
    } catch (error) {
      console.error("Error bulk updating permissions:", error);
      res.status(500).json({ error: "Failed to update permissions" });
    }
  });

  app.get("/api/super-admin/permissions/:role", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const permissions = await db.select().from(rolePermissions)
        .where(eq(rolePermissions.role, req.params.role));
      res.json(permissions);
    } catch (error) {
      console.error("Error fetching role permissions:", error);
      res.status(500).json({ error: "Failed to fetch role permissions" });
    }
  });

  app.get("/api/permissions/current", requireAuth, async (req, res) => {
    try {
      const user = (req as any).session?.user;
      if (!user) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      
      const permissions = await db.select().from(rolePermissions)
        .where(eq(rolePermissions.role, user.role));
      res.json({ role: user.role, permissions });
    } catch (error) {
      console.error("Error fetching current user permissions:", error);
      res.status(500).json({ error: "Failed to fetch permissions" });
    }
  });

  // Billing Records
  app.get("/api/super-admin/billing-records", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const records = await db.select().from(billingRecords).orderBy(desc(billingRecords.createdAt)).limit(100);
      res.json(records);
    } catch (error) {
      console.error("Error fetching billing records:", error);
      res.status(500).json({ error: "Failed to fetch billing records" });
    }
  });

  // Stock Batches
  app.get("/api/super-admin/stock-batches", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const batches = await db.select().from(stockBatches).orderBy(desc(stockBatches.createdAt));
      res.json(batches);
    } catch (error) {
      console.error("Error fetching stock batches:", error);
      res.status(500).json({ error: "Failed to fetch stock batches" });
    }
  });

  app.post("/api/super-admin/stock-batches", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const batch = insertStockBatchSchema.parse(req.body);
      const [newBatch] = await db.insert(stockBatches).values(batch).returning();
      res.json(newBatch);
    } catch (error) {
      console.error("Error creating stock batch:", error);
      res.status(500).json({ error: "Failed to create stock batch" });
    }
  });

  // Surgery Packages
  app.get("/api/super-admin/surgery-packages", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const packages = await db.select().from(surgeryPackages).orderBy(desc(surgeryPackages.createdAt));
      res.json(packages);
    } catch (error) {
      console.error("Error fetching surgery packages:", error);
      res.status(500).json({ error: "Failed to fetch surgery packages" });
    }
  });

  app.post("/api/super-admin/surgery-packages", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const pkg = insertSurgeryPackageSchema.parse({
        ...req.body,
        createdBy: user?.id
      });
      const [newPackage] = await db.insert(surgeryPackages).values(pkg).returning();
      res.json(newPackage);
    } catch (error) {
      console.error("Error creating surgery package:", error);
      res.status(500).json({ error: "Failed to create surgery package" });
    }
  });

  // Medicine Catalog
  app.get("/api/super-admin/medicine-catalog", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const medicines = await db.select().from(medicineCatalog).orderBy(medicineCatalog.brandName);
      res.json(medicines);
    } catch (error) {
      console.error("Error fetching medicine catalog:", error);
      res.status(500).json({ error: "Failed to fetch medicine catalog" });
    }
  });

  app.post("/api/super-admin/medicine-catalog", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const medicine = insertMedicineCatalogSchema.parse({
        ...req.body,
        createdBy: user?.id
      });
      const [newMedicine] = await db.insert(medicineCatalog).values(medicine).returning();
      res.json(newMedicine);
    } catch (error) {
      console.error("Error creating medicine:", error);
      res.status(500).json({ error: "Failed to create medicine" });
    }
  });

  // Insurance Providers
  app.get("/api/super-admin/insurance-providers", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const providers = await db.select().from(insuranceProviders).orderBy(insuranceProviders.name);
      res.json(providers);
    } catch (error) {
      console.error("Error fetching insurance providers:", error);
      res.status(500).json({ error: "Failed to fetch insurance providers" });
    }
  });

  app.post("/api/super-admin/insurance-providers", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const provider = insertInsuranceProviderSchema.parse({
        ...req.body,
        createdBy: user?.id
      });
      const [newProvider] = await db.insert(insuranceProviders).values(provider).returning();
      res.json(newProvider);
    } catch (error) {
      console.error("Error creating insurance provider:", error);
      res.status(500).json({ error: "Failed to create insurance provider" });
    }
  });

  // Insurance Claims
  app.get("/api/super-admin/claims", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const claims = await db.select().from(insuranceClaims).orderBy(desc(insuranceClaims.filedAt));
      res.json(claims);
    } catch (error) {
      console.error("Error fetching claims:", error);
      res.status(500).json({ error: "Failed to fetch claims" });
    }
  });

  app.patch("/api/super-admin/claims/:id", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const updateData = {
        ...req.body,
        updatedAt: new Date()
      };
      
      if (req.body.status === "approved" || req.body.status === "rejected") {
        updateData.reviewedBy = user?.id;
        updateData.reviewedAt = new Date();
      }
      
      const [claim] = await db.update(insuranceClaims)
        .set(updateData)
        .where(eq(insuranceClaims.id, req.params.id))
        .returning();
      res.json(claim);
    } catch (error) {
      console.error("Error updating claim:", error);
      res.status(500).json({ error: "Failed to update claim" });
    }
  });

  // Hospital Packages
  app.get("/api/super-admin/hospital-packages", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const packages = await db.select().from(hospitalPackages).orderBy(hospitalPackages.packageName);
      res.json(packages);
    } catch (error) {
      console.error("Error fetching hospital packages:", error);
      res.status(500).json({ error: "Failed to fetch hospital packages" });
    }
  });

  app.post("/api/super-admin/hospital-packages", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const pkg = insertHospitalPackageSchema.parse({
        ...req.body,
        createdBy: user?.id
      });
      const [newPackage] = await db.insert(hospitalPackages).values(pkg).returning();
      res.json(newPackage);
    } catch (error) {
      console.error("Error creating hospital package:", error);
      res.status(500).json({ error: "Failed to create hospital package" });
    }
  });

  // Override Requests
  app.get("/api/super-admin/override-requests", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const requests = await db.select().from(overrideRequests).orderBy(desc(overrideRequests.requestedAt));
      res.json(requests);
    } catch (error) {
      console.error("Error fetching override requests:", error);
      res.status(500).json({ error: "Failed to fetch override requests" });
    }
  });

  app.patch("/api/super-admin/override-requests/:id", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const user = (req as any).session?.user;
      const [request] = await db.update(overrideRequests)
        .set({
          ...req.body,
          reviewedBy: user?.id,
          reviewedAt: new Date()
        })
        .where(eq(overrideRequests.id, req.params.id))
        .returning();
      res.json(request);
    } catch (error) {
      console.error("Error updating override request:", error);
      res.status(500).json({ error: "Failed to update override request" });
    }
  });

  // Users Management for Super Admin
  app.get("/api/super-admin/users", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const allUsers = await db.select({
        id: users.id,
        username: users.username,
        name: users.name,
        email: users.email,
        role: users.role,
        status: users.status,
        lastLogin: users.lastLogin,
        createdAt: users.createdAt
      }).from(users).orderBy(desc(users.createdAt));
      res.json(allUsers);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ error: "Failed to fetch users" });
    }
  });

  app.patch("/api/super-admin/users/:id/status", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const { status } = req.body;
      const updated = await storage.updateUserStatus(req.params.id, status);
      if (!updated) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating user status:", error);
      res.status(500).json({ error: "Failed to update user status" });
    }
  });

  // Reset user password (Super Admin only)
  app.post("/api/super-admin/users/:id/reset-password", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const currentUser = (req as any).session?.user;
      const user = await storage.getUser(req.params.id);
      
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      
      // Prevent resetting super admin password
      if (user.role === "SUPER_ADMIN") {
        return res.status(403).json({ error: "Cannot reset Super Admin password" });
      }
      
      // Generate new random password
      const newPassword = generateSecurePassword();
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      
      // Update user password
      await storage.updateUserPassword(user.id, hashedPassword);
      
      // Log audit
      await db.insert(auditLogs).values({
        userId: currentUser?.id || 'system',
        action: 'USER_PASSWORD_RESET',
        module: 'USERS',
        entityType: 'user',
        entityId: user.id,
        userName: currentUser?.name || 'System',
        userRole: currentUser?.role || 'SUPER_ADMIN',
        changeDescription: `Password reset for user ${user.username} by ${currentUser?.username}`,
        ipAddress: req.ip || 'unknown'
      });
      
      res.json({ 
        success: true, 
        username: user.username,
        newPassword 
      });
    } catch (error) {
      console.error("Error resetting password:", error);
      res.status(500).json({ error: "Failed to reset password" });
    }
  });

  // Create new user with auto-generated username and password
  const createUserSchema = z.object({
    name: z.string().min(1, "Name is required").max(100),
    email: z.string().email().optional().nullable(),
    role: z.enum(["SUPER_ADMIN", "ADMIN", "DOCTOR", "NURSE", "OPD_MANAGER", "PATIENT", "MEDICAL_STORE", "PATHOLOGY_LAB"]),
    dateOfBirth: z.string().optional().nullable()
  });

  app.post("/api/super-admin/users", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const currentUser = (req as any).session?.user;
      
      // Validate request body with Zod
      const parseResult = createUserSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ 
          error: parseResult.error.errors[0]?.message || "Invalid request data"
        });
      }
      
      const { name, email, role, dateOfBirth } = parseResult.data;

      // Generate username: role prefix + name slug + random suffix
      const rolePrefix = role.toLowerCase().replace(/_/g, '').slice(0, 3);
      const nameSlug = name.toLowerCase().replace(/[^a-z0-9]/g, '').slice(0, 8);
      const randomSuffix = Math.random().toString(36).substring(2, 6);
      const username = `${rolePrefix}_${nameSlug}_${randomSuffix}`;

      // Check if username exists
      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(400).json({ error: "Generated username conflict, please try again" });
      }

      // Generate secure random password
      const plainPassword = generateSecurePassword();

      // Hash password before storing
      const hashedPassword = await bcrypt.hash(plainPassword, 10);

      // Create user
      const newUser = await storage.createUser({
        username,
        password: hashedPassword,
        name,
        email: email || null,
        role,
        dateOfBirth: dateOfBirth || null,
      });

      // If creating a DOCTOR, also create their doctor profile for OPD
      // CRITICAL: Create staff_master entry for staff roles (required for login)
      const staffRoles = ["DOCTOR", "NURSE", "OPD_MANAGER", "ADMIN", "PATHOLOGY_LAB", "MEDICAL_STORE"];
      if (staffRoles.includes(role)) {
        const empCodePrefix = role === "DOCTOR" ? "DOC" : role === "NURSE" ? "NUR" : role === "OPD_MANAGER" ? "OPD" : role === "ADMIN" ? "ADM" : role === "PATHOLOGY_LAB" ? "LAB" : "STR";
        const empCode = `${empCodePrefix}${Date.now().toString().slice(-6)}`;
        
        await storage.createStaffMaster({
          fullName: name,
          email: email || null,
          role: role,
          department: "General",
          employeeCode: empCode,
          status: "ACTIVE",
          userId: newUser.id,
          phone: null,
          dateOfBirth: dateOfBirth || null,
          address: null,
          qualifications: role === "DOCTOR" ? "MBBS" : null,
          specialization: null,
          joiningDate: new Date().toISOString().split('T')[0]
        });
        
        console.log(`Created staff_master entry for ${name} (${role}) with employee code ${empCode}`);
      }
      
      if (role === "DOCTOR") {
        const initials = name.split(' ').map((n: string) => n[0]).join('').toUpperCase().slice(0, 2);
        
        // Create doctor entry in doctors table (for OPD booking list)
        const [doctorEntry] = await db.insert(doctors).values({
          name: name,
          specialty: "General Medicine", // Default specialty, can be updated later
          qualification: "MBBS",         // Default qualification
          experience: 1,                 // Default experience in years
          rating: "4.5",
          availableDays: "Mon, Wed, Fri", // Default availability
          avatarInitials: initials,
          dateOfBirth: dateOfBirth || null
        }).returning();
        
        // Also create doctor profile entry (extended profile info linked to user)
        await db.insert(doctorProfiles).values({
          doctorId: newUser.id,          // Link to the user account
          fullName: name,
          specialty: "General Medicine",
          email: email || null,
          qualifications: "MBBS",
          experience: "1 year",
          designation: "Consultant",
          department: "General Medicine",
          hospitalName: "Gravity Hospital"
        });
        
        console.log(`Created doctor entry and profile for ${name} (user: ${newUser.id}, doctor: ${doctorEntry.id})`);
      }

      // Log audit action
      await db.insert(auditLogs).values({
        userId: currentUser?.id || 'system',
        action: 'USER_CREATED',
        module: 'USERS',
        entityType: 'user',
        entityId: newUser.id,
        userName: currentUser?.name || 'System',
        userRole: currentUser?.role || 'SUPER_ADMIN',
        newValue: JSON.stringify({ username, role, name, email }),
        changeDescription: `Created new ${role} user: ${name} (${username})`,
        ipAddress: req.ip || 'unknown'
      });

      // Return user with plain password (only shown once)
      res.json({
        ...newUser,
        generatedPassword: plainPassword, // Only returned once for display
        password: undefined // Don't return hashed password
      });
    } catch (error) {
      console.error("Error creating user:", error);
      res.status(500).json({ error: "Failed to create user" });
    }
  });

  // Delete user
  app.delete("/api/super-admin/users/:id", requireAuth, requireSuperAdmin, async (req, res) => {
    try {
      const currentUser = (req as any).session?.user;
      const userId = req.params.id;

      // Prevent self-deletion
      if (currentUser?.id === userId) {
        return res.status(400).json({ error: "Cannot delete your own account" });
      }

      // Get user before deletion for audit
      const userToDelete = await storage.getUser(userId);
      if (!userToDelete) {
        return res.status(404).json({ error: "User not found" });
      }

      // Prevent deleting other Super Admins (safety measure)
      if (userToDelete.role === 'SUPER_ADMIN' && currentUser?.role !== 'SUPER_ADMIN') {
        return res.status(403).json({ error: "Cannot delete Super Admin accounts" });
      }

      const deleted = await storage.deleteUser(userId);
      if (!deleted) {
        return res.status(404).json({ error: "User not found" });
      }

      // Log audit action
      await db.insert(auditLogs).values({
        userId: currentUser?.id || 'system',
        action: 'USER_DELETED',
        module: 'USERS',
        entityType: 'user',
        entityId: userId,
        userName: currentUser?.name || 'System',
        userRole: currentUser?.role || 'SUPER_ADMIN',
        previousValue: JSON.stringify({ 
          username: userToDelete.username, 
          role: userToDelete.role,
          name: userToDelete.name
        }),
        changeDescription: `Deleted ${userToDelete.role} user: ${userToDelete.name} (${userToDelete.username})`,
        ipAddress: req.ip || 'unknown'
      });

      res.json({ success: true, message: "User deleted successfully" });
    } catch (error) {
      console.error("Error deleting user:", error);
      res.status(500).json({ error: "Failed to delete user" });
    }
  });

  // ========== NURSE DEPARTMENT PREFERENCES API ==========
  const HOSPITAL_DEPARTMENTS = [
    "Emergency", "Cardiology", "Neurology", "Orthopedics", "Pediatrics",
    "Oncology", "Ophthalmology", "ENT", "Dermatology", "Psychiatry",
    "Gynecology", "Urology", "Nephrology", "Gastroenterology", "Pulmonology",
    "Endocrinology", "Rheumatology", "Pathology", "Radiology", "Physiotherapy",
    "Dental", "General Medicine", "General Surgery", "ICU"
  ];

  app.get("/api/nurse-department-preferences/departments", async (req, res) => {
    res.json(HOSPITAL_DEPARTMENTS);
  });

  // Get all nurses from users table with auto-generated IDs for those without
  app.get("/api/nurse-department-preferences/all-nurses", requireAuth, async (req, res) => {
    try {
      const allUsers = await storage.getAllUsers();
      const nurses = allUsers.filter(u => u.role === 'NURSE');
      
      // Get existing preferences to check for existing IDs
      const existingPrefs = await storage.getAllNurseDepartmentPreferences();
      const existingIdMap = new Map(existingPrefs.map(p => [p.nurseName, p.nurseId]));
      
      // Map nurses with IDs (use existing or generate new)
      let autoIdCounter = 1;
      const nursesWithIds = nurses.map(nurse => {
        // Check if nurse already has a preference with ID
        const existingId = existingIdMap.get(nurse.name || nurse.username);
        if (existingId) {
          return { nurseId: existingId, nurseName: nurse.name || nurse.username };
        }
        // Generate dummy ID for nurses without one
        const dummyId = `NRS-AUTO-${String(autoIdCounter++).padStart(3, '0')}`;
        return { nurseId: dummyId, nurseName: nurse.name || nurse.username };
      });
      
      res.json(nursesWithIds);
    } catch (error) {
      console.error("Error fetching all nurses:", error);
      res.status(500).json({ error: "Failed to fetch nurses" });
    }
  });

  app.get("/api/nurse-department-preferences", requireAuth, async (req, res) => {
    try {
      const allPreferences = await storage.getAllNurseDepartmentPreferences();
      res.json(allPreferences);
    } catch (error) {
      console.error("Error fetching nurse preferences:", error);
      res.status(500).json({ error: "Failed to fetch nurse preferences" });
    }
  });

  app.get("/api/nurse-department-preferences/:nurseId", requireAuth, async (req, res) => {
    try {
      const prefs = await storage.getNurseDepartmentPreferences(req.params.nurseId);
      if (!prefs) {
        return res.status(404).json({ error: "Preferences not found" });
      }
      res.json(prefs);
    } catch (error) {
      console.error("Error fetching nurse preferences:", error);
      res.status(500).json({ error: "Failed to fetch nurse preferences" });
    }
  });

  app.post("/api/nurse-department-preferences", requireAuth, async (req, res) => {
    try {
      const { nurseId, nurseName, primaryDepartment, secondaryDepartment, tertiaryDepartment } = req.body;
      
      if (!nurseId || !nurseName || !primaryDepartment || !secondaryDepartment || !tertiaryDepartment) {
        return res.status(400).json({ error: "All fields are required" });
      }

      const departments = [primaryDepartment, secondaryDepartment, tertiaryDepartment];
      const uniqueDepartments = new Set(departments);
      if (uniqueDepartments.size !== 3) {
        return res.status(400).json({ error: "All three department preferences must be unique" });
      }

      for (const dept of departments) {
        if (!HOSPITAL_DEPARTMENTS.includes(dept)) {
          return res.status(400).json({ error: `Invalid department: ${dept}` });
        }
      }

      const result = await storage.upsertNurseDepartmentPreferences({
        nurseId,
        nurseName,
        primaryDepartment,
        secondaryDepartment,
        tertiaryDepartment
      });
      
      res.json(result);
    } catch (error) {
      console.error("Error saving nurse preferences:", error);
      res.status(500).json({ error: "Failed to save nurse preferences" });
    }
  });

  app.delete("/api/nurse-department-preferences/:nurseId", requireAuth, async (req, res) => {
    try {
      const deleted = await storage.deleteNurseDepartmentPreferences(req.params.nurseId);
      if (!deleted) {
        return res.status(404).json({ error: "Preferences not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting nurse preferences:", error);
      res.status(500).json({ error: "Failed to delete nurse preferences" });
    }
  });

  app.patch("/api/nurse-department-preferences/:nurseId/availability", requireAuth, requireRole(["ADMIN", "SUPER_ADMIN"]), async (req, res) => {
    try {
      const { isAvailable } = req.body;
      if (typeof isAvailable !== "boolean") {
        return res.status(400).json({ error: "isAvailable must be a boolean value" });
      }
      
      const updated = await storage.updateNurseAvailability(req.params.nurseId, isAvailable);
      if (!updated) {
        return res.status(404).json({ error: "Nurse preferences not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating nurse availability:", error);
      res.status(500).json({ error: "Failed to update nurse availability" });
    }
  });

  app.post("/api/nurse-department-preferences/seed", requireAuth, requireRole(["ADMIN", "SUPER_ADMIN"]), async (req, res) => {
    try {
      await storage.seedNurseDepartmentPreferences();
      res.json({ success: true, message: "Nurse department preferences seeded successfully" });
    } catch (error) {
      console.error("Error seeding nurse preferences:", error);
      res.status(500).json({ error: "Failed to seed nurse preferences" });
    }
  });

  // Seed ICU beds endpoint
  app.post("/api/icu/seed-beds", requireAuth, requireRole(["ADMIN", "SUPER_ADMIN"]), async (req, res) => {
    try {
      await storage.seedIcuBeds();
      res.json({ success: true, message: "ICU beds seeded successfully" });
    } catch (error) {
      console.error("Error seeding ICU beds:", error);
      res.status(500).json({ error: "Failed to seed ICU beds" });
    }
  });

  // ========== DEPARTMENT NURSE ASSIGNMENTS ==========
  app.get("/api/department-nurse-assignments", requireAuth, async (req, res) => {
    try {
      const assignments = await storage.getAllDepartmentNurseAssignments();
      res.json(assignments);
    } catch (error) {
      console.error("Error fetching department nurse assignments:", error);
      res.status(500).json({ error: "Failed to fetch department nurse assignments" });
    }
  });

  app.get("/api/department-nurse-assignments/:departmentName", requireAuth, async (req, res) => {
    try {
      const assignment = await storage.getDepartmentNurseAssignment(req.params.departmentName);
      if (!assignment) {
        return res.status(404).json({ error: "Department assignment not found" });
      }
      res.json(assignment);
    } catch (error) {
      console.error("Error fetching department assignment:", error);
      res.status(500).json({ error: "Failed to fetch department assignment" });
    }
  });

  app.post("/api/department-nurse-assignments", requireAuth, requireRole(["ADMIN", "SUPER_ADMIN"]), async (req, res) => {
    try {
      const { departmentName, primaryNurseId, primaryNurseName, secondaryNurseId, secondaryNurseName, tertiaryNurseId, tertiaryNurseName } = req.body;
      
      if (!departmentName) {
        return res.status(400).json({ error: "Department name is required" });
      }

      if (!HOSPITAL_DEPARTMENTS.includes(departmentName)) {
        return res.status(400).json({ error: `Invalid department: ${departmentName}` });
      }

      const nurseIds = [primaryNurseId, secondaryNurseId, tertiaryNurseId].filter(Boolean);
      const uniqueNurseIds = new Set(nurseIds);
      if (uniqueNurseIds.size !== nurseIds.length) {
        return res.status(400).json({ error: "Each nurse can only occupy one priority per department" });
      }

      const result = await storage.upsertDepartmentNurseAssignment({
        departmentName,
        primaryNurseId: primaryNurseId || null,
        primaryNurseName: primaryNurseId ? (primaryNurseName || null) : null,
        secondaryNurseId: secondaryNurseId || null,
        secondaryNurseName: secondaryNurseId ? (secondaryNurseName || null) : null,
        tertiaryNurseId: tertiaryNurseId || null,
        tertiaryNurseName: tertiaryNurseId ? (tertiaryNurseName || null) : null
      });
      
      res.json(result);
    } catch (error) {
      console.error("Error saving department nurse assignment:", error);
      res.status(500).json({ error: "Failed to save department nurse assignment" });
    }
  });

  app.delete("/api/department-nurse-assignments/:departmentName", requireAuth, requireRole(["ADMIN", "SUPER_ADMIN"]), async (req, res) => {
    try {
      const deleted = await storage.deleteDepartmentNurseAssignment(req.params.departmentName);
      if (!deleted) {
        return res.status(404).json({ error: "Department assignment not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting department assignment:", error);
      res.status(500).json({ error: "Failed to delete department assignment" });
    }
  });

  app.post("/api/department-nurse-assignments/initialize", requireAuth, requireRole(["ADMIN", "SUPER_ADMIN"]), async (req, res) => {
    try {
      await storage.initializeDepartmentNurseAssignments();
      res.json({ success: true, message: "Department nurse assignments initialized successfully" });
    } catch (error) {
      console.error("Error initializing department nurse assignments:", error);
      res.status(500).json({ error: "Failed to initialize department nurse assignments" });
    }
  });

  // ========== SMART OPD FLOW ENGINE ==========

  // Get all OPD department flows
  app.get("/api/opd-flows", requireAuth, async (req, res) => {
    try {
      const flows = await db.select().from(opdDepartmentFlows).where(eq(opdDepartmentFlows.isActive, true)).orderBy(opdDepartmentFlows.sortOrder);
      res.json(flows);
    } catch (error) {
      console.error("Error fetching OPD flows:", error);
      res.status(500).json({ error: "Failed to fetch OPD flows" });
    }
  });

  // Get specific department flow
  app.get("/api/opd-flows/:departmentCode", requireAuth, async (req, res) => {
    try {
      const [flow] = await db.select().from(opdDepartmentFlows).where(eq(opdDepartmentFlows.departmentCode, req.params.departmentCode));
      if (!flow) {
        return res.status(404).json({ error: "Department flow not found" });
      }
      res.json(flow);
    } catch (error) {
      console.error("Error fetching OPD flow:", error);
      res.status(500).json({ error: "Failed to fetch OPD flow" });
    }
  });

  // Seed OPD flows
  app.post("/api/opd-flows/seed", requireAuth, requireRole(["ADMIN", "SUPER_ADMIN"]), async (req, res) => {
    try {
      await seedOpdDepartmentFlows();
      res.json({ success: true, message: "OPD department flows seeded successfully" });
    } catch (error) {
      console.error("Error seeding OPD flows:", error);
      res.status(500).json({ error: "Failed to seed OPD flows" });
    }
  });

  // ========== OPD CONSULTATIONS ==========

  // Get all consultations (with filters)
  app.get("/api/opd-consultations", requireAuth, async (req, res) => {
    try {
      const { doctorId, patientId, status, date } = req.query;
      let query = db.select().from(opdConsultations).orderBy(desc(opdConsultations.consultationDate));
      
      const consultations = await query;
      
      let filtered = consultations;
      if (doctorId) {
        filtered = filtered.filter(c => c.doctorId === doctorId);
      }
      if (patientId) {
        filtered = filtered.filter(c => c.patientId === patientId);
      }
      if (status) {
        filtered = filtered.filter(c => c.status === status);
      }
      if (date) {
        const targetDate = new Date(date as string).toDateString();
        filtered = filtered.filter(c => c.consultationDate && new Date(c.consultationDate).toDateString() === targetDate);
      }
      
      res.json(filtered);
    } catch (error) {
      console.error("Error fetching OPD consultations:", error);
      res.status(500).json({ error: "Failed to fetch OPD consultations" });
    }
  });

  // Get specific consultation
  app.get("/api/opd-consultations/:id", requireAuth, async (req, res) => {
    try {
      const [consultation] = await db.select().from(opdConsultations).where(eq(opdConsultations.id, req.params.id));
      if (!consultation) {
        return res.status(404).json({ error: "Consultation not found" });
      }
      res.json(consultation);
    } catch (error) {
      console.error("Error fetching consultation:", error);
      res.status(500).json({ error: "Failed to fetch consultation" });
    }
  });

  // Create new OPD consultation
  app.post("/api/opd-consultations", requireAuth, requireRole(["DOCTOR", "ADMIN", "SUPER_ADMIN"]), async (req, res) => {
    try {
      const now = new Date();
      const dateStr = now.toISOString().split('T')[0].replace(/-/g, '');
      const randomSuffix = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
      const consultationNumber = `OPD-${dateStr}-${randomSuffix}`;
      
      const consultationData = {
        ...req.body,
        consultationNumber,
        consultationDate: now,
        startTime: now,
        status: 'in_progress'
      };
      
      const [newConsultation] = await db.insert(opdConsultations).values(consultationData).returning();
      res.status(201).json(newConsultation);
    } catch (error) {
      console.error("Error creating OPD consultation:", error);
      res.status(500).json({ error: "Failed to create OPD consultation" });
    }
  });

  // Update OPD consultation
  app.patch("/api/opd-consultations/:id", requireAuth, requireRole(["DOCTOR", "ADMIN", "SUPER_ADMIN"]), async (req, res) => {
    try {
      const updateData = { ...req.body, updatedAt: new Date() };
      
      // If completing the consultation, set end time
      if (req.body.status === 'completed') {
        updateData.endTime = new Date();
      }
      
      const [updated] = await db.update(opdConsultations)
        .set(updateData)
        .where(eq(opdConsultations.id, req.params.id))
        .returning();
      
      if (!updated) {
        return res.status(404).json({ error: "Consultation not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Error updating consultation:", error);
      res.status(500).json({ error: "Failed to update consultation" });
    }
  });

  // Apply flow logic rules to get suggestions
  app.post("/api/opd-flows/apply-rules", requireAuth, async (req, res) => {
    try {
      const { departmentCode, selectedSymptoms, observations } = req.body;
      
      // Get the department flow
      const [flow] = await db.select().from(opdDepartmentFlows).where(eq(opdDepartmentFlows.departmentCode, departmentCode));
      if (!flow) {
        return res.status(404).json({ error: "Department flow not found" });
      }
      
      const flowRules = JSON.parse(flow.flowLogicRules);
      const suggestedTests: any[] = [];
      const suggestedReferrals: any[] = [];
      const alerts: string[] = [];
      
      // Parse symptoms and observations
      const symptomIds = selectedSymptoms.map((s: any) => s.symptomId || s.id);
      const observationMap = new Map(observations.map((o: any) => [o.fieldId || o.id, o.value]));
      
      // Apply each rule
      for (const rule of flowRules) {
        let conditionMet = false;
        
        if (rule.condition?.symptom) {
          const hasSymptom = symptomIds.includes(rule.condition.symptom);
          if (hasSymptom) {
            // Check modifier if present
            if (rule.condition.modifier) {
              const symptom = selectedSymptoms.find((s: any) => (s.symptomId || s.id) === rule.condition.symptom);
              if (symptom && (symptom.severity === rule.condition.modifier || symptom.duration === rule.condition.modifier || symptom.notes?.includes(rule.condition.modifier))) {
                conditionMet = true;
              }
            } else {
              conditionMet = true;
            }
          }
        }
        
        if (rule.condition?.observation) {
          const obsValue = observationMap.get(rule.condition.observation);
          if (obsValue && rule.condition.value) {
            if (rule.condition.value.startsWith('>')) {
              const threshold = parseFloat(rule.condition.value.substring(1).trim());
              if (parseFloat(obsValue) > threshold) conditionMet = true;
            } else if (rule.condition.value.startsWith('>=')) {
              const threshold = parseFloat(rule.condition.value.substring(2).trim());
              if (parseFloat(obsValue) >= threshold) conditionMet = true;
            } else if (obsValue === rule.condition.value || obsValue.includes(rule.condition.value)) {
              conditionMet = true;
            }
          }
        }
        
        if (conditionMet && rule.action) {
          if (rule.action.tests) {
            for (const test of rule.action.tests) {
              if (!suggestedTests.find(t => t.testName === test)) {
                suggestedTests.push({ testName: test, priority: rule.action.priority || 'routine', reason: JSON.stringify(rule.condition) });
              }
            }
          }
          if (rule.action.referral) {
            if (!suggestedReferrals.find(r => r.department === rule.action.referral)) {
              suggestedReferrals.push({ department: rule.action.referral, reason: JSON.stringify(rule.condition) });
            }
          }
          if (rule.action.note) {
            alerts.push(rule.action.note);
          }
        }
      }
      
      res.json({ suggestedTests, suggestedReferrals, alerts });
    } catch (error) {
      console.error("Error applying flow rules:", error);
      res.status(500).json({ error: "Failed to apply flow rules" });
    }
  });

  // Get patient's OPD consultation history
  app.get("/api/patients/:patientId/opd-history", requireAuth, async (req, res) => {
    try {
      const consultations = await db.select()
        .from(opdConsultations)
        .where(eq(opdConsultations.patientId, req.params.patientId))
        .orderBy(desc(opdConsultations.consultationDate));
      res.json(consultations);
    } catch (error) {
      console.error("Error fetching patient OPD history:", error);
      res.status(500).json({ error: "Failed to fetch patient OPD history" });
    }
  });

  // Get doctor's consultations for today
  app.get("/api/doctors/:doctorId/todays-consultations", requireAuth, async (req, res) => {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      const consultations = await db.select()
        .from(opdConsultations)
        .where(eq(opdConsultations.doctorId, req.params.doctorId))
        .orderBy(desc(opdConsultations.consultationDate));
      
      // Filter for today
      const todaysConsultations = consultations.filter(c => {
        if (!c.consultationDate) return false;
        const cDate = new Date(c.consultationDate);
        return cDate >= today && cDate < tomorrow;
      });
      
      res.json(todaysConsultations);
    } catch (error) {
      console.error("Error fetching today's consultations:", error);
      res.status(500).json({ error: "Failed to fetch today's consultations" });
    }
  });

  // ========== TECHNICIAN PORTAL ROUTES ==========
  
  // Get all pending/upcoming tests for technician
  app.get("/api/technician/pending-tests", requireAuth, async (req, res) => {
    try {
      const tests = await storage.getPendingDiagnosticTestOrders();
      // Format for frontend
      const formattedTests = tests.map(test => ({
        id: test.id,
        patientId: test.patientId,
        patientName: test.patientName,
        testName: test.testName,
        testType: test.testType,
        department: test.department,
        orderedBy: test.doctorName,
        orderedDate: test.orderedDate ? new Date(test.orderedDate).toLocaleDateString() : new Date().toLocaleDateString(),
        priority: test.priority || "ROUTINE",
        status: test.status || "PENDING",
        notes: test.clinicalNotes
      }));
      res.json(formattedTests);
    } catch (error) {
      console.error("Error fetching pending tests:", error);
      res.status(500).json({ error: "Failed to fetch pending tests" });
    }
  });

  // Get technician's submitted reports
  app.get("/api/technician/reports/:technicianId", requireAuth, async (req, res) => {
    try {
      const reports = await storage.getTechnicianReportsByTechnician(req.params.technicianId);
      const formattedReports = reports.map(report => ({
        id: report.id,
        patientId: report.patientId,
        patientName: report.patientName,
        testName: report.testName,
        department: report.department,
        technicianId: report.technicianId,
        technicianName: report.technicianName,
        reportDate: report.reportDate ? new Date(report.reportDate).toLocaleDateString() : new Date().toLocaleDateString(),
        findings: report.findings,
        conclusion: report.conclusion,
        recommendations: report.recommendations,
        attachmentUrl: report.fileData,
        fileData: report.fileData,
        fileName: report.fileName,
        status: report.status || "SUBMITTED",
        createdAt: report.createdAt
      }));
      res.json(formattedReports);
    } catch (error) {
      console.error("Error fetching technician reports:", error);
      res.status(500).json({ error: "Failed to fetch technician reports" });
    }
  });

  // Get technician notifications (uses user notifications system)
  app.get("/api/technician/notifications/:userId", requireAuth, async (req, res) => {
    try {
      const notifications = await storage.getUserNotifications(req.params.userId);
      res.json(notifications);
    } catch (error) {
      console.error("Error fetching technician notifications:", error);
      res.status(500).json({ error: "Failed to fetch notifications" });
    }
  });

  // Submit a report for a test
  app.post("/api/technician/submit-report", requireAuth, async (req, res) => {
    try {
      const { testOrderId, findings, conclusion, recommendations, fileName, fileType, fileData, technicianId, technicianName } = req.body;
      
      // Get the test order
      const testOrder = await storage.getDiagnosticTestOrderById(testOrderId);
      if (!testOrder) {
        return res.status(404).json({ error: "Test order not found" });
      }

      // Use recommendations as findings if findings not provided (form uses recommendations field)
      const reportFindings = findings || recommendations || "See attached report";
      const reportConclusion = conclusion || "Report submitted - see attached file for details";

      // Create the report
      const report = await storage.createTechnicianReport({
        testOrderId,
        patientId: testOrder.patientId,
        patientName: testOrder.patientName,
        doctorId: testOrder.doctorId,
        doctorName: testOrder.doctorName,
        testName: testOrder.testName,
        testType: testOrder.testType,
        department: testOrder.department,
        technicianId,
        technicianName,
        findings: reportFindings,
        conclusion: reportConclusion,
        recommendations,
        fileName,
        fileType,
        fileData,
        status: "SUBMITTED",
        reportDate: new Date()
      });

      // Update test order status to COMPLETED and store report URL
      await storage.updateDiagnosticTestOrder(testOrderId, {
        status: "COMPLETED",
        completedDate: new Date(),
        reportUrl: fileData || null,
        reportFileName: fileName || null
      });

      // Send real-time notifications to doctor, patient, and admins
      await notificationService.notifyDiagnosticReportReady({
        id: report.id,
        testOrderId,
        testName: testOrder.testName || "",
        testType: testOrder.testType || "Pathology",
        patientId: testOrder.patientId || "",
        patientName: testOrder.patientName || "",
        doctorId: testOrder.doctorId || "",
        doctorName: testOrder.doctorName || "",
        technicianName,
        reportUrl: fileData
      });

      // Notify Technician (self-confirmation)
      await storage.createUserNotification({
        userId: technicianId,
        userRole: "TECHNICIAN",
        title: "Report Submitted Successfully",
        message: `Your report for ${testOrder.testName} has been submitted.`,
        type: "lab_report",
        isRead: false
      });

      res.json({ success: true, report });
    } catch (error) {
      console.error("Error submitting report:", error);
      res.status(500).json({ error: "Failed to submit report" });
    }
  });

  // Create test order from prescription (called when doctor finalizes prescription with tests)
  // NOTE: Technician notifications are NOT sent here - only tests from Patient Monitoring trigger technician notifications
  app.post("/api/diagnostic-test-orders", requireAuth, async (req, res) => {
    try {
      const orderData = req.body;
      const testOrder = await storage.createDiagnosticTestOrder({
        ...orderData,
        status: "PENDING",
        orderedDate: new Date()
      });

      // Do NOT notify technicians for prescription-based tests
      // Only tests ordered through Patient Monitoring â†’ Tests tab go to Technician Portal

      res.json(testOrder);
    } catch (error) {
      console.error("Error creating test order:", error);
      res.status(500).json({ error: "Failed to create test order" });
    }
  });

  // Get all test orders (for admin)
  app.get("/api/diagnostic-test-orders", requireAuth, async (req, res) => {
    try {
      const orders = await storage.getAllDiagnosticTestOrders();
      res.json(orders);
    } catch (error) {
      console.error("Error fetching test orders:", error);
      res.status(500).json({ error: "Failed to fetch test orders" });
    }
  });

  // Get technician reports by patient (for patient portal) - old endpoint kept for compatibility
  app.get("/api/patients/:patientId/diagnostic-reports", requireAuth, async (req, res) => {
    try {
      const reports = await storage.getTechnicianReportsByPatient(req.params.patientId);
      res.json(reports);
    } catch (error) {
      console.error("Error fetching patient diagnostic reports:", error);
      res.status(500).json({ error: "Failed to fetch diagnostic reports" });
    }
  });

  // Secure session-aware endpoint for patient diagnostic reports
  app.get("/api/patient/my-diagnostic-reports", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      // Match by email, phone, or name (case-insensitive)
      const userEmail = user.email?.toLowerCase()?.trim() || "";
      const userName = user.username?.toLowerCase()?.trim() || "";
      const userFullName = user.fullName?.toLowerCase()?.trim() || "";
      
      // Security guard: require at least one valid identifier
      if (!userEmail && !userName && !userFullName) {
        return res.json([]);
      }

      // Find service patient by email or by name match with user
      const servicePatients = await storage.getAllServicePatients();
      const allReports = await storage.getAllTechnicianReports();
      
      const matchingPatients = servicePatients.filter(p => {
        const patientEmail = p.email?.toLowerCase()?.trim() || "";
        const patientName = `${p.firstName} ${p.lastName}`.toLowerCase().trim();
        
        // Only match if we have non-empty identifiers to compare
        const emailMatch = userEmail.length > 0 && patientEmail.length > 0 && patientEmail === userEmail;
        const nameMatch = userFullName.length > 2 && patientName.length > 2 && (
          patientName.includes(userFullName) || userFullName.includes(patientName)
        );
        const usernameMatch = userName.length > 2 && patientName.length > 2 && patientName.includes(userName);
        
        return emailMatch || nameMatch || usernameMatch;
      });
      
      const patientIds = matchingPatients.map(p => p.id);
      
      // Filter reports for these patients by patient ID only (no name matching to avoid leaks)
      const patientReports = allReports.filter(r => patientIds.includes(r.patientId));
      
      res.json(patientReports);
    } catch (error) {
      console.error("Error fetching patient diagnostic reports:", error);
      res.status(500).json({ error: "Failed to fetch diagnostic reports" });
    }
  });

  // Session-aware endpoint for patient lab reports (pathology)
  app.get("/api/patient/my-lab-reports", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      if (!user) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      // Get user ID for strict matching (PHI security)
      const userId = user.id;
      
      // Security guard: require valid user ID
      if (!userId) {
        return res.json([]);
      }

      // Fetch all lab reports
      const allLabReports = await storage.getAllLabReports();
      
      // Filter reports that belong to this patient
      // STRICT matching: only return reports where patient_id equals user.id
      // This prevents PHI leakage from fuzzy name matching
      const patientReports = allLabReports.filter(report => {
        return report.patientId === userId;
      });
      
      // Sort by most recent first
      patientReports.sort((a, b) => {
        const dateA = a.reportDate ? new Date(a.reportDate).getTime() : 0;
        const dateB = b.reportDate ? new Date(b.reportDate).getTime() : 0;
        return dateB - dateA;
      });
      
      res.json(patientReports);
    } catch (error) {
      console.error("Error fetching patient lab reports:", error);
      res.status(500).json({ error: "Failed to fetch lab reports" });
    }
  });

  // Get technician reports by doctor (for doctor portal)
  app.get("/api/doctors/:doctorId/diagnostic-reports", requireAuth, async (req, res) => {
    try {
      // Get doctor's user info to find associated tests
      const doctorUser = await storage.getUser(req.params.doctorId);
      if (!doctorUser) {
        return res.status(404).json({ error: "Doctor not found" });
      }
      
      // Find reports where doctorId matches or doctor name matches
      const allReports = await storage.getAllTechnicianReports();
      const doctorReports = allReports.filter(r => {
        const doctorNameNormalized = doctorUser.fullName?.toLowerCase().trim() || "";
        const usernameNormalized = doctorUser.username?.toLowerCase().trim() || "";
        const reportDoctorNameNormalized = r.doctorName?.toLowerCase().trim() || "";
        return r.doctorId === req.params.doctorId || 
               reportDoctorNameNormalized.includes(usernameNormalized) ||
               usernameNormalized.includes(reportDoctorNameNormalized.split(" ")[0]);
      });
      res.json(doctorReports);
    } catch (error) {
      console.error("Error fetching doctor diagnostic reports:", error);
      res.status(500).json({ error: "Failed to fetch diagnostic reports" });
    }
  });

  // Secure session-aware endpoint for doctor diagnostic reports
  app.get("/api/doctor/my-diagnostic-reports", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      if (!user || !user.id) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      const userFullName = user.fullName?.toLowerCase().trim() || "";
      const userName = user.username?.toLowerCase().trim() || "";
      
      // Security guard: require at least one valid identifier
      if (!userFullName && !userName && !user.id) {
        return res.json([]);
      }

      // Find reports where doctorId matches the logged-in user
      const allReports = await storage.getAllTechnicianReports();
      
      const doctorReports = allReports.filter(r => {
        // Primary match: doctorId matches user.id (most secure)
        if (r.doctorId === user.id) {
          return true;
        }
        
        // Secondary match: doctorName matches (with length guards)
        const reportDoctorName = r.doctorName?.toLowerCase().trim() || "";
        if (reportDoctorName.length < 3) {
          return false;
        }
        
        // Only match if we have valid names to compare (minimum 3 chars to avoid false positives)
        if (userFullName.length >= 3 && (
          reportDoctorName.includes(userFullName) || userFullName.includes(reportDoctorName)
        )) {
          return true;
        }
        
        if (userName.length >= 3 && reportDoctorName.includes(userName)) {
          return true;
        }
        
        return false;
      });
      res.json(doctorReports);
    } catch (error) {
      console.error("Error fetching doctor diagnostic reports:", error);
      res.status(500).json({ error: "Failed to fetch diagnostic reports" });
    }
  });

  // Get all technician reports (for admin)
  app.get("/api/technician-reports", requireAuth, async (req, res) => {
    try {
      const reports = await storage.getAllTechnicianReports();
      res.json(reports);
    } catch (error) {
      console.error("Error fetching all technician reports:", error);
      res.status(500).json({ error: "Failed to fetch reports" });
    }
  });

  // Update test order status
  app.patch("/api/diagnostic-test-orders/:id", requireAuth, async (req, res) => {
    try {
      const updated = await storage.updateDiagnosticTestOrder(req.params.id, req.body);
      res.json(updated);
    } catch (error) {
      console.error("Error updating test order:", error);
      res.status(500).json({ error: "Failed to update test order" });
    }
  });

  // Get service patients for technician portal search
  app.get("/api/technician/patients", requireAuth, async (req, res) => {
    try {
      const patients = await storage.getAllServicePatients();
      res.json(patients);
    } catch (error) {
      console.error("Error fetching patients for technician:", error);
      res.status(500).json({ error: "Failed to fetch patients" });
    }
  });

  // ========== ICU MONITORING SYSTEM ==========

  // ========== ICU DROPDOWN DATA ENDPOINTS ==========
  
  // Get admitted patients for ICU chart creation - patients currently in ICU
  app.get("/api/icu/admitted-patients", requireAuth, async (req, res) => {
    try {
      // Fetch patients with isInIcu = true from tracking_patients
      const patients = await storage.getAdmittedPatientsWithDetails();
      res.json(patients);
    } catch (error) {
      console.error("Error fetching admitted patients:", error);
      res.status(500).json({ error: "Failed to fetch admitted patients" });
    }
  });

  // Get available ICU beds
  app.get("/api/icu/available-beds", requireAuth, async (req, res) => {
    try {
      const beds = await storage.getAvailableIcuBeds();
      res.json(beds);
    } catch (error) {
      console.error("Error fetching available ICU beds:", error);
      res.status(500).json({ error: "Failed to fetch available ICU beds" });
    }
  });

  // Get ICU doctors
  app.get("/api/icu/doctors", requireAuth, async (req, res) => {
    try {
      const doctors = await storage.getIcuDoctors();
      res.json(doctors);
    } catch (error) {
      console.error("Error fetching ICU doctors:", error);
      res.status(500).json({ error: "Failed to fetch ICU doctors" });
    }
  });

  // Get ICU nurses (nurses with ICU in department preferences)
  app.get("/api/icu/nurses", requireAuth, async (req, res) => {
    try {
      const nurses = await storage.getIcuNurses();
      res.json(nurses);
    } catch (error) {
      console.error("Error fetching ICU nurses:", error);
      res.status(500).json({ error: "Failed to fetch ICU nurses" });
    }
  });

  // Get all beds (for bed management)
  app.get("/api/beds", requireAuth, async (req, res) => {
    try {
      const beds = await storage.getAllBeds();
      res.json(beds);
    } catch (error) {
      console.error("Error fetching beds:", error);
      res.status(500).json({ error: "Failed to fetch beds" });
    }
  });

  // ICU Charts - Main record management
  app.post("/api/icu-charts", requireAuth, async (req, res) => {
    try {
      // Check if patient already has an active ICU chart to prevent duplicates
      const existingCharts = await storage.getAllIcuCharts();
      const existingChart = existingCharts.find(
        c => c.patientId === req.body.patientId || c.patientName === req.body.patientName
      );
      
      if (existingChart) {
        // Return existing chart instead of creating duplicate
        return res.status(200).json(existingChart);
      }
      
      const chart = await storage.createIcuChart(req.body);
      res.status(201).json(chart);
    } catch (error) {
      console.error("Error creating ICU chart:", error);
      res.status(500).json({ error: "Failed to create ICU chart" });
    }
  });

  app.get("/api/icu-charts", requireAuth, async (req, res) => {
    try {
      const charts = await storage.getAllIcuCharts();
      // Only return charts for patients currently in ICU
      const trackingPatients = await storage.getAllTrackingPatients();
      const patientsInIcu = new Set(
        trackingPatients
          .filter(p => p.isInIcu === true)
          .map(p => p.id)
      );
      // Also include patients matched by name for legacy compatibility
      const patientsInIcuByName = new Set(
        trackingPatients
          .filter(p => p.isInIcu === true)
          .map(p => p.name.toLowerCase())
      );
      const activeCharts = charts.filter(chart => 
        patientsInIcu.has(chart.patientId || '') || 
        patientsInIcuByName.has((chart.patientName || '').toLowerCase())
      );
      res.json(activeCharts);
    } catch (error) {
      console.error("Error fetching ICU charts:", error);
      res.status(500).json({ error: "Failed to fetch ICU charts" });
    }
  });

  app.get("/api/icu-charts/:id", requireAuth, async (req, res) => {
    try {
      const chart = await storage.getIcuChartById(req.params.id);
      if (!chart) {
        return res.status(404).json({ error: "ICU chart not found" });
      }
      res.json(chart);
    } catch (error) {
      console.error("Error fetching ICU chart:", error);
      res.status(500).json({ error: "Failed to fetch ICU chart" });
    }
  });

  app.get("/api/icu-charts/:id/complete", requireAuth, async (req, res) => {
    try {
      const completeChart = await storage.getCompleteIcuChart(req.params.id);
      if (!completeChart) {
        return res.status(404).json({ error: "ICU chart not found" });
      }
      res.json(completeChart);
    } catch (error) {
      console.error("Error fetching complete ICU chart:", error);
      res.status(500).json({ error: "Failed to fetch complete ICU chart" });
    }
  });

  app.get("/api/patients/:patientId/icu-charts", requireAuth, async (req, res) => {
    try {
      const charts = await storage.getIcuChartsByPatient(req.params.patientId);
      res.json(charts);
    } catch (error) {
      console.error("Error fetching patient ICU charts:", error);
      res.status(500).json({ error: "Failed to fetch patient ICU charts" });
    }
  });

  app.patch("/api/icu-charts/:id", requireAuth, async (req, res) => {
    try {
      const chart = await storage.updateIcuChart(req.params.id, req.body);
      res.json(chart);
    } catch (error) {
      console.error("Error updating ICU chart:", error);
      res.status(500).json({ error: "Failed to update ICU chart" });
    }
  });

  app.delete("/api/icu-charts/:id", requireAuth, async (req, res) => {
    try {
      await storage.deleteIcuChart(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting ICU chart:", error);
      res.status(500).json({ error: "Failed to delete ICU chart" });
    }
  });

  // ICU Patient Tests - Get tests for ICU chart
  app.get("/api/icu-charts/:chartId/tests", requireAuth, async (req, res) => {
    try {
      const tests = await storage.getDiagnosticTestOrdersByIcuChart(req.params.chartId);
      res.json(tests);
    } catch (error) {
      console.error("Error fetching ICU tests:", error);
      res.status(500).json({ error: "Failed to fetch ICU tests" });
    }
  });

  // ICU Patient Tests - Order new test from ICU
  app.post("/api/icu-charts/:chartId/tests", requireAuth, async (req, res) => {
    try {
      const chart = await storage.getIcuChartById(req.params.chartId);
      if (!chart) {
        return res.status(404).json({ error: "ICU chart not found" });
      }
      const testOrder = await storage.createDiagnosticTestOrder({
        ...req.body,
        icuChartId: req.params.chartId,
        source: "ICU",
        patientId: chart.patientId || "",
        patientName: chart.patientName || "",
        patientAge: chart.age?.toString() || "",
        patientGender: chart.sex || "",
      });
      res.status(201).json(testOrder);
    } catch (error) {
      console.error("Error creating ICU test order:", error);
      res.status(500).json({ error: "Failed to create test order" });
    }
  });

  // Update test status (sample collected, in progress, etc.)
  app.patch("/api/diagnostic-test-orders/:id/status", requireAuth, async (req, res) => {
    try {
      const { status, sampleCollectedBy } = req.body;
      const updates: any = { status, updatedAt: new Date() };
      if (status === "SAMPLE_COLLECTED") {
        updates.sampleCollectedAt = new Date();
        updates.sampleCollectedBy = sampleCollectedBy;
      }
      const test = await storage.updateDiagnosticTestOrder(req.params.id, updates);
      res.json(test);
    } catch (error) {
      console.error("Error updating test status:", error);
      res.status(500).json({ error: "Failed to update test status" });
    }
  });

  // ICU Vital Charts
  app.post("/api/icu-charts/:chartId/vitals", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuVitalChart({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating ICU vital entry:", error);
      res.status(500).json({ error: "Failed to create vital entry" });
    }
  });

  app.get("/api/icu-charts/:chartId/vitals", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuVitalChartsByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching ICU vitals:", error);
      res.status(500).json({ error: "Failed to fetch vitals" });
    }
  });

  app.patch("/api/icu-vitals/:id", requireAuth, async (req, res) => {
    try {
      const entry = await storage.updateIcuVitalChart(req.params.id, req.body);
      res.json(entry);
    } catch (error) {
      console.error("Error updating ICU vital:", error);
      res.status(500).json({ error: "Failed to update vital" });
    }
  });

  app.delete("/api/icu-vitals/:id", requireAuth, async (req, res) => {
    try {
      await storage.deleteIcuVitalChart(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting ICU vital:", error);
      res.status(500).json({ error: "Failed to delete vital" });
    }
  });

  // ICU Hemodynamic Monitoring
  app.post("/api/icu-charts/:chartId/hemodynamic", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuHemodynamicEntry({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating hemodynamic entry:", error);
      res.status(500).json({ error: "Failed to create hemodynamic entry" });
    }
  });

  app.get("/api/icu-charts/:chartId/hemodynamic", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuHemodynamicByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching hemodynamic data:", error);
      res.status(500).json({ error: "Failed to fetch hemodynamic data" });
    }
  });

  // ICU Sedation Monitoring
  app.post("/api/icu-charts/:chartId/sedation", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuSedationEntry({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating sedation entry:", error);
      res.status(500).json({ error: "Failed to create sedation entry" });
    }
  });

  app.get("/api/icu-charts/:chartId/sedation", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuSedationByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching sedation data:", error);
      res.status(500).json({ error: "Failed to fetch sedation data" });
    }
  });

  // ICU Ventilator Settings
  app.post("/api/icu-charts/:chartId/ventilator", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuVentilatorEntry({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating ventilator entry:", error);
      res.status(500).json({ error: "Failed to create ventilator entry" });
    }
  });

  app.get("/api/icu-charts/:chartId/ventilator", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuVentilatorByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching ventilator data:", error);
      res.status(500).json({ error: "Failed to fetch ventilator data" });
    }
  });

  app.patch("/api/icu-ventilator/:id", requireAuth, async (req, res) => {
    try {
      const entry = await storage.updateIcuVentilatorEntry(req.params.id, req.body);
      res.json(entry);
    } catch (error) {
      console.error("Error updating ventilator entry:", error);
      res.status(500).json({ error: "Failed to update ventilator entry" });
    }
  });

  app.patch("/api/icu-hemodynamic/:id", requireAuth, async (req, res) => {
    try {
      const entry = await storage.updateIcuHemodynamicEntry(req.params.id, req.body);
      res.json(entry);
    } catch (error) {
      console.error("Error updating hemodynamic entry:", error);
      res.status(500).json({ error: "Failed to update hemodynamic entry" });
    }
  });

  // ICU ABG Reports
  app.post("/api/icu-charts/:chartId/abg", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuAbgReport({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating ABG report:", error);
      res.status(500).json({ error: "Failed to create ABG report" });
    }
  });

  app.get("/api/icu-charts/:chartId/abg", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuAbgByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching ABG reports:", error);
      res.status(500).json({ error: "Failed to fetch ABG reports" });
    }
  });

  app.patch("/api/icu-abg/:id", requireAuth, async (req, res) => {
    try {
      const entry = await storage.updateIcuAbgReport(req.params.id, req.body);
      res.json(entry);
    } catch (error) {
      console.error("Error updating ABG report:", error);
      res.status(500).json({ error: "Failed to update ABG report" });
    }
  });

  app.patch("/api/icu-diabetic/:id", requireAuth, async (req, res) => {
    try {
      const entry = await storage.updateIcuDiabeticEntry(req.params.id, req.body);
      res.json(entry);
    } catch (error) {
      console.error("Error updating diabetic entry:", error);
      res.status(500).json({ error: "Failed to update diabetic entry" });
    }
  });

  app.patch("/api/icu-intake/:id", requireAuth, async (req, res) => {
    try {
      const entry = await storage.updateIcuIntakeEntry(req.params.id, req.body);
      res.json(entry);
    } catch (error) {
      console.error("Error updating intake entry:", error);
      res.status(500).json({ error: "Failed to update intake entry" });
    }
  });

  app.patch("/api/icu-output/:id", requireAuth, async (req, res) => {
    try {
      const entry = await storage.updateIcuOutputEntry(req.params.id, req.body);
      res.json(entry);
    } catch (error) {
      console.error("Error updating output entry:", error);
      res.status(500).json({ error: "Failed to update output entry" });
    }
  });

  app.patch("/api/icu-medication/:id", requireAuth, async (req, res) => {
    try {
      const entry = await storage.updateIcuMedicationOrder(req.params.id, req.body);
      res.json(entry);
    } catch (error) {
      console.error("Error updating medication order:", error);
      res.status(500).json({ error: "Failed to update medication order" });
    }
  });

  app.patch("/api/icu-nursing-remark/:id", requireAuth, async (req, res) => {
    try {
      const entry = await storage.updateIcuNursingRemark(req.params.id, req.body);
      res.json(entry);
    } catch (error) {
      console.error("Error updating nursing remark:", error);
      res.status(500).json({ error: "Failed to update nursing remark" });
    }
  });

  app.patch("/api/icu-nurse-diary/:id", requireAuth, async (req, res) => {
    try {
      const entry = await storage.updateIcuNurseDiaryEntry(req.params.id, req.body);
      res.json(entry);
    } catch (error) {
      console.error("Error updating nurse diary entry:", error);
      res.status(500).json({ error: "Failed to update nurse diary entry" });
    }
  });

  app.patch("/api/icu-body-marking/:id", requireAuth, async (req, res) => {
    try {
      const entry = await storage.updateIcuBodyMarking(req.params.id, req.body);
      res.json(entry);
    } catch (error) {
      console.error("Error updating body marking:", error);
      res.status(500).json({ error: "Failed to update body marking" });
    }
  });

  app.post("/api/icu-body-marking", requireAuth, async (req, res) => {
    try {
      const { chartId, markedArea, typeOfInjury, grade, positionX, positionY } = req.body;
      const entry = await storage.createIcuBodyMarking({
        icuChartId: chartId,
        markedArea,
        typeOfInjury,
        grade,
        positionX,
        positionY,
        date: new Date().toLocaleDateString("en-IN"),
        recordedBy: req.user?.id
      });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating body marking:", error);
      res.status(500).json({ error: "Failed to create body marking" });
    }
  });

  // ICU Airway Care
  app.post("/api/icu-charts/:chartId/airway-care", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuAirwayCare({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating airway care entry:", error);
      res.status(500).json({ error: "Failed to create airway care entry" });
    }
  });

  app.get("/api/icu-charts/:chartId/airway-care", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuAirwayCareByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching airway care data:", error);
      res.status(500).json({ error: "Failed to fetch airway care data" });
    }
  });

  // ICU Daily Investigations
  app.post("/api/icu-charts/:chartId/daily-investigations", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuDailyInvestigation({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating daily investigation:", error);
      res.status(500).json({ error: "Failed to create daily investigation" });
    }
  });

  app.get("/api/icu-charts/:chartId/daily-investigations", requireAuth, async (req, res) => {
    try {
      const entry = await storage.getIcuDailyInvestigationByChartId(req.params.chartId);
      res.json(entry);
    } catch (error) {
      console.error("Error fetching daily investigation:", error);
      res.status(500).json({ error: "Failed to fetch daily investigation" });
    }
  });

  // ICU Diabetic Chart
  app.post("/api/icu-charts/:chartId/diabetic", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuDiabeticEntry({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating diabetic entry:", error);
      res.status(500).json({ error: "Failed to create diabetic entry" });
    }
  });

  app.get("/api/icu-charts/:chartId/diabetic", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuDiabeticByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching diabetic data:", error);
      res.status(500).json({ error: "Failed to fetch diabetic data" });
    }
  });

  // ICU Intake Chart
  app.post("/api/icu-charts/:chartId/intake", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuIntakeEntry({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating intake entry:", error);
      res.status(500).json({ error: "Failed to create intake entry" });
    }
  });

  app.get("/api/icu-charts/:chartId/intake", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuIntakeByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching intake data:", error);
      res.status(500).json({ error: "Failed to fetch intake data" });
    }
  });

  // ICU Output Chart
  app.post("/api/icu-charts/:chartId/output", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuOutputEntry({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating output entry:", error);
      res.status(500).json({ error: "Failed to create output entry" });
    }
  });

  app.get("/api/icu-charts/:chartId/output", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuOutputByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching output data:", error);
      res.status(500).json({ error: "Failed to fetch output data" });
    }
  });

  // ICU Medication Orders
  app.post("/api/icu-charts/:chartId/medication-orders", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuMedicationOrder({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating medication order:", error);
      res.status(500).json({ error: "Failed to create medication order" });
    }
  });

  app.get("/api/icu-charts/:chartId/medication-orders", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuMedicationOrdersByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching medication orders:", error);
      res.status(500).json({ error: "Failed to fetch medication orders" });
    }
  });

  // ICU Nursing Remarks
  app.post("/api/icu-charts/:chartId/nursing-remarks", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuNursingRemark({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating nursing remark:", error);
      res.status(500).json({ error: "Failed to create nursing remark" });
    }
  });

  app.get("/api/icu-charts/:chartId/nursing-remarks", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuNursingRemarksByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching nursing remarks:", error);
      res.status(500).json({ error: "Failed to fetch nursing remarks" });
    }
  });

  // ICU Nursing Duty
  app.post("/api/icu-charts/:chartId/nursing-duty", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuNursingDuty({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating nursing duty:", error);
      res.status(500).json({ error: "Failed to create nursing duty" });
    }
  });

  app.get("/api/icu-charts/:chartId/nursing-duty", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuNursingDutyByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching nursing duty:", error);
      res.status(500).json({ error: "Failed to fetch nursing duty" });
    }
  });

  // ICU Fluid Orders
  app.post("/api/icu-charts/:chartId/fluid-orders", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuFluidOrder({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating fluid order:", error);
      res.status(500).json({ error: "Failed to create fluid order" });
    }
  });

  app.get("/api/icu-charts/:chartId/fluid-orders", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuFluidOrdersByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching fluid orders:", error);
      res.status(500).json({ error: "Failed to fetch fluid orders" });
    }
  });

  // ICU Nutrition Chart
  app.post("/api/icu-charts/:chartId/nutrition", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuNutritionEntry({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating nutrition entry:", error);
      res.status(500).json({ error: "Failed to create nutrition entry" });
    }
  });

  app.get("/api/icu-charts/:chartId/nutrition", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuNutritionByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching nutrition data:", error);
      res.status(500).json({ error: "Failed to fetch nutrition data" });
    }
  });

  // ICU Body Marking
  app.post("/api/icu-charts/:chartId/body-marking", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuBodyMarking({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating body marking:", error);
      res.status(500).json({ error: "Failed to create body marking" });
    }
  });

  app.get("/api/icu-charts/:chartId/body-marking", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuBodyMarkingsByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching body markings:", error);
      res.status(500).json({ error: "Failed to fetch body markings" });
    }
  });

  // ICU Nurse Diary
  app.post("/api/icu-charts/:chartId/nurse-diary", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuNurseDiaryEntry({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating nurse diary entry:", error);
      res.status(500).json({ error: "Failed to create nurse diary entry" });
    }
  });

  app.get("/api/icu-charts/:chartId/nurse-diary", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuNurseDiaryByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching nurse diary:", error);
      res.status(500).json({ error: "Failed to fetch nurse diary" });
    }
  });

  // ICU Once Only Drugs
  app.post("/api/icu-charts/:chartId/once-only-drugs", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuOnceOnlyDrug({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating once only drug:", error);
      res.status(500).json({ error: "Failed to create once only drug" });
    }
  });

  app.get("/api/icu-charts/:chartId/once-only-drugs", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getIcuOnceOnlyDrugsByChartId(req.params.chartId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching once only drugs:", error);
      res.status(500).json({ error: "Failed to fetch once only drugs" });
    }
  });

  // ICU Allergy Precautions
  app.post("/api/icu-charts/:chartId/allergy-precautions", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuAllergyPrecautions({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating allergy precautions:", error);
      res.status(500).json({ error: "Failed to create allergy precautions" });
    }
  });

  app.get("/api/icu-charts/:chartId/allergy-precautions", requireAuth, async (req, res) => {
    try {
      const entry = await storage.getIcuAllergyPrecautionsByChartId(req.params.chartId);
      res.json(entry);
    } catch (error) {
      console.error("Error fetching allergy precautions:", error);
      res.status(500).json({ error: "Failed to fetch allergy precautions" });
    }
  });

  // ICU Play of Day
  app.post("/api/icu-charts/:chartId/play-of-day", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuPlayOfDay({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating play of day:", error);
      res.status(500).json({ error: "Failed to create play of day" });
    }
  });

  app.get("/api/icu-charts/:chartId/play-of-day", requireAuth, async (req, res) => {
    try {
      const entry = await storage.getIcuPlayOfDayByChartId(req.params.chartId);
      res.json(entry);
    } catch (error) {
      console.error("Error fetching play of day:", error);
      res.status(500).json({ error: "Failed to fetch play of day" });
    }
  });

  // ICU Cuff Pressure
  app.post("/api/icu-charts/:chartId/cuff-pressure", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuCuffPressure({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating cuff pressure:", error);
      res.status(500).json({ error: "Failed to create cuff pressure" });
    }
  });

  app.get("/api/icu-charts/:chartId/cuff-pressure", requireAuth, async (req, res) => {
    try {
      const entry = await storage.getIcuCuffPressureByChartId(req.params.chartId);
      res.json(entry);
    } catch (error) {
      console.error("Error fetching cuff pressure:", error);
      res.status(500).json({ error: "Failed to fetch cuff pressure" });
    }
  });

  // ICU ETT/Tracheostomy
  app.post("/api/icu-charts/:chartId/ett-tracheostomy", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuEttTracheostomy({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating ETT/Tracheostomy:", error);
      res.status(500).json({ error: "Failed to create ETT/Tracheostomy" });
    }
  });

  app.get("/api/icu-charts/:chartId/ett-tracheostomy", requireAuth, async (req, res) => {
    try {
      const entry = await storage.getIcuEttTracheostomyByChartId(req.params.chartId);
      res.json(entry);
    } catch (error) {
      console.error("Error fetching ETT/Tracheostomy:", error);
      res.status(500).json({ error: "Failed to fetch ETT/Tracheostomy" });
    }
  });

  // ICU Duration
  app.post("/api/icu-charts/:chartId/duration", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuDuration({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating ICU duration:", error);
      res.status(500).json({ error: "Failed to create ICU duration" });
    }
  });

  app.get("/api/icu-charts/:chartId/duration", requireAuth, async (req, res) => {
    try {
      const entry = await storage.getIcuDurationByChartId(req.params.chartId);
      res.json(entry);
    } catch (error) {
      console.error("Error fetching ICU duration:", error);
      res.status(500).json({ error: "Failed to fetch ICU duration" });
    }
  });

  // ICU Fluid Balance Target
  app.post("/api/icu-charts/:chartId/fluid-balance-target", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuFluidBalanceTarget({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating fluid balance target:", error);
      res.status(500).json({ error: "Failed to create fluid balance target" });
    }
  });

  app.get("/api/icu-charts/:chartId/fluid-balance-target", requireAuth, async (req, res) => {
    try {
      const entry = await storage.getIcuFluidBalanceTargetByChartId(req.params.chartId);
      res.json(entry);
    } catch (error) {
      console.error("Error fetching fluid balance target:", error);
      res.status(500).json({ error: "Failed to fetch fluid balance target" });
    }
  });

  // ICU Previous Day Notes
  app.post("/api/icu-charts/:chartId/previous-day-notes", requireAuth, async (req, res) => {
    try {
      const entry = await storage.createIcuPreviousDayNotes({ ...req.body, icuChartId: req.params.chartId });
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating previous day notes:", error);
      res.status(500).json({ error: "Failed to create previous day notes" });
    }
  });

  app.get("/api/icu-charts/:chartId/previous-day-notes", requireAuth, async (req, res) => {
    try {
      const entry = await storage.getIcuPreviousDayNotesByChartId(req.params.chartId);
      res.json(entry);
    } catch (error) {
      console.error("Error fetching previous day notes:", error);
      res.status(500).json({ error: "Failed to fetch previous day notes" });
    }
  });

  // ICU Doctor & Nurse Notes
  app.post("/api/icu-charts/:chartId/notes", requireAuth, async (req, res) => {
    try {
      // Get user name for recording
      let recordedByName = "";
      if (req.body.recordedBy) {
        const user = await storage.getUser(req.body.recordedBy);
        if (user) {
          recordedByName = user.fullName || user.username || "";
        }
      }
      const noteData = {
        icuChartId: req.params.chartId,
        noteType: req.body.noteType || "nurse",
        content: req.body.content,
        priority: req.body.priority || "normal",
        shiftTime: req.body.shiftTime || null,
        recordedBy: req.body.recordedBy || null,
        recordedByName: recordedByName || null
      };
      console.log("Creating ICU note with data:", noteData);
      const entry = await (storage as any).createIcuDoctorNurseNote(noteData);
      res.status(201).json(entry);
    } catch (error: any) {
      console.error("Error creating doctor/nurse note:", error?.message || error);
      res.status(500).json({ error: "Failed to create note", details: error?.message });
    }
  });

  app.get("/api/icu-charts/:chartId/notes", requireAuth, async (req, res) => {
    try {
      const notes = await (storage as any).getIcuDoctorNurseNotesByChartId(req.params.chartId);
      res.json(notes);
    } catch (error) {
      console.error("Error fetching doctor/nurse notes:", error);
      res.status(500).json({ error: "Failed to fetch notes" });
    }
  });

  // ========== OPERATION & OT MODULE ==========

  // Helper to check OT access (SUPER_ADMIN, ADMIN, DOCTOR allowed)
  const checkOtAccess = (role: string) => {
    return ["SUPER_ADMIN", "ADMIN", "DOCTOR", "NURSE"].includes(role);
  };

  // Create OT audit log helper
  const logOtAction = async (caseId: string, action: string, userId: string, entityType: string, entityId: string, changes?: any) => {
    try {
      await storage.createOtAuditLog({
        id: crypto.randomUUID(),
        caseId,
        entityType,
        entityId,
        action,
        userId,
        metadata: changes ? JSON.stringify(changes) : null
      });
    } catch (e) {
      console.error("OT Audit log error:", e);
    }
  };

  // OT Cases
  app.get("/api/ot-cases", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      if (!checkOtAccess(user.role)) {
        return res.status(403).json({ error: "Insufficient permissions" });
      }
      
      const { status, date, surgeonId, patientId } = req.query;
      let cases;
      
      if (status) {
        cases = await storage.getOtCasesByStatus(status as string);
      } else if (date) {
        cases = await storage.getOtCasesByDate(date as string);
      } else if (surgeonId) {
        cases = await storage.getOtCasesBySurgeon(surgeonId as string);
      } else if (patientId) {
        cases = await storage.getOtCasesByPatient(patientId as string);
      } else {
        cases = await storage.getOtCases();
      }
      
      res.json(cases);
    } catch (error) {
      console.error("Error fetching OT cases:", error);
      res.status(500).json({ error: "Failed to fetch OT cases" });
    }
  });

  app.get("/api/ot-cases/:id", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      if (!checkOtAccess(user.role)) {
        return res.status(403).json({ error: "Insufficient permissions" });
      }
      
      const otCase = await storage.getOtCaseById(req.params.id);
      if (!otCase) {
        return res.status(404).json({ error: "OT case not found" });
      }
      res.json(otCase);
    } catch (error) {
      console.error("Error fetching OT case:", error);
      res.status(500).json({ error: "Failed to fetch OT case" });
    }
  });

  app.post("/api/ot-cases", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      if (!["SUPER_ADMIN", "ADMIN", "DOCTOR"].includes(user.role)) {
        return res.status(403).json({ error: "Insufficient permissions" });
      }
      
      const caseId = crypto.randomUUID();
      const otCase = await storage.createOtCase({
        id: caseId,
        ...req.body,
        createdBy: user.id
      });
      
      await logOtAction(caseId, "CREATE", user.id, "ot_cases", caseId, req.body);
      res.status(201).json(otCase);
    } catch (error) {
      console.error("Error creating OT case:", error);
      res.status(500).json({ error: "Failed to create OT case" });
    }
  });

  app.patch("/api/ot-cases/:id", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      if (!["SUPER_ADMIN", "ADMIN", "DOCTOR"].includes(user.role)) {
        return res.status(403).json({ error: "Insufficient permissions" });
      }
      
      const otCase = await storage.updateOtCase(req.params.id, req.body);
      if (!otCase) {
        return res.status(404).json({ error: "OT case not found" });
      }
      
      await logOtAction(req.params.id, "UPDATE", user.id, "ot_cases", req.params.id, req.body);
      res.json(otCase);
    } catch (error) {
      console.error("Error updating OT case:", error);
      res.status(500).json({ error: "Failed to update OT case" });
    }
  });

  app.patch("/api/ot-cases/:id/status", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      if (!["SUPER_ADMIN", "ADMIN", "DOCTOR"].includes(user.role)) {
        return res.status(403).json({ error: "Insufficient permissions" });
      }
      
      const { status } = req.body;
      const otCase = await storage.updateOtCaseStatus(req.params.id, status);
      if (!otCase) {
        return res.status(404).json({ error: "OT case not found" });
      }
      
      await logOtAction(req.params.id, "STATUS_CHANGE", user.id, "ot_cases", req.params.id, { status });
      res.json(otCase);
    } catch (error) {
      console.error("Error updating OT case status:", error);
      res.status(500).json({ error: "Failed to update status" });
    }
  });

  // OT Case Team
  app.get("/api/ot-cases/:caseId/team", requireAuth, async (req, res) => {
    try {
      const team = await storage.getOtCaseTeam(req.params.caseId);
      res.json(team);
    } catch (error) {
      console.error("Error fetching OT team:", error);
      res.status(500).json({ error: "Failed to fetch team" });
    }
  });

  app.post("/api/ot-cases/:caseId/team", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      if (!["SUPER_ADMIN", "ADMIN", "DOCTOR"].includes(user.role)) {
        return res.status(403).json({ error: "Insufficient permissions" });
      }
      
      const teamMemberId = crypto.randomUUID();
      const member = await storage.addOtCaseTeamMember({
        id: teamMemberId,
        caseId: req.params.caseId,
        ...req.body
      });
      
      await logOtAction(req.params.caseId, "ADD_TEAM_MEMBER", user.id, "ot_case_team", teamMemberId, req.body);
      res.status(201).json(member);
    } catch (error) {
      console.error("Error adding team member:", error);
      res.status(500).json({ error: "Failed to add team member" });
    }
  });

  app.delete("/api/ot-cases/:caseId/team/:memberId", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      if (!["SUPER_ADMIN", "ADMIN", "DOCTOR"].includes(user.role)) {
        return res.status(403).json({ error: "Insufficient permissions" });
      }
      
      const success = await storage.removeOtCaseTeamMember(req.params.memberId);
      if (success) {
        await logOtAction(req.params.caseId, "REMOVE_TEAM_MEMBER", user.id, "ot_case_team", req.params.memberId);
      }
      res.json({ success });
    } catch (error) {
      console.error("Error removing team member:", error);
      res.status(500).json({ error: "Failed to remove team member" });
    }
  });

  // Pre-Op Counselling
  app.get("/api/ot-cases/:caseId/preop-counselling", requireAuth, async (req, res) => {
    try {
      const counselling = await storage.getOtPreopCounselling(req.params.caseId);
      res.json(counselling || null);
    } catch (error) {
      console.error("Error fetching counselling:", error);
      res.status(500).json({ error: "Failed to fetch counselling" });
    }
  });

  app.post("/api/ot-cases/:caseId/preop-counselling", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const recordId = crypto.randomUUID();
      const counselling = await storage.createOtPreopCounselling({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body,
        counselledBy: user.id
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_preop_counselling", recordId, req.body);
      res.status(201).json(counselling);
    } catch (error) {
      console.error("Error creating counselling:", error);
      res.status(500).json({ error: "Failed to create counselling" });
    }
  });

  app.patch("/api/ot-cases/:caseId/preop-counselling/:id", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const counselling = await storage.updateOtPreopCounselling(req.params.id, req.body);
      
      await logOtAction(req.params.caseId, "UPDATE", user.id, "ot_preop_counselling", req.params.id, req.body);
      res.json(counselling);
    } catch (error) {
      console.error("Error updating counselling:", error);
      res.status(500).json({ error: "Failed to update counselling" });
    }
  });

  // Pre-Op Checklist
  app.get("/api/ot-cases/:caseId/preop-checklist", requireAuth, async (req, res) => {
    try {
      const checklist = await storage.getOtPreopChecklist(req.params.caseId);
      res.json(checklist || null);
    } catch (error) {
      console.error("Error fetching checklist:", error);
      res.status(500).json({ error: "Failed to fetch checklist" });
    }
  });

  app.post("/api/ot-cases/:caseId/preop-checklist", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const recordId = crypto.randomUUID();
      const checklist = await storage.createOtPreopChecklist({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body,
        completedBy: user.id
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_preop_checklist", recordId, req.body);
      res.status(201).json(checklist);
    } catch (error) {
      console.error("Error creating checklist:", error);
      res.status(500).json({ error: "Failed to create checklist" });
    }
  });

  app.patch("/api/ot-cases/:caseId/preop-checklist/:id", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const checklist = await storage.updateOtPreopChecklist(req.params.id, req.body);
      
      await logOtAction(req.params.caseId, "UPDATE", user.id, "ot_preop_checklist", req.params.id, req.body);
      res.json(checklist);
    } catch (error) {
      console.error("Error updating checklist:", error);
      res.status(500).json({ error: "Failed to update checklist" });
    }
  });

  // Pre-Anaesthetic Evaluation
  app.get("/api/ot-cases/:caseId/preanaesthetic-eval", requireAuth, async (req, res) => {
    try {
      const evalData = await storage.getOtPreanaestheticEval(req.params.caseId);
      res.json(evalData || null);
    } catch (error) {
      console.error("Error fetching PAE:", error);
      res.status(500).json({ error: "Failed to fetch PAE" });
    }
  });

  app.post("/api/ot-cases/:caseId/preanaesthetic-eval", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const recordId = crypto.randomUUID();
      const evalData = await storage.createOtPreanaestheticEval({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body,
        evaluatedBy: user.id
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_preanaesthetic_eval", recordId, req.body);
      res.status(201).json(evalData);
    } catch (error) {
      console.error("Error creating PAE:", error);
      res.status(500).json({ error: "Failed to create PAE" });
    }
  });

  app.patch("/api/ot-cases/:caseId/preanaesthetic-eval/:id", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const evalData = await storage.updateOtPreanaestheticEval(req.params.id, req.body);
      
      await logOtAction(req.params.caseId, "UPDATE", user.id, "ot_preanaesthetic_eval", req.params.id, req.body);
      res.json(evalData);
    } catch (error) {
      console.error("Error updating PAE:", error);
      res.status(500).json({ error: "Failed to update PAE" });
    }
  });

  // Safety Checklist (WHO Surgical Safety Checklist)
  app.get("/api/ot-cases/:caseId/safety-checklist", requireAuth, async (req, res) => {
    try {
      const checklist = await storage.getOtSafetyChecklist(req.params.caseId);
      res.json(checklist || null);
    } catch (error) {
      console.error("Error fetching safety checklist:", error);
      res.status(500).json({ error: "Failed to fetch safety checklist" });
    }
  });

  app.post("/api/ot-cases/:caseId/safety-checklist", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const recordId = crypto.randomUUID();
      const checklist = await storage.createOtSafetyChecklist({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_safety_checklist", recordId, req.body);
      res.status(201).json(checklist);
    } catch (error) {
      console.error("Error creating safety checklist:", error);
      res.status(500).json({ error: "Failed to create safety checklist" });
    }
  });

  app.patch("/api/ot-cases/:caseId/safety-checklist/:id", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const checklist = await storage.updateOtSafetyChecklist(req.params.id, req.body);
      
      await logOtAction(req.params.caseId, "UPDATE", user.id, "ot_safety_checklist", req.params.id, req.body);
      res.json(checklist);
    } catch (error) {
      console.error("Error updating safety checklist:", error);
      res.status(500).json({ error: "Failed to update safety checklist" });
    }
  });

  // Pre-Op Assessment
  app.get("/api/ot-cases/:caseId/preop-assessment", requireAuth, async (req, res) => {
    try {
      const assessment = await storage.getOtPreopAssessment(req.params.caseId);
      res.json(assessment || null);
    } catch (error) {
      console.error("Error fetching assessment:", error);
      res.status(500).json({ error: "Failed to fetch assessment" });
    }
  });

  app.post("/api/ot-cases/:caseId/preop-assessment", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const recordId = crypto.randomUUID();
      const assessment = await storage.createOtPreopAssessment({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body,
        assessedBy: user.id
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_preop_assessment", recordId, req.body);
      res.status(201).json(assessment);
    } catch (error) {
      console.error("Error creating assessment:", error);
      res.status(500).json({ error: "Failed to create assessment" });
    }
  });

  app.patch("/api/ot-cases/:caseId/preop-assessment/:id", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const assessment = await storage.updateOtPreopAssessment(req.params.id, req.body);
      
      await logOtAction(req.params.caseId, "UPDATE", user.id, "ot_preop_assessment", req.params.id, req.body);
      res.json(assessment);
    } catch (error) {
      console.error("Error updating assessment:", error);
      res.status(500).json({ error: "Failed to update assessment" });
    }
  });

  // Re-Evaluation
  app.get("/api/ot-cases/:caseId/re-evaluation", requireAuth, async (req, res) => {
    try {
      const evaluations = await storage.getOtReEvaluation(req.params.caseId);
      res.json(evaluations);
    } catch (error) {
      console.error("Error fetching re-evaluations:", error);
      res.status(500).json({ error: "Failed to fetch re-evaluations" });
    }
  });

  app.post("/api/ot-cases/:caseId/re-evaluation", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const recordId = crypto.randomUUID();
      const evaluation = await storage.createOtReEvaluation({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body,
        evaluatedBy: user.id
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_re_evaluation", recordId, req.body);
      res.status(201).json(evaluation);
    } catch (error) {
      console.error("Error creating re-evaluation:", error);
      res.status(500).json({ error: "Failed to create re-evaluation" });
    }
  });

  // Consent Surgery
  app.get("/api/ot-cases/:caseId/consent-surgery", requireAuth, async (req, res) => {
    try {
      const consent = await storage.getOtConsentSurgery(req.params.caseId);
      res.json(consent || null);
    } catch (error) {
      console.error("Error fetching consent:", error);
      res.status(500).json({ error: "Failed to fetch consent" });
    }
  });

  app.post("/api/ot-cases/:caseId/consent-surgery", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const recordId = crypto.randomUUID();
      const consent = await storage.createOtConsentSurgery({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body,
        witnessedBy: user.id
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_consent_surgery", recordId, req.body);
      res.status(201).json(consent);
    } catch (error) {
      console.error("Error creating consent:", error);
      res.status(500).json({ error: "Failed to create consent" });
    }
  });

  app.patch("/api/ot-cases/:caseId/consent-surgery/:id", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const consent = await storage.updateOtConsentSurgery(req.params.id, req.body);
      
      await logOtAction(req.params.caseId, "UPDATE", user.id, "ot_consent_surgery", req.params.id, req.body);
      res.json(consent);
    } catch (error) {
      console.error("Error updating consent:", error);
      res.status(500).json({ error: "Failed to update consent" });
    }
  });

  // Consent Anaesthesia
  app.get("/api/ot-cases/:caseId/consent-anaesthesia", requireAuth, async (req, res) => {
    try {
      const consent = await storage.getOtConsentAnaesthesia(req.params.caseId);
      res.json(consent || null);
    } catch (error) {
      console.error("Error fetching anaesthesia consent:", error);
      res.status(500).json({ error: "Failed to fetch consent" });
    }
  });

  app.post("/api/ot-cases/:caseId/consent-anaesthesia", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const recordId = crypto.randomUUID();
      const consent = await storage.createOtConsentAnaesthesia({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body,
        witnessedBy: user.id
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_consent_anaesthesia", recordId, req.body);
      res.status(201).json(consent);
    } catch (error) {
      console.error("Error creating consent:", error);
      res.status(500).json({ error: "Failed to create consent" });
    }
  });

  app.patch("/api/ot-cases/:caseId/consent-anaesthesia/:id", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const consent = await storage.updateOtConsentAnaesthesia(req.params.id, req.body);
      
      await logOtAction(req.params.caseId, "UPDATE", user.id, "ot_consent_anaesthesia", req.params.id, req.body);
      res.json(consent);
    } catch (error) {
      console.error("Error updating consent:", error);
      res.status(500).json({ error: "Failed to update consent" });
    }
  });

  // Anaesthesia Record
  app.get("/api/ot-cases/:caseId/anaesthesia-record", requireAuth, async (req, res) => {
    try {
      const record = await storage.getOtAnaesthesiaRecord(req.params.caseId);
      res.json(record || null);
    } catch (error) {
      console.error("Error fetching anaesthesia record:", error);
      res.status(500).json({ error: "Failed to fetch record" });
    }
  });

  app.post("/api/ot-cases/:caseId/anaesthesia-record", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const recordId = crypto.randomUUID();
      const record = await storage.createOtAnaesthesiaRecord({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body,
        anaesthetistId: req.body.anaesthetistId || user.id
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_anaesthesia_record", recordId, req.body);
      res.status(201).json(record);
    } catch (error) {
      console.error("Error creating anaesthesia record:", error);
      res.status(500).json({ error: "Failed to create record" });
    }
  });

  app.patch("/api/ot-cases/:caseId/anaesthesia-record/:id", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const record = await storage.updateOtAnaesthesiaRecord(req.params.id, req.body);
      
      await logOtAction(req.params.caseId, "UPDATE", user.id, "ot_anaesthesia_record", req.params.id, req.body);
      res.json(record);
    } catch (error) {
      console.error("Error updating anaesthesia record:", error);
      res.status(500).json({ error: "Failed to update record" });
    }
  });

  // Time Log
  app.get("/api/ot-cases/:caseId/time-log", requireAuth, async (req, res) => {
    try {
      const logs = await storage.getOtTimeLog(req.params.caseId);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching time logs:", error);
      res.status(500).json({ error: "Failed to fetch time logs" });
    }
  });

  app.post("/api/ot-cases/:caseId/time-log", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const recordId = crypto.randomUUID();
      const log = await storage.createOtTimeLogEntry({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body,
        recordedBy: user.id
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_time_log", recordId, req.body);
      res.status(201).json(log);
    } catch (error) {
      console.error("Error creating time log:", error);
      res.status(500).json({ error: "Failed to create time log" });
    }
  });

  // Surgeon Notes
  app.get("/api/ot-cases/:caseId/surgeon-notes", requireAuth, async (req, res) => {
    try {
      const notes = await storage.getOtSurgeonNotes(req.params.caseId);
      res.json(notes || null);
    } catch (error) {
      console.error("Error fetching surgeon notes:", error);
      res.status(500).json({ error: "Failed to fetch notes" });
    }
  });

  app.post("/api/ot-cases/:caseId/surgeon-notes", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      if (!["SUPER_ADMIN", "ADMIN", "DOCTOR"].includes(user.role)) {
        return res.status(403).json({ error: "Only surgeons can create notes" });
      }
      
      const recordId = crypto.randomUUID();
      const notes = await storage.createOtSurgeonNotes({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body,
        surgeonId: user.id
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_surgeon_notes", recordId, req.body);
      res.status(201).json(notes);
    } catch (error) {
      console.error("Error creating surgeon notes:", error);
      res.status(500).json({ error: "Failed to create notes" });
    }
  });

  app.patch("/api/ot-cases/:caseId/surgeon-notes/:id", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const notes = await storage.updateOtSurgeonNotes(req.params.id, req.body);
      
      await logOtAction(req.params.caseId, "UPDATE", user.id, "ot_surgeon_notes", req.params.id, req.body);
      res.json(notes);
    } catch (error) {
      console.error("Error updating surgeon notes:", error);
      res.status(500).json({ error: "Failed to update notes" });
    }
  });

  // Post-Op Assessment
  app.get("/api/ot-cases/:caseId/postop-assessment", requireAuth, async (req, res) => {
    try {
      const assessments = await storage.getOtPostopAssessment(req.params.caseId);
      res.json(assessments);
    } catch (error) {
      console.error("Error fetching post-op assessments:", error);
      res.status(500).json({ error: "Failed to fetch assessments" });
    }
  });

  app.post("/api/ot-cases/:caseId/postop-assessment", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const recordId = crypto.randomUUID();
      const assessment = await storage.createOtPostopAssessment({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body,
        assessedBy: user.id
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_postop_assessment", recordId, req.body);
      res.status(201).json(assessment);
    } catch (error) {
      console.error("Error creating post-op assessment:", error);
      res.status(500).json({ error: "Failed to create assessment" });
    }
  });

  // Monitoring Chart
  app.get("/api/ot-cases/:caseId/monitoring-chart", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getOtMonitoringChart(req.params.caseId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching monitoring chart:", error);
      res.status(500).json({ error: "Failed to fetch chart" });
    }
  });

  app.post("/api/ot-cases/:caseId/monitoring-chart", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const recordId = crypto.randomUUID();
      const entry = await storage.createOtMonitoringChartEntry({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body,
        recordedBy: user.id
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_monitoring_chart", recordId, req.body);
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating monitoring entry:", error);
      res.status(500).json({ error: "Failed to create entry" });
    }
  });

  // Labour Chart
  app.get("/api/ot-cases/:caseId/labour-chart", requireAuth, async (req, res) => {
    try {
      const entries = await storage.getOtLabourChart(req.params.caseId);
      res.json(entries);
    } catch (error) {
      console.error("Error fetching labour chart:", error);
      res.status(500).json({ error: "Failed to fetch chart" });
    }
  });

  app.post("/api/ot-cases/:caseId/labour-chart", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const recordId = crypto.randomUUID();
      const entry = await storage.createOtLabourChartEntry({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body,
        recordedBy: user.id
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_labour_chart", recordId, req.body);
      res.status(201).json(entry);
    } catch (error) {
      console.error("Error creating labour chart entry:", error);
      res.status(500).json({ error: "Failed to create entry" });
    }
  });

  // Neonate Sheet
  app.get("/api/ot-cases/:caseId/neonate-sheet", requireAuth, async (req, res) => {
    try {
      const sheet = await storage.getOtNeonateSheet(req.params.caseId);
      res.json(sheet || null);
    } catch (error) {
      console.error("Error fetching neonate sheet:", error);
      res.status(500).json({ error: "Failed to fetch sheet" });
    }
  });

  app.post("/api/ot-cases/:caseId/neonate-sheet", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const recordId = crypto.randomUUID();
      const sheet = await storage.createOtNeonateSheet({
        id: recordId,
        caseId: req.params.caseId,
        ...req.body,
        attendedBy: user.id
      });
      
      await logOtAction(req.params.caseId, "CREATE", user.id, "ot_neonate_sheet", recordId, req.body);
      res.status(201).json(sheet);
    } catch (error) {
      console.error("Error creating neonate sheet:", error);
      res.status(500).json({ error: "Failed to create sheet" });
    }
  });

  app.patch("/api/ot-cases/:caseId/neonate-sheet/:id", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      const sheet = await storage.updateOtNeonateSheet(req.params.id, req.body);
      
      await logOtAction(req.params.caseId, "UPDATE", user.id, "ot_neonate_sheet", req.params.id, req.body);
      res.json(sheet);
    } catch (error) {
      console.error("Error updating neonate sheet:", error);
      res.status(500).json({ error: "Failed to update sheet" });
    }
  });

  // OT Audit Logs
  app.get("/api/ot-cases/:caseId/audit-logs", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      if (!["SUPER_ADMIN", "ADMIN"].includes(user.role)) {
        return res.status(403).json({ error: "Insufficient permissions" });
      }
      
      const logs = await storage.getOtAuditLogs(req.params.caseId);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching audit logs:", error);
      res.status(500).json({ error: "Failed to fetch audit logs" });
    }
  });

  // Get full OT case with all related data
  app.get("/api/ot-cases/:caseId/full", requireAuth, async (req, res) => {
    try {
      const user = req.user as any;
      if (!checkOtAccess(user.role)) {
        return res.status(403).json({ error: "Insufficient permissions" });
      }
      
      const [
        otCase, team, counselling, checklist, pae, safetyChecklist,
        assessment, reEvals, consentSurgery, consentAnaesthesia,
        anaesthesiaRecord, timeLog, surgeonNotes, postopAssessments,
        monitoringChart, labourChart, neonateSheet
      ] = await Promise.all([
        storage.getOtCaseById(req.params.caseId),
        storage.getOtCaseTeam(req.params.caseId),
        storage.getOtPreopCounselling(req.params.caseId),
        storage.getOtPreopChecklist(req.params.caseId),
        storage.getOtPreanaestheticEval(req.params.caseId),
        storage.getOtSafetyChecklist(req.params.caseId),
        storage.getOtPreopAssessment(req.params.caseId),
        storage.getOtReEvaluation(req.params.caseId),
        storage.getOtConsentSurgery(req.params.caseId),
        storage.getOtConsentAnaesthesia(req.params.caseId),
        storage.getOtAnaesthesiaRecord(req.params.caseId),
        storage.getOtTimeLog(req.params.caseId),
        storage.getOtSurgeonNotes(req.params.caseId),
        storage.getOtPostopAssessment(req.params.caseId),
        storage.getOtMonitoringChart(req.params.caseId),
        storage.getOtLabourChart(req.params.caseId),
        storage.getOtNeonateSheet(req.params.caseId)
      ]);
      
      if (!otCase) {
        return res.status(404).json({ error: "OT case not found" });
      }
      
      // Fetch patient details from tracking_patients (IPD patients) if available
      let patientDetails: any = {};
      try {
        const trackingPatient = await storage.getTrackingPatientById(otCase.patientId);
        if (trackingPatient) {
          patientDetails = {
            patientAge: trackingPatient.age,
            patientGender: trackingPatient.gender,
            room: trackingPatient.room,
            bedNumber: trackingPatient.room,
            bedNo: trackingPatient.room,
            ipdNumber: trackingPatient.id?.slice(0, 8).toUpperCase(),
            ipdNo: trackingPatient.id?.slice(0, 8).toUpperCase(),
            admissionDate: trackingPatient.admissionDate,
            doctorName: trackingPatient.doctor || trackingPatient.attendingDoctor || otCase.surgeonName,
            bloodGroup: trackingPatient.bloodGroup,
            diagnosis: trackingPatient.diagnosis,
          };
        }
      } catch (e) {
        // Patient details not found in IPD, continue with OT case basic info
      }
      
      res.json({
        ...otCase,
        ...patientDetails,
        team,
        preOp: { counselling, checklist, pae, safetyChecklist, assessment, reEvals },
        consents: { surgery: consentSurgery, anaesthesia: consentAnaesthesia },
        intraOp: { anaesthesiaRecord, timeLog, surgeonNotes },
        postOp: { assessments: postopAssessments, monitoringChart, labourChart, neonateSheet }
      });
    } catch (error) {
      console.error("Error fetching full OT case:", error);
      res.status(500).json({ error: "Failed to fetch OT case" });
    }
  });

  const httpServer = createServer(app);

  // Initialize WebSocket notification service
  notificationService.initialize(httpServer);

  // Start appointment reminder scheduler
  notificationService.startReminderScheduler();

  // Start health tip scheduler (9 AM and 9 PM IST daily)
  notificationService.startHealthTipScheduler();

  // Start birthday wish scheduler (9 AM IST daily)
  notificationService.startBirthdayScheduler();

  return httpServer;
}
